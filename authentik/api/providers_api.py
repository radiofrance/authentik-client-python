# coding: utf-8

"""
    authentik

    Making authentication simple.

    The version of the OpenAPI document: 2023.6.1
    Contact: hello@goauthentik.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr, conlist, constr

from typing import List, Optional, Union

from authentik.models.ldap_provider import LDAPProvider
from authentik.models.ldap_provider_request import LDAPProviderRequest
from authentik.models.o_auth2_provider import OAuth2Provider
from authentik.models.o_auth2_provider_request import OAuth2ProviderRequest
from authentik.models.o_auth2_provider_setup_urls import OAuth2ProviderSetupURLs
from authentik.models.paginated_ldap_provider_list import PaginatedLDAPProviderList
from authentik.models.paginated_o_auth2_provider_list import PaginatedOAuth2ProviderList
from authentik.models.paginated_provider_list import PaginatedProviderList
from authentik.models.paginated_proxy_provider_list import PaginatedProxyProviderList
from authentik.models.paginated_radius_provider_list import PaginatedRadiusProviderList
from authentik.models.paginated_saml_provider_list import PaginatedSAMLProviderList
from authentik.models.paginated_scim_provider_list import PaginatedSCIMProviderList
from authentik.models.patched_ldap_provider_request import PatchedLDAPProviderRequest
from authentik.models.patched_o_auth2_provider_request import PatchedOAuth2ProviderRequest
from authentik.models.patched_proxy_provider_request import PatchedProxyProviderRequest
from authentik.models.patched_radius_provider_request import PatchedRadiusProviderRequest
from authentik.models.patched_saml_provider_request import PatchedSAMLProviderRequest
from authentik.models.patched_scim_provider_request import PatchedSCIMProviderRequest
from authentik.models.property_mapping_preview import PropertyMappingPreview
from authentik.models.provider import Provider
from authentik.models.proxy_provider import ProxyProvider
from authentik.models.proxy_provider_request import ProxyProviderRequest
from authentik.models.radius_provider import RadiusProvider
from authentik.models.radius_provider_request import RadiusProviderRequest
from authentik.models.saml_metadata import SAMLMetadata
from authentik.models.saml_provider import SAMLProvider
from authentik.models.saml_provider_request import SAMLProviderRequest
from authentik.models.scim_provider import SCIMProvider
from authentik.models.scim_provider_request import SCIMProviderRequest
from authentik.models.task import Task
from authentik.models.type_create import TypeCreate
from authentik.models.used_by import UsedBy

from authentik.api_client import ApiClient
from authentik.api_response import ApiResponse
from authentik.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ProvidersApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def providers_all_destroy(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this provider.")], **kwargs) -> None:  # noqa: E501
        """providers_all_destroy  # noqa: E501

        Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_all_destroy(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_all_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_all_destroy_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_all_destroy_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_all_destroy  # noqa: E501

        Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_all_destroy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_all_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/providers/all/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_all_list(self, application__isnull : Optional[StrictBool] = None, backchannel_only : Optional[StrictBool] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> PaginatedProviderList:  # noqa: E501
        """providers_all_list  # noqa: E501

        Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_all_list(application__isnull, backchannel_only, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param application__isnull:
        :type application__isnull: bool
        :param backchannel_only:
        :type backchannel_only: bool
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedProviderList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_all_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_all_list_with_http_info(application__isnull, backchannel_only, ordering, page, page_size, search, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_all_list_with_http_info(self, application__isnull : Optional[StrictBool] = None, backchannel_only : Optional[StrictBool] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_all_list  # noqa: E501

        Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_all_list_with_http_info(application__isnull, backchannel_only, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param application__isnull:
        :type application__isnull: bool
        :param backchannel_only:
        :type backchannel_only: bool
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedProviderList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'application__isnull',
            'backchannel_only',
            'ordering',
            'page',
            'page_size',
            'search'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_all_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('application__isnull') is not None:  # noqa: E501
            _query_params.append(('application__isnull', _params['application__isnull']))

        if _params.get('backchannel_only') is not None:  # noqa: E501
            _query_params.append(('backchannel_only', _params['backchannel_only']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedProviderList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/all/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_all_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this provider.")], **kwargs) -> Provider:  # noqa: E501
        """providers_all_retrieve  # noqa: E501

        Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_all_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Provider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_all_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_all_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_all_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_all_retrieve  # noqa: E501

        Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_all_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Provider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_all_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Provider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/all/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_all_types_list(self, **kwargs) -> List[TypeCreate]:  # noqa: E501
        """providers_all_types_list  # noqa: E501

        Get all creatable provider types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_all_types_list(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[TypeCreate]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_all_types_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_all_types_list_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def providers_all_types_list_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_all_types_list  # noqa: E501

        Get all creatable provider types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_all_types_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[TypeCreate], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_all_types_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[TypeCreate]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/all/types/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_all_used_by_list(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this provider.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """providers_all_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_all_used_by_list(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_all_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_all_used_by_list_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_all_used_by_list_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_all_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_all_used_by_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_all_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/all/{id}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_ldap_create(self, ldap_provider_request : LDAPProviderRequest, **kwargs) -> LDAPProvider:  # noqa: E501
        """providers_ldap_create  # noqa: E501

        LDAPProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_create(ldap_provider_request, async_req=True)
        >>> result = thread.get()

        :param ldap_provider_request: (required)
        :type ldap_provider_request: LDAPProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LDAPProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_ldap_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_ldap_create_with_http_info(ldap_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_ldap_create_with_http_info(self, ldap_provider_request : LDAPProviderRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_ldap_create  # noqa: E501

        LDAPProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_create_with_http_info(ldap_provider_request, async_req=True)
        >>> result = thread.get()

        :param ldap_provider_request: (required)
        :type ldap_provider_request: LDAPProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LDAPProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ldap_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_ldap_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['ldap_provider_request'] is not None:
            _body_params = _params['ldap_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "LDAPProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/ldap/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_ldap_destroy(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this LDAP Provider.")], **kwargs) -> None:  # noqa: E501
        """providers_ldap_destroy  # noqa: E501

        LDAPProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_destroy(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this LDAP Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_ldap_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_ldap_destroy_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_ldap_destroy_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this LDAP Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_ldap_destroy  # noqa: E501

        LDAPProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_destroy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this LDAP Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_ldap_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/providers/ldap/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_ldap_list(self, application__isnull : Optional[StrictBool] = None, authorization_flow__slug__iexact : Optional[StrictStr] = None, base_dn__iexact : Optional[StrictStr] = None, certificate__kp_uuid__iexact : Optional[StrictStr] = None, certificate__name__iexact : Optional[StrictStr] = None, gid_start_number__iexact : Optional[StrictInt] = None, name__iexact : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, search_group__group_uuid__iexact : Optional[StrictStr] = None, search_group__name__iexact : Optional[StrictStr] = None, tls_server_name__iexact : Optional[StrictStr] = None, uid_start_number__iexact : Optional[StrictInt] = None, **kwargs) -> PaginatedLDAPProviderList:  # noqa: E501
        """providers_ldap_list  # noqa: E501

        LDAPProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_list(application__isnull, authorization_flow__slug__iexact, base_dn__iexact, certificate__kp_uuid__iexact, certificate__name__iexact, gid_start_number__iexact, name__iexact, ordering, page, page_size, search, search_group__group_uuid__iexact, search_group__name__iexact, tls_server_name__iexact, uid_start_number__iexact, async_req=True)
        >>> result = thread.get()

        :param application__isnull:
        :type application__isnull: bool
        :param authorization_flow__slug__iexact:
        :type authorization_flow__slug__iexact: str
        :param base_dn__iexact:
        :type base_dn__iexact: str
        :param certificate__kp_uuid__iexact:
        :type certificate__kp_uuid__iexact: str
        :param certificate__name__iexact:
        :type certificate__name__iexact: str
        :param gid_start_number__iexact:
        :type gid_start_number__iexact: int
        :param name__iexact:
        :type name__iexact: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param search_group__group_uuid__iexact:
        :type search_group__group_uuid__iexact: str
        :param search_group__name__iexact:
        :type search_group__name__iexact: str
        :param tls_server_name__iexact:
        :type tls_server_name__iexact: str
        :param uid_start_number__iexact:
        :type uid_start_number__iexact: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedLDAPProviderList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_ldap_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_ldap_list_with_http_info(application__isnull, authorization_flow__slug__iexact, base_dn__iexact, certificate__kp_uuid__iexact, certificate__name__iexact, gid_start_number__iexact, name__iexact, ordering, page, page_size, search, search_group__group_uuid__iexact, search_group__name__iexact, tls_server_name__iexact, uid_start_number__iexact, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_ldap_list_with_http_info(self, application__isnull : Optional[StrictBool] = None, authorization_flow__slug__iexact : Optional[StrictStr] = None, base_dn__iexact : Optional[StrictStr] = None, certificate__kp_uuid__iexact : Optional[StrictStr] = None, certificate__name__iexact : Optional[StrictStr] = None, gid_start_number__iexact : Optional[StrictInt] = None, name__iexact : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, search_group__group_uuid__iexact : Optional[StrictStr] = None, search_group__name__iexact : Optional[StrictStr] = None, tls_server_name__iexact : Optional[StrictStr] = None, uid_start_number__iexact : Optional[StrictInt] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_ldap_list  # noqa: E501

        LDAPProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_list_with_http_info(application__isnull, authorization_flow__slug__iexact, base_dn__iexact, certificate__kp_uuid__iexact, certificate__name__iexact, gid_start_number__iexact, name__iexact, ordering, page, page_size, search, search_group__group_uuid__iexact, search_group__name__iexact, tls_server_name__iexact, uid_start_number__iexact, async_req=True)
        >>> result = thread.get()

        :param application__isnull:
        :type application__isnull: bool
        :param authorization_flow__slug__iexact:
        :type authorization_flow__slug__iexact: str
        :param base_dn__iexact:
        :type base_dn__iexact: str
        :param certificate__kp_uuid__iexact:
        :type certificate__kp_uuid__iexact: str
        :param certificate__name__iexact:
        :type certificate__name__iexact: str
        :param gid_start_number__iexact:
        :type gid_start_number__iexact: int
        :param name__iexact:
        :type name__iexact: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param search_group__group_uuid__iexact:
        :type search_group__group_uuid__iexact: str
        :param search_group__name__iexact:
        :type search_group__name__iexact: str
        :param tls_server_name__iexact:
        :type tls_server_name__iexact: str
        :param uid_start_number__iexact:
        :type uid_start_number__iexact: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedLDAPProviderList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'application__isnull',
            'authorization_flow__slug__iexact',
            'base_dn__iexact',
            'certificate__kp_uuid__iexact',
            'certificate__name__iexact',
            'gid_start_number__iexact',
            'name__iexact',
            'ordering',
            'page',
            'page_size',
            'search',
            'search_group__group_uuid__iexact',
            'search_group__name__iexact',
            'tls_server_name__iexact',
            'uid_start_number__iexact'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_ldap_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('application__isnull') is not None:  # noqa: E501
            _query_params.append(('application__isnull', _params['application__isnull']))

        if _params.get('authorization_flow__slug__iexact') is not None:  # noqa: E501
            _query_params.append(('authorization_flow__slug__iexact', _params['authorization_flow__slug__iexact']))

        if _params.get('base_dn__iexact') is not None:  # noqa: E501
            _query_params.append(('base_dn__iexact', _params['base_dn__iexact']))

        if _params.get('certificate__kp_uuid__iexact') is not None:  # noqa: E501
            _query_params.append(('certificate__kp_uuid__iexact', _params['certificate__kp_uuid__iexact']))

        if _params.get('certificate__name__iexact') is not None:  # noqa: E501
            _query_params.append(('certificate__name__iexact', _params['certificate__name__iexact']))

        if _params.get('gid_start_number__iexact') is not None:  # noqa: E501
            _query_params.append(('gid_start_number__iexact', _params['gid_start_number__iexact']))

        if _params.get('name__iexact') is not None:  # noqa: E501
            _query_params.append(('name__iexact', _params['name__iexact']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('search_group__group_uuid__iexact') is not None:  # noqa: E501
            _query_params.append(('search_group__group_uuid__iexact', _params['search_group__group_uuid__iexact']))

        if _params.get('search_group__name__iexact') is not None:  # noqa: E501
            _query_params.append(('search_group__name__iexact', _params['search_group__name__iexact']))

        if _params.get('tls_server_name__iexact') is not None:  # noqa: E501
            _query_params.append(('tls_server_name__iexact', _params['tls_server_name__iexact']))

        if _params.get('uid_start_number__iexact') is not None:  # noqa: E501
            _query_params.append(('uid_start_number__iexact', _params['uid_start_number__iexact']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedLDAPProviderList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/ldap/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_ldap_partial_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this LDAP Provider.")], patched_ldap_provider_request : Optional[PatchedLDAPProviderRequest] = None, **kwargs) -> LDAPProvider:  # noqa: E501
        """providers_ldap_partial_update  # noqa: E501

        LDAPProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_partial_update(id, patched_ldap_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this LDAP Provider. (required)
        :type id: int
        :param patched_ldap_provider_request:
        :type patched_ldap_provider_request: PatchedLDAPProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LDAPProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_ldap_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_ldap_partial_update_with_http_info(id, patched_ldap_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_ldap_partial_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this LDAP Provider.")], patched_ldap_provider_request : Optional[PatchedLDAPProviderRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_ldap_partial_update  # noqa: E501

        LDAPProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_partial_update_with_http_info(id, patched_ldap_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this LDAP Provider. (required)
        :type id: int
        :param patched_ldap_provider_request:
        :type patched_ldap_provider_request: PatchedLDAPProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LDAPProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'patched_ldap_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_ldap_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_ldap_provider_request'] is not None:
            _body_params = _params['patched_ldap_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "LDAPProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/ldap/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_ldap_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this LDAP Provider.")], **kwargs) -> LDAPProvider:  # noqa: E501
        """providers_ldap_retrieve  # noqa: E501

        LDAPProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this LDAP Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LDAPProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_ldap_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_ldap_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_ldap_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this LDAP Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_ldap_retrieve  # noqa: E501

        LDAPProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this LDAP Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LDAPProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_ldap_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "LDAPProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/ldap/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_ldap_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this LDAP Provider.")], ldap_provider_request : LDAPProviderRequest, **kwargs) -> LDAPProvider:  # noqa: E501
        """providers_ldap_update  # noqa: E501

        LDAPProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_update(id, ldap_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this LDAP Provider. (required)
        :type id: int
        :param ldap_provider_request: (required)
        :type ldap_provider_request: LDAPProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LDAPProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_ldap_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_ldap_update_with_http_info(id, ldap_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_ldap_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this LDAP Provider.")], ldap_provider_request : LDAPProviderRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_ldap_update  # noqa: E501

        LDAPProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_update_with_http_info(id, ldap_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this LDAP Provider. (required)
        :type id: int
        :param ldap_provider_request: (required)
        :type ldap_provider_request: LDAPProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LDAPProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'ldap_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_ldap_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['ldap_provider_request'] is not None:
            _body_params = _params['ldap_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "LDAPProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/ldap/{id}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_ldap_used_by_list(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this LDAP Provider.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """providers_ldap_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_used_by_list(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this LDAP Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_ldap_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_ldap_used_by_list_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_ldap_used_by_list_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this LDAP Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_ldap_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_ldap_used_by_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this LDAP Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_ldap_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/ldap/{id}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_oauth2_create(self, o_auth2_provider_request : OAuth2ProviderRequest, **kwargs) -> OAuth2Provider:  # noqa: E501
        """providers_oauth2_create  # noqa: E501

        OAuth2Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_create(o_auth2_provider_request, async_req=True)
        >>> result = thread.get()

        :param o_auth2_provider_request: (required)
        :type o_auth2_provider_request: OAuth2ProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OAuth2Provider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_oauth2_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_oauth2_create_with_http_info(o_auth2_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_oauth2_create_with_http_info(self, o_auth2_provider_request : OAuth2ProviderRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_oauth2_create  # noqa: E501

        OAuth2Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_create_with_http_info(o_auth2_provider_request, async_req=True)
        >>> result = thread.get()

        :param o_auth2_provider_request: (required)
        :type o_auth2_provider_request: OAuth2ProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OAuth2Provider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'o_auth2_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_oauth2_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['o_auth2_provider_request'] is not None:
            _body_params = _params['o_auth2_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "OAuth2Provider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/oauth2/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_oauth2_destroy(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], **kwargs) -> None:  # noqa: E501
        """providers_oauth2_destroy  # noqa: E501

        OAuth2Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_destroy(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_oauth2_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_oauth2_destroy_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_oauth2_destroy_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_oauth2_destroy  # noqa: E501

        OAuth2Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_destroy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_oauth2_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/providers/oauth2/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_oauth2_list(self, access_code_validity : Optional[StrictStr] = None, access_token_validity : Optional[StrictStr] = None, application : Optional[StrictStr] = None, authorization_flow : Optional[StrictStr] = None, client_id : Optional[StrictStr] = None, client_type : Annotated[Optional[StrictStr], Field(description="Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable  * `confidential` - Confidential * `public` - Public")] = None, include_claims_in_id_token : Optional[StrictBool] = None, issuer_mode : Annotated[Optional[StrictStr], Field(description="Configure how the issuer field of the ID Token should be filled.  * `global` - Same identifier is used for all providers * `per_provider` - Each provider has a different issuer, based on the application slug.")] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, property_mappings : Optional[conlist(StrictStr)] = None, redirect_uris : Optional[StrictStr] = None, refresh_token_validity : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, signing_key : Optional[StrictStr] = None, sub_mode : Annotated[Optional[StrictStr], Field(description="Configure what data should be used as unique User Identifier. For most cases, the default should be fine.  * `hashed_user_id` - Based on the Hashed User ID * `user_id` - Based on user ID * `user_uuid` - Based on user UUID * `user_username` - Based on the username * `user_email` - Based on the User's Email. This is recommended over the UPN method. * `user_upn` - Based on the User's UPN, only works if user has a 'upn' attribute set. Use this method only if you have different UPN and Mail domains.")] = None, **kwargs) -> PaginatedOAuth2ProviderList:  # noqa: E501
        """providers_oauth2_list  # noqa: E501

        OAuth2Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_list(access_code_validity, access_token_validity, application, authorization_flow, client_id, client_type, include_claims_in_id_token, issuer_mode, name, ordering, page, page_size, property_mappings, redirect_uris, refresh_token_validity, search, signing_key, sub_mode, async_req=True)
        >>> result = thread.get()

        :param access_code_validity:
        :type access_code_validity: str
        :param access_token_validity:
        :type access_token_validity: str
        :param application:
        :type application: str
        :param authorization_flow:
        :type authorization_flow: str
        :param client_id:
        :type client_id: str
        :param client_type: Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable  * `confidential` - Confidential * `public` - Public
        :type client_type: str
        :param include_claims_in_id_token:
        :type include_claims_in_id_token: bool
        :param issuer_mode: Configure how the issuer field of the ID Token should be filled.  * `global` - Same identifier is used for all providers * `per_provider` - Each provider has a different issuer, based on the application slug.
        :type issuer_mode: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param property_mappings:
        :type property_mappings: List[str]
        :param redirect_uris:
        :type redirect_uris: str
        :param refresh_token_validity:
        :type refresh_token_validity: str
        :param search: A search term.
        :type search: str
        :param signing_key:
        :type signing_key: str
        :param sub_mode: Configure what data should be used as unique User Identifier. For most cases, the default should be fine.  * `hashed_user_id` - Based on the Hashed User ID * `user_id` - Based on user ID * `user_uuid` - Based on user UUID * `user_username` - Based on the username * `user_email` - Based on the User's Email. This is recommended over the UPN method. * `user_upn` - Based on the User's UPN, only works if user has a 'upn' attribute set. Use this method only if you have different UPN and Mail domains.
        :type sub_mode: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedOAuth2ProviderList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_oauth2_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_oauth2_list_with_http_info(access_code_validity, access_token_validity, application, authorization_flow, client_id, client_type, include_claims_in_id_token, issuer_mode, name, ordering, page, page_size, property_mappings, redirect_uris, refresh_token_validity, search, signing_key, sub_mode, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_oauth2_list_with_http_info(self, access_code_validity : Optional[StrictStr] = None, access_token_validity : Optional[StrictStr] = None, application : Optional[StrictStr] = None, authorization_flow : Optional[StrictStr] = None, client_id : Optional[StrictStr] = None, client_type : Annotated[Optional[StrictStr], Field(description="Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable  * `confidential` - Confidential * `public` - Public")] = None, include_claims_in_id_token : Optional[StrictBool] = None, issuer_mode : Annotated[Optional[StrictStr], Field(description="Configure how the issuer field of the ID Token should be filled.  * `global` - Same identifier is used for all providers * `per_provider` - Each provider has a different issuer, based on the application slug.")] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, property_mappings : Optional[conlist(StrictStr)] = None, redirect_uris : Optional[StrictStr] = None, refresh_token_validity : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, signing_key : Optional[StrictStr] = None, sub_mode : Annotated[Optional[StrictStr], Field(description="Configure what data should be used as unique User Identifier. For most cases, the default should be fine.  * `hashed_user_id` - Based on the Hashed User ID * `user_id` - Based on user ID * `user_uuid` - Based on user UUID * `user_username` - Based on the username * `user_email` - Based on the User's Email. This is recommended over the UPN method. * `user_upn` - Based on the User's UPN, only works if user has a 'upn' attribute set. Use this method only if you have different UPN and Mail domains.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_oauth2_list  # noqa: E501

        OAuth2Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_list_with_http_info(access_code_validity, access_token_validity, application, authorization_flow, client_id, client_type, include_claims_in_id_token, issuer_mode, name, ordering, page, page_size, property_mappings, redirect_uris, refresh_token_validity, search, signing_key, sub_mode, async_req=True)
        >>> result = thread.get()

        :param access_code_validity:
        :type access_code_validity: str
        :param access_token_validity:
        :type access_token_validity: str
        :param application:
        :type application: str
        :param authorization_flow:
        :type authorization_flow: str
        :param client_id:
        :type client_id: str
        :param client_type: Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable  * `confidential` - Confidential * `public` - Public
        :type client_type: str
        :param include_claims_in_id_token:
        :type include_claims_in_id_token: bool
        :param issuer_mode: Configure how the issuer field of the ID Token should be filled.  * `global` - Same identifier is used for all providers * `per_provider` - Each provider has a different issuer, based on the application slug.
        :type issuer_mode: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param property_mappings:
        :type property_mappings: List[str]
        :param redirect_uris:
        :type redirect_uris: str
        :param refresh_token_validity:
        :type refresh_token_validity: str
        :param search: A search term.
        :type search: str
        :param signing_key:
        :type signing_key: str
        :param sub_mode: Configure what data should be used as unique User Identifier. For most cases, the default should be fine.  * `hashed_user_id` - Based on the Hashed User ID * `user_id` - Based on user ID * `user_uuid` - Based on user UUID * `user_username` - Based on the username * `user_email` - Based on the User's Email. This is recommended over the UPN method. * `user_upn` - Based on the User's UPN, only works if user has a 'upn' attribute set. Use this method only if you have different UPN and Mail domains.
        :type sub_mode: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedOAuth2ProviderList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'access_code_validity',
            'access_token_validity',
            'application',
            'authorization_flow',
            'client_id',
            'client_type',
            'include_claims_in_id_token',
            'issuer_mode',
            'name',
            'ordering',
            'page',
            'page_size',
            'property_mappings',
            'redirect_uris',
            'refresh_token_validity',
            'search',
            'signing_key',
            'sub_mode'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_oauth2_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('access_code_validity') is not None:  # noqa: E501
            _query_params.append(('access_code_validity', _params['access_code_validity']))

        if _params.get('access_token_validity') is not None:  # noqa: E501
            _query_params.append(('access_token_validity', _params['access_token_validity']))

        if _params.get('application') is not None:  # noqa: E501
            _query_params.append(('application', _params['application']))

        if _params.get('authorization_flow') is not None:  # noqa: E501
            _query_params.append(('authorization_flow', _params['authorization_flow']))

        if _params.get('client_id') is not None:  # noqa: E501
            _query_params.append(('client_id', _params['client_id']))

        if _params.get('client_type') is not None:  # noqa: E501
            _query_params.append(('client_type', _params['client_type']))

        if _params.get('include_claims_in_id_token') is not None:  # noqa: E501
            _query_params.append(('include_claims_in_id_token', _params['include_claims_in_id_token']))

        if _params.get('issuer_mode') is not None:  # noqa: E501
            _query_params.append(('issuer_mode', _params['issuer_mode']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('property_mappings') is not None:  # noqa: E501
            _query_params.append(('property_mappings', _params['property_mappings']))
            _collection_formats['property_mappings'] = 'multi'

        if _params.get('redirect_uris') is not None:  # noqa: E501
            _query_params.append(('redirect_uris', _params['redirect_uris']))

        if _params.get('refresh_token_validity') is not None:  # noqa: E501
            _query_params.append(('refresh_token_validity', _params['refresh_token_validity']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('signing_key') is not None:  # noqa: E501
            _query_params.append(('signing_key', _params['signing_key']))

        if _params.get('sub_mode') is not None:  # noqa: E501
            _query_params.append(('sub_mode', _params['sub_mode']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedOAuth2ProviderList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/oauth2/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_oauth2_partial_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], patched_o_auth2_provider_request : Optional[PatchedOAuth2ProviderRequest] = None, **kwargs) -> OAuth2Provider:  # noqa: E501
        """providers_oauth2_partial_update  # noqa: E501

        OAuth2Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_partial_update(id, patched_o_auth2_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param patched_o_auth2_provider_request:
        :type patched_o_auth2_provider_request: PatchedOAuth2ProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OAuth2Provider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_oauth2_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_oauth2_partial_update_with_http_info(id, patched_o_auth2_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_oauth2_partial_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], patched_o_auth2_provider_request : Optional[PatchedOAuth2ProviderRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_oauth2_partial_update  # noqa: E501

        OAuth2Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_partial_update_with_http_info(id, patched_o_auth2_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param patched_o_auth2_provider_request:
        :type patched_o_auth2_provider_request: PatchedOAuth2ProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OAuth2Provider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'patched_o_auth2_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_oauth2_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_o_auth2_provider_request'] is not None:
            _body_params = _params['patched_o_auth2_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "OAuth2Provider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/oauth2/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_oauth2_preview_user_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], **kwargs) -> PropertyMappingPreview:  # noqa: E501
        """providers_oauth2_preview_user_retrieve  # noqa: E501

        Preview user data for provider  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_preview_user_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PropertyMappingPreview
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_oauth2_preview_user_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_oauth2_preview_user_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_oauth2_preview_user_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_oauth2_preview_user_retrieve  # noqa: E501

        Preview user data for provider  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_preview_user_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PropertyMappingPreview, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_oauth2_preview_user_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PropertyMappingPreview",
            '400': None,
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/oauth2/{id}/preview_user/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_oauth2_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], **kwargs) -> OAuth2Provider:  # noqa: E501
        """providers_oauth2_retrieve  # noqa: E501

        OAuth2Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OAuth2Provider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_oauth2_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_oauth2_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_oauth2_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_oauth2_retrieve  # noqa: E501

        OAuth2Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OAuth2Provider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_oauth2_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "OAuth2Provider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/oauth2/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_oauth2_setup_urls_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], **kwargs) -> OAuth2ProviderSetupURLs:  # noqa: E501
        """providers_oauth2_setup_urls_retrieve  # noqa: E501

        Get Providers setup URLs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_setup_urls_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OAuth2ProviderSetupURLs
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_oauth2_setup_urls_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_oauth2_setup_urls_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_oauth2_setup_urls_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_oauth2_setup_urls_retrieve  # noqa: E501

        Get Providers setup URLs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_setup_urls_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OAuth2ProviderSetupURLs, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_oauth2_setup_urls_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "OAuth2ProviderSetupURLs",
            '404': None,
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/oauth2/{id}/setup_urls/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_oauth2_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], o_auth2_provider_request : OAuth2ProviderRequest, **kwargs) -> OAuth2Provider:  # noqa: E501
        """providers_oauth2_update  # noqa: E501

        OAuth2Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_update(id, o_auth2_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param o_auth2_provider_request: (required)
        :type o_auth2_provider_request: OAuth2ProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OAuth2Provider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_oauth2_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_oauth2_update_with_http_info(id, o_auth2_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_oauth2_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], o_auth2_provider_request : OAuth2ProviderRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_oauth2_update  # noqa: E501

        OAuth2Provider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_update_with_http_info(id, o_auth2_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param o_auth2_provider_request: (required)
        :type o_auth2_provider_request: OAuth2ProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OAuth2Provider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'o_auth2_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_oauth2_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['o_auth2_provider_request'] is not None:
            _body_params = _params['o_auth2_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "OAuth2Provider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/oauth2/{id}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_oauth2_used_by_list(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """providers_oauth2_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_used_by_list(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_oauth2_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_oauth2_used_by_list_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_oauth2_used_by_list_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this OAuth2/OpenID Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_oauth2_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_oauth2_used_by_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this OAuth2/OpenID Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_oauth2_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/oauth2/{id}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_proxy_create(self, proxy_provider_request : ProxyProviderRequest, **kwargs) -> ProxyProvider:  # noqa: E501
        """providers_proxy_create  # noqa: E501

        ProxyProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_create(proxy_provider_request, async_req=True)
        >>> result = thread.get()

        :param proxy_provider_request: (required)
        :type proxy_provider_request: ProxyProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProxyProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_proxy_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_proxy_create_with_http_info(proxy_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_proxy_create_with_http_info(self, proxy_provider_request : ProxyProviderRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_proxy_create  # noqa: E501

        ProxyProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_create_with_http_info(proxy_provider_request, async_req=True)
        >>> result = thread.get()

        :param proxy_provider_request: (required)
        :type proxy_provider_request: ProxyProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProxyProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'proxy_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_proxy_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['proxy_provider_request'] is not None:
            _body_params = _params['proxy_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "ProxyProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/proxy/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_proxy_destroy(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Proxy Provider.")], **kwargs) -> None:  # noqa: E501
        """providers_proxy_destroy  # noqa: E501

        ProxyProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_destroy(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Proxy Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_proxy_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_proxy_destroy_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_proxy_destroy_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Proxy Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_proxy_destroy  # noqa: E501

        ProxyProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_destroy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Proxy Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_proxy_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/providers/proxy/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_proxy_list(self, application__isnull : Optional[StrictBool] = None, authorization_flow__slug__iexact : Optional[StrictStr] = None, basic_auth_enabled__iexact : Optional[StrictBool] = None, basic_auth_password_attribute__iexact : Optional[StrictStr] = None, basic_auth_user_attribute__iexact : Optional[StrictStr] = None, certificate__kp_uuid__iexact : Optional[StrictStr] = None, certificate__name__iexact : Optional[StrictStr] = None, cookie_domain__iexact : Optional[StrictStr] = None, external_host__iexact : Optional[StrictStr] = None, internal_host__iexact : Optional[StrictStr] = None, internal_host_ssl_validation__iexact : Optional[StrictBool] = None, mode__iexact : Optional[StrictStr] = None, name__iexact : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, property_mappings__iexact : Optional[conlist(StrictStr)] = None, redirect_uris__iexact : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, skip_path_regex__iexact : Optional[StrictStr] = None, **kwargs) -> PaginatedProxyProviderList:  # noqa: E501
        """providers_proxy_list  # noqa: E501

        ProxyProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_list(application__isnull, authorization_flow__slug__iexact, basic_auth_enabled__iexact, basic_auth_password_attribute__iexact, basic_auth_user_attribute__iexact, certificate__kp_uuid__iexact, certificate__name__iexact, cookie_domain__iexact, external_host__iexact, internal_host__iexact, internal_host_ssl_validation__iexact, mode__iexact, name__iexact, ordering, page, page_size, property_mappings__iexact, redirect_uris__iexact, search, skip_path_regex__iexact, async_req=True)
        >>> result = thread.get()

        :param application__isnull:
        :type application__isnull: bool
        :param authorization_flow__slug__iexact:
        :type authorization_flow__slug__iexact: str
        :param basic_auth_enabled__iexact:
        :type basic_auth_enabled__iexact: bool
        :param basic_auth_password_attribute__iexact:
        :type basic_auth_password_attribute__iexact: str
        :param basic_auth_user_attribute__iexact:
        :type basic_auth_user_attribute__iexact: str
        :param certificate__kp_uuid__iexact:
        :type certificate__kp_uuid__iexact: str
        :param certificate__name__iexact:
        :type certificate__name__iexact: str
        :param cookie_domain__iexact:
        :type cookie_domain__iexact: str
        :param external_host__iexact:
        :type external_host__iexact: str
        :param internal_host__iexact:
        :type internal_host__iexact: str
        :param internal_host_ssl_validation__iexact:
        :type internal_host_ssl_validation__iexact: bool
        :param mode__iexact:
        :type mode__iexact: str
        :param name__iexact:
        :type name__iexact: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param property_mappings__iexact:
        :type property_mappings__iexact: List[str]
        :param redirect_uris__iexact:
        :type redirect_uris__iexact: str
        :param search: A search term.
        :type search: str
        :param skip_path_regex__iexact:
        :type skip_path_regex__iexact: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedProxyProviderList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_proxy_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_proxy_list_with_http_info(application__isnull, authorization_flow__slug__iexact, basic_auth_enabled__iexact, basic_auth_password_attribute__iexact, basic_auth_user_attribute__iexact, certificate__kp_uuid__iexact, certificate__name__iexact, cookie_domain__iexact, external_host__iexact, internal_host__iexact, internal_host_ssl_validation__iexact, mode__iexact, name__iexact, ordering, page, page_size, property_mappings__iexact, redirect_uris__iexact, search, skip_path_regex__iexact, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_proxy_list_with_http_info(self, application__isnull : Optional[StrictBool] = None, authorization_flow__slug__iexact : Optional[StrictStr] = None, basic_auth_enabled__iexact : Optional[StrictBool] = None, basic_auth_password_attribute__iexact : Optional[StrictStr] = None, basic_auth_user_attribute__iexact : Optional[StrictStr] = None, certificate__kp_uuid__iexact : Optional[StrictStr] = None, certificate__name__iexact : Optional[StrictStr] = None, cookie_domain__iexact : Optional[StrictStr] = None, external_host__iexact : Optional[StrictStr] = None, internal_host__iexact : Optional[StrictStr] = None, internal_host_ssl_validation__iexact : Optional[StrictBool] = None, mode__iexact : Optional[StrictStr] = None, name__iexact : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, property_mappings__iexact : Optional[conlist(StrictStr)] = None, redirect_uris__iexact : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, skip_path_regex__iexact : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_proxy_list  # noqa: E501

        ProxyProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_list_with_http_info(application__isnull, authorization_flow__slug__iexact, basic_auth_enabled__iexact, basic_auth_password_attribute__iexact, basic_auth_user_attribute__iexact, certificate__kp_uuid__iexact, certificate__name__iexact, cookie_domain__iexact, external_host__iexact, internal_host__iexact, internal_host_ssl_validation__iexact, mode__iexact, name__iexact, ordering, page, page_size, property_mappings__iexact, redirect_uris__iexact, search, skip_path_regex__iexact, async_req=True)
        >>> result = thread.get()

        :param application__isnull:
        :type application__isnull: bool
        :param authorization_flow__slug__iexact:
        :type authorization_flow__slug__iexact: str
        :param basic_auth_enabled__iexact:
        :type basic_auth_enabled__iexact: bool
        :param basic_auth_password_attribute__iexact:
        :type basic_auth_password_attribute__iexact: str
        :param basic_auth_user_attribute__iexact:
        :type basic_auth_user_attribute__iexact: str
        :param certificate__kp_uuid__iexact:
        :type certificate__kp_uuid__iexact: str
        :param certificate__name__iexact:
        :type certificate__name__iexact: str
        :param cookie_domain__iexact:
        :type cookie_domain__iexact: str
        :param external_host__iexact:
        :type external_host__iexact: str
        :param internal_host__iexact:
        :type internal_host__iexact: str
        :param internal_host_ssl_validation__iexact:
        :type internal_host_ssl_validation__iexact: bool
        :param mode__iexact:
        :type mode__iexact: str
        :param name__iexact:
        :type name__iexact: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param property_mappings__iexact:
        :type property_mappings__iexact: List[str]
        :param redirect_uris__iexact:
        :type redirect_uris__iexact: str
        :param search: A search term.
        :type search: str
        :param skip_path_regex__iexact:
        :type skip_path_regex__iexact: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedProxyProviderList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'application__isnull',
            'authorization_flow__slug__iexact',
            'basic_auth_enabled__iexact',
            'basic_auth_password_attribute__iexact',
            'basic_auth_user_attribute__iexact',
            'certificate__kp_uuid__iexact',
            'certificate__name__iexact',
            'cookie_domain__iexact',
            'external_host__iexact',
            'internal_host__iexact',
            'internal_host_ssl_validation__iexact',
            'mode__iexact',
            'name__iexact',
            'ordering',
            'page',
            'page_size',
            'property_mappings__iexact',
            'redirect_uris__iexact',
            'search',
            'skip_path_regex__iexact'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_proxy_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('application__isnull') is not None:  # noqa: E501
            _query_params.append(('application__isnull', _params['application__isnull']))

        if _params.get('authorization_flow__slug__iexact') is not None:  # noqa: E501
            _query_params.append(('authorization_flow__slug__iexact', _params['authorization_flow__slug__iexact']))

        if _params.get('basic_auth_enabled__iexact') is not None:  # noqa: E501
            _query_params.append(('basic_auth_enabled__iexact', _params['basic_auth_enabled__iexact']))

        if _params.get('basic_auth_password_attribute__iexact') is not None:  # noqa: E501
            _query_params.append(('basic_auth_password_attribute__iexact', _params['basic_auth_password_attribute__iexact']))

        if _params.get('basic_auth_user_attribute__iexact') is not None:  # noqa: E501
            _query_params.append(('basic_auth_user_attribute__iexact', _params['basic_auth_user_attribute__iexact']))

        if _params.get('certificate__kp_uuid__iexact') is not None:  # noqa: E501
            _query_params.append(('certificate__kp_uuid__iexact', _params['certificate__kp_uuid__iexact']))

        if _params.get('certificate__name__iexact') is not None:  # noqa: E501
            _query_params.append(('certificate__name__iexact', _params['certificate__name__iexact']))

        if _params.get('cookie_domain__iexact') is not None:  # noqa: E501
            _query_params.append(('cookie_domain__iexact', _params['cookie_domain__iexact']))

        if _params.get('external_host__iexact') is not None:  # noqa: E501
            _query_params.append(('external_host__iexact', _params['external_host__iexact']))

        if _params.get('internal_host__iexact') is not None:  # noqa: E501
            _query_params.append(('internal_host__iexact', _params['internal_host__iexact']))

        if _params.get('internal_host_ssl_validation__iexact') is not None:  # noqa: E501
            _query_params.append(('internal_host_ssl_validation__iexact', _params['internal_host_ssl_validation__iexact']))

        if _params.get('mode__iexact') is not None:  # noqa: E501
            _query_params.append(('mode__iexact', _params['mode__iexact']))

        if _params.get('name__iexact') is not None:  # noqa: E501
            _query_params.append(('name__iexact', _params['name__iexact']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('property_mappings__iexact') is not None:  # noqa: E501
            _query_params.append(('property_mappings__iexact', _params['property_mappings__iexact']))
            _collection_formats['property_mappings__iexact'] = 'multi'

        if _params.get('redirect_uris__iexact') is not None:  # noqa: E501
            _query_params.append(('redirect_uris__iexact', _params['redirect_uris__iexact']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('skip_path_regex__iexact') is not None:  # noqa: E501
            _query_params.append(('skip_path_regex__iexact', _params['skip_path_regex__iexact']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedProxyProviderList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/proxy/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_proxy_partial_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Proxy Provider.")], patched_proxy_provider_request : Optional[PatchedProxyProviderRequest] = None, **kwargs) -> ProxyProvider:  # noqa: E501
        """providers_proxy_partial_update  # noqa: E501

        ProxyProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_partial_update(id, patched_proxy_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Proxy Provider. (required)
        :type id: int
        :param patched_proxy_provider_request:
        :type patched_proxy_provider_request: PatchedProxyProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProxyProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_proxy_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_proxy_partial_update_with_http_info(id, patched_proxy_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_proxy_partial_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Proxy Provider.")], patched_proxy_provider_request : Optional[PatchedProxyProviderRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_proxy_partial_update  # noqa: E501

        ProxyProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_partial_update_with_http_info(id, patched_proxy_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Proxy Provider. (required)
        :type id: int
        :param patched_proxy_provider_request:
        :type patched_proxy_provider_request: PatchedProxyProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProxyProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'patched_proxy_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_proxy_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_proxy_provider_request'] is not None:
            _body_params = _params['patched_proxy_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "ProxyProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/proxy/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_proxy_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Proxy Provider.")], **kwargs) -> ProxyProvider:  # noqa: E501
        """providers_proxy_retrieve  # noqa: E501

        ProxyProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Proxy Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProxyProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_proxy_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_proxy_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_proxy_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Proxy Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_proxy_retrieve  # noqa: E501

        ProxyProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Proxy Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProxyProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_proxy_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "ProxyProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/proxy/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_proxy_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Proxy Provider.")], proxy_provider_request : ProxyProviderRequest, **kwargs) -> ProxyProvider:  # noqa: E501
        """providers_proxy_update  # noqa: E501

        ProxyProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_update(id, proxy_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Proxy Provider. (required)
        :type id: int
        :param proxy_provider_request: (required)
        :type proxy_provider_request: ProxyProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProxyProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_proxy_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_proxy_update_with_http_info(id, proxy_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_proxy_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Proxy Provider.")], proxy_provider_request : ProxyProviderRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_proxy_update  # noqa: E501

        ProxyProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_update_with_http_info(id, proxy_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Proxy Provider. (required)
        :type id: int
        :param proxy_provider_request: (required)
        :type proxy_provider_request: ProxyProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProxyProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'proxy_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_proxy_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['proxy_provider_request'] is not None:
            _body_params = _params['proxy_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "ProxyProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/proxy/{id}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_proxy_used_by_list(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Proxy Provider.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """providers_proxy_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_used_by_list(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Proxy Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_proxy_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_proxy_used_by_list_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_proxy_used_by_list_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Proxy Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_proxy_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_proxy_used_by_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Proxy Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_proxy_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/proxy/{id}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_radius_create(self, radius_provider_request : RadiusProviderRequest, **kwargs) -> RadiusProvider:  # noqa: E501
        """providers_radius_create  # noqa: E501

        RadiusProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_create(radius_provider_request, async_req=True)
        >>> result = thread.get()

        :param radius_provider_request: (required)
        :type radius_provider_request: RadiusProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RadiusProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_radius_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_radius_create_with_http_info(radius_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_radius_create_with_http_info(self, radius_provider_request : RadiusProviderRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_radius_create  # noqa: E501

        RadiusProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_create_with_http_info(radius_provider_request, async_req=True)
        >>> result = thread.get()

        :param radius_provider_request: (required)
        :type radius_provider_request: RadiusProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RadiusProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'radius_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_radius_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['radius_provider_request'] is not None:
            _body_params = _params['radius_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "RadiusProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/radius/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_radius_destroy(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Radius Provider.")], **kwargs) -> None:  # noqa: E501
        """providers_radius_destroy  # noqa: E501

        RadiusProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_destroy(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Radius Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_radius_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_radius_destroy_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_radius_destroy_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Radius Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_radius_destroy  # noqa: E501

        RadiusProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_destroy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Radius Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_radius_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/providers/radius/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_radius_list(self, application__isnull : Optional[StrictBool] = None, authorization_flow__slug__iexact : Optional[StrictStr] = None, client_networks__iexact : Optional[StrictStr] = None, name__iexact : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> PaginatedRadiusProviderList:  # noqa: E501
        """providers_radius_list  # noqa: E501

        RadiusProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_list(application__isnull, authorization_flow__slug__iexact, client_networks__iexact, name__iexact, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param application__isnull:
        :type application__isnull: bool
        :param authorization_flow__slug__iexact:
        :type authorization_flow__slug__iexact: str
        :param client_networks__iexact:
        :type client_networks__iexact: str
        :param name__iexact:
        :type name__iexact: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedRadiusProviderList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_radius_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_radius_list_with_http_info(application__isnull, authorization_flow__slug__iexact, client_networks__iexact, name__iexact, ordering, page, page_size, search, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_radius_list_with_http_info(self, application__isnull : Optional[StrictBool] = None, authorization_flow__slug__iexact : Optional[StrictStr] = None, client_networks__iexact : Optional[StrictStr] = None, name__iexact : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_radius_list  # noqa: E501

        RadiusProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_list_with_http_info(application__isnull, authorization_flow__slug__iexact, client_networks__iexact, name__iexact, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param application__isnull:
        :type application__isnull: bool
        :param authorization_flow__slug__iexact:
        :type authorization_flow__slug__iexact: str
        :param client_networks__iexact:
        :type client_networks__iexact: str
        :param name__iexact:
        :type name__iexact: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedRadiusProviderList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'application__isnull',
            'authorization_flow__slug__iexact',
            'client_networks__iexact',
            'name__iexact',
            'ordering',
            'page',
            'page_size',
            'search'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_radius_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('application__isnull') is not None:  # noqa: E501
            _query_params.append(('application__isnull', _params['application__isnull']))

        if _params.get('authorization_flow__slug__iexact') is not None:  # noqa: E501
            _query_params.append(('authorization_flow__slug__iexact', _params['authorization_flow__slug__iexact']))

        if _params.get('client_networks__iexact') is not None:  # noqa: E501
            _query_params.append(('client_networks__iexact', _params['client_networks__iexact']))

        if _params.get('name__iexact') is not None:  # noqa: E501
            _query_params.append(('name__iexact', _params['name__iexact']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedRadiusProviderList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/radius/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_radius_partial_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Radius Provider.")], patched_radius_provider_request : Optional[PatchedRadiusProviderRequest] = None, **kwargs) -> RadiusProvider:  # noqa: E501
        """providers_radius_partial_update  # noqa: E501

        RadiusProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_partial_update(id, patched_radius_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Radius Provider. (required)
        :type id: int
        :param patched_radius_provider_request:
        :type patched_radius_provider_request: PatchedRadiusProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RadiusProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_radius_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_radius_partial_update_with_http_info(id, patched_radius_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_radius_partial_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Radius Provider.")], patched_radius_provider_request : Optional[PatchedRadiusProviderRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_radius_partial_update  # noqa: E501

        RadiusProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_partial_update_with_http_info(id, patched_radius_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Radius Provider. (required)
        :type id: int
        :param patched_radius_provider_request:
        :type patched_radius_provider_request: PatchedRadiusProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RadiusProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'patched_radius_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_radius_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_radius_provider_request'] is not None:
            _body_params = _params['patched_radius_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "RadiusProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/radius/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_radius_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Radius Provider.")], **kwargs) -> RadiusProvider:  # noqa: E501
        """providers_radius_retrieve  # noqa: E501

        RadiusProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Radius Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RadiusProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_radius_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_radius_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_radius_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Radius Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_radius_retrieve  # noqa: E501

        RadiusProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Radius Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RadiusProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_radius_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "RadiusProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/radius/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_radius_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Radius Provider.")], radius_provider_request : RadiusProviderRequest, **kwargs) -> RadiusProvider:  # noqa: E501
        """providers_radius_update  # noqa: E501

        RadiusProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_update(id, radius_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Radius Provider. (required)
        :type id: int
        :param radius_provider_request: (required)
        :type radius_provider_request: RadiusProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RadiusProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_radius_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_radius_update_with_http_info(id, radius_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_radius_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Radius Provider.")], radius_provider_request : RadiusProviderRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_radius_update  # noqa: E501

        RadiusProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_update_with_http_info(id, radius_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Radius Provider. (required)
        :type id: int
        :param radius_provider_request: (required)
        :type radius_provider_request: RadiusProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RadiusProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'radius_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_radius_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['radius_provider_request'] is not None:
            _body_params = _params['radius_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "RadiusProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/radius/{id}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_radius_used_by_list(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Radius Provider.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """providers_radius_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_used_by_list(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Radius Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_radius_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_radius_used_by_list_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_radius_used_by_list_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this Radius Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_radius_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_radius_used_by_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this Radius Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_radius_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/radius/{id}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_saml_create(self, saml_provider_request : SAMLProviderRequest, **kwargs) -> SAMLProvider:  # noqa: E501
        """providers_saml_create  # noqa: E501

        SAMLProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_create(saml_provider_request, async_req=True)
        >>> result = thread.get()

        :param saml_provider_request: (required)
        :type saml_provider_request: SAMLProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SAMLProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_saml_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_saml_create_with_http_info(saml_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_saml_create_with_http_info(self, saml_provider_request : SAMLProviderRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_saml_create  # noqa: E501

        SAMLProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_create_with_http_info(saml_provider_request, async_req=True)
        >>> result = thread.get()

        :param saml_provider_request: (required)
        :type saml_provider_request: SAMLProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SAMLProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'saml_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_saml_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['saml_provider_request'] is not None:
            _body_params = _params['saml_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "SAMLProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/saml/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_saml_destroy(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], **kwargs) -> None:  # noqa: E501
        """providers_saml_destroy  # noqa: E501

        SAMLProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_destroy(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_saml_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_saml_destroy_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_saml_destroy_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_saml_destroy  # noqa: E501

        SAMLProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_destroy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_saml_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/providers/saml/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_saml_import_metadata_create(self, name : constr(strict=True, min_length=1), authorization_flow : Annotated[constr(strict=True, min_length=1), Field(..., description="Visible in the URL.")], file : Union[StrictBytes, StrictStr], **kwargs) -> None:  # noqa: E501
        """providers_saml_import_metadata_create  # noqa: E501

        Create provider from SAML Metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_import_metadata_create(name, authorization_flow, file, async_req=True)
        >>> result = thread.get()

        :param name: (required)
        :type name: str
        :param authorization_flow: Visible in the URL. (required)
        :type authorization_flow: str
        :param file: (required)
        :type file: bytearray
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_saml_import_metadata_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_saml_import_metadata_create_with_http_info(name, authorization_flow, file, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_saml_import_metadata_create_with_http_info(self, name : constr(strict=True, min_length=1), authorization_flow : Annotated[constr(strict=True, min_length=1), Field(..., description="Visible in the URL.")], file : Union[StrictBytes, StrictStr], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_saml_import_metadata_create  # noqa: E501

        Create provider from SAML Metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_import_metadata_create_with_http_info(name, authorization_flow, file, async_req=True)
        >>> result = thread.get()

        :param name: (required)
        :type name: str
        :param authorization_flow: Visible in the URL. (required)
        :type authorization_flow: str
        :param file: (required)
        :type file: bytearray
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'name',
            'authorization_flow',
            'file'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_saml_import_metadata_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        if _params['name']:
            _form_params.append(('name', _params['name']))

        if _params['authorization_flow']:
            _form_params.append(('authorization_flow', _params['authorization_flow']))

        if _params['file']:
            _files['file'] = _params['file']

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/providers/saml/import_metadata/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_saml_list(self, acs_url : Optional[StrictStr] = None, assertion_valid_not_before : Optional[StrictStr] = None, assertion_valid_not_on_or_after : Optional[StrictStr] = None, audience : Optional[StrictStr] = None, authentication_flow : Optional[StrictStr] = None, authorization_flow : Optional[StrictStr] = None, backchannel_application : Optional[StrictStr] = None, digest_algorithm : Annotated[Optional[StrictStr], Field(description="* `http://www.w3.org/2000/09/xmldsig#sha1` - SHA1 * `http://www.w3.org/2001/04/xmlenc#sha256` - SHA256 * `http://www.w3.org/2001/04/xmldsig-more#sha384` - SHA384 * `http://www.w3.org/2001/04/xmlenc#sha512` - SHA512")] = None, is_backchannel : Optional[StrictBool] = None, issuer : Optional[StrictStr] = None, name : Optional[StrictStr] = None, name_id_mapping : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, property_mappings : Optional[conlist(StrictStr)] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, session_valid_not_on_or_after : Optional[StrictStr] = None, signature_algorithm : Annotated[Optional[StrictStr], Field(description="* `http://www.w3.org/2000/09/xmldsig#rsa-sha1` - RSA-SHA1 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha256` - RSA-SHA256 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha384` - RSA-SHA384 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha512` - RSA-SHA512 * `http://www.w3.org/2000/09/xmldsig#dsa-sha1` - DSA-SHA1")] = None, signing_kp : Optional[StrictStr] = None, sp_binding : Annotated[Optional[StrictStr], Field(description="This determines how authentik sends the response back to the Service Provider.  * `redirect` - Redirect * `post` - Post")] = None, verification_kp : Optional[StrictStr] = None, **kwargs) -> PaginatedSAMLProviderList:  # noqa: E501
        """providers_saml_list  # noqa: E501

        SAMLProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_list(acs_url, assertion_valid_not_before, assertion_valid_not_on_or_after, audience, authentication_flow, authorization_flow, backchannel_application, digest_algorithm, is_backchannel, issuer, name, name_id_mapping, ordering, page, page_size, property_mappings, search, session_valid_not_on_or_after, signature_algorithm, signing_kp, sp_binding, verification_kp, async_req=True)
        >>> result = thread.get()

        :param acs_url:
        :type acs_url: str
        :param assertion_valid_not_before:
        :type assertion_valid_not_before: str
        :param assertion_valid_not_on_or_after:
        :type assertion_valid_not_on_or_after: str
        :param audience:
        :type audience: str
        :param authentication_flow:
        :type authentication_flow: str
        :param authorization_flow:
        :type authorization_flow: str
        :param backchannel_application:
        :type backchannel_application: str
        :param digest_algorithm: * `http://www.w3.org/2000/09/xmldsig#sha1` - SHA1 * `http://www.w3.org/2001/04/xmlenc#sha256` - SHA256 * `http://www.w3.org/2001/04/xmldsig-more#sha384` - SHA384 * `http://www.w3.org/2001/04/xmlenc#sha512` - SHA512
        :type digest_algorithm: str
        :param is_backchannel:
        :type is_backchannel: bool
        :param issuer:
        :type issuer: str
        :param name:
        :type name: str
        :param name_id_mapping:
        :type name_id_mapping: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param property_mappings:
        :type property_mappings: List[str]
        :param search: A search term.
        :type search: str
        :param session_valid_not_on_or_after:
        :type session_valid_not_on_or_after: str
        :param signature_algorithm: * `http://www.w3.org/2000/09/xmldsig#rsa-sha1` - RSA-SHA1 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha256` - RSA-SHA256 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha384` - RSA-SHA384 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha512` - RSA-SHA512 * `http://www.w3.org/2000/09/xmldsig#dsa-sha1` - DSA-SHA1
        :type signature_algorithm: str
        :param signing_kp:
        :type signing_kp: str
        :param sp_binding: This determines how authentik sends the response back to the Service Provider.  * `redirect` - Redirect * `post` - Post
        :type sp_binding: str
        :param verification_kp:
        :type verification_kp: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedSAMLProviderList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_saml_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_saml_list_with_http_info(acs_url, assertion_valid_not_before, assertion_valid_not_on_or_after, audience, authentication_flow, authorization_flow, backchannel_application, digest_algorithm, is_backchannel, issuer, name, name_id_mapping, ordering, page, page_size, property_mappings, search, session_valid_not_on_or_after, signature_algorithm, signing_kp, sp_binding, verification_kp, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_saml_list_with_http_info(self, acs_url : Optional[StrictStr] = None, assertion_valid_not_before : Optional[StrictStr] = None, assertion_valid_not_on_or_after : Optional[StrictStr] = None, audience : Optional[StrictStr] = None, authentication_flow : Optional[StrictStr] = None, authorization_flow : Optional[StrictStr] = None, backchannel_application : Optional[StrictStr] = None, digest_algorithm : Annotated[Optional[StrictStr], Field(description="* `http://www.w3.org/2000/09/xmldsig#sha1` - SHA1 * `http://www.w3.org/2001/04/xmlenc#sha256` - SHA256 * `http://www.w3.org/2001/04/xmldsig-more#sha384` - SHA384 * `http://www.w3.org/2001/04/xmlenc#sha512` - SHA512")] = None, is_backchannel : Optional[StrictBool] = None, issuer : Optional[StrictStr] = None, name : Optional[StrictStr] = None, name_id_mapping : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, property_mappings : Optional[conlist(StrictStr)] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, session_valid_not_on_or_after : Optional[StrictStr] = None, signature_algorithm : Annotated[Optional[StrictStr], Field(description="* `http://www.w3.org/2000/09/xmldsig#rsa-sha1` - RSA-SHA1 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha256` - RSA-SHA256 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha384` - RSA-SHA384 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha512` - RSA-SHA512 * `http://www.w3.org/2000/09/xmldsig#dsa-sha1` - DSA-SHA1")] = None, signing_kp : Optional[StrictStr] = None, sp_binding : Annotated[Optional[StrictStr], Field(description="This determines how authentik sends the response back to the Service Provider.  * `redirect` - Redirect * `post` - Post")] = None, verification_kp : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_saml_list  # noqa: E501

        SAMLProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_list_with_http_info(acs_url, assertion_valid_not_before, assertion_valid_not_on_or_after, audience, authentication_flow, authorization_flow, backchannel_application, digest_algorithm, is_backchannel, issuer, name, name_id_mapping, ordering, page, page_size, property_mappings, search, session_valid_not_on_or_after, signature_algorithm, signing_kp, sp_binding, verification_kp, async_req=True)
        >>> result = thread.get()

        :param acs_url:
        :type acs_url: str
        :param assertion_valid_not_before:
        :type assertion_valid_not_before: str
        :param assertion_valid_not_on_or_after:
        :type assertion_valid_not_on_or_after: str
        :param audience:
        :type audience: str
        :param authentication_flow:
        :type authentication_flow: str
        :param authorization_flow:
        :type authorization_flow: str
        :param backchannel_application:
        :type backchannel_application: str
        :param digest_algorithm: * `http://www.w3.org/2000/09/xmldsig#sha1` - SHA1 * `http://www.w3.org/2001/04/xmlenc#sha256` - SHA256 * `http://www.w3.org/2001/04/xmldsig-more#sha384` - SHA384 * `http://www.w3.org/2001/04/xmlenc#sha512` - SHA512
        :type digest_algorithm: str
        :param is_backchannel:
        :type is_backchannel: bool
        :param issuer:
        :type issuer: str
        :param name:
        :type name: str
        :param name_id_mapping:
        :type name_id_mapping: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param property_mappings:
        :type property_mappings: List[str]
        :param search: A search term.
        :type search: str
        :param session_valid_not_on_or_after:
        :type session_valid_not_on_or_after: str
        :param signature_algorithm: * `http://www.w3.org/2000/09/xmldsig#rsa-sha1` - RSA-SHA1 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha256` - RSA-SHA256 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha384` - RSA-SHA384 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha512` - RSA-SHA512 * `http://www.w3.org/2000/09/xmldsig#dsa-sha1` - DSA-SHA1
        :type signature_algorithm: str
        :param signing_kp:
        :type signing_kp: str
        :param sp_binding: This determines how authentik sends the response back to the Service Provider.  * `redirect` - Redirect * `post` - Post
        :type sp_binding: str
        :param verification_kp:
        :type verification_kp: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedSAMLProviderList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'acs_url',
            'assertion_valid_not_before',
            'assertion_valid_not_on_or_after',
            'audience',
            'authentication_flow',
            'authorization_flow',
            'backchannel_application',
            'digest_algorithm',
            'is_backchannel',
            'issuer',
            'name',
            'name_id_mapping',
            'ordering',
            'page',
            'page_size',
            'property_mappings',
            'search',
            'session_valid_not_on_or_after',
            'signature_algorithm',
            'signing_kp',
            'sp_binding',
            'verification_kp'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_saml_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('acs_url') is not None:  # noqa: E501
            _query_params.append(('acs_url', _params['acs_url']))

        if _params.get('assertion_valid_not_before') is not None:  # noqa: E501
            _query_params.append(('assertion_valid_not_before', _params['assertion_valid_not_before']))

        if _params.get('assertion_valid_not_on_or_after') is not None:  # noqa: E501
            _query_params.append(('assertion_valid_not_on_or_after', _params['assertion_valid_not_on_or_after']))

        if _params.get('audience') is not None:  # noqa: E501
            _query_params.append(('audience', _params['audience']))

        if _params.get('authentication_flow') is not None:  # noqa: E501
            _query_params.append(('authentication_flow', _params['authentication_flow']))

        if _params.get('authorization_flow') is not None:  # noqa: E501
            _query_params.append(('authorization_flow', _params['authorization_flow']))

        if _params.get('backchannel_application') is not None:  # noqa: E501
            _query_params.append(('backchannel_application', _params['backchannel_application']))

        if _params.get('digest_algorithm') is not None:  # noqa: E501
            _query_params.append(('digest_algorithm', _params['digest_algorithm']))

        if _params.get('is_backchannel') is not None:  # noqa: E501
            _query_params.append(('is_backchannel', _params['is_backchannel']))

        if _params.get('issuer') is not None:  # noqa: E501
            _query_params.append(('issuer', _params['issuer']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('name_id_mapping') is not None:  # noqa: E501
            _query_params.append(('name_id_mapping', _params['name_id_mapping']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('property_mappings') is not None:  # noqa: E501
            _query_params.append(('property_mappings', _params['property_mappings']))
            _collection_formats['property_mappings'] = 'multi'

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('session_valid_not_on_or_after') is not None:  # noqa: E501
            _query_params.append(('session_valid_not_on_or_after', _params['session_valid_not_on_or_after']))

        if _params.get('signature_algorithm') is not None:  # noqa: E501
            _query_params.append(('signature_algorithm', _params['signature_algorithm']))

        if _params.get('signing_kp') is not None:  # noqa: E501
            _query_params.append(('signing_kp', _params['signing_kp']))

        if _params.get('sp_binding') is not None:  # noqa: E501
            _query_params.append(('sp_binding', _params['sp_binding']))

        if _params.get('verification_kp') is not None:  # noqa: E501
            _query_params.append(('verification_kp', _params['verification_kp']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedSAMLProviderList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/saml/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_saml_metadata_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], download : Optional[StrictBool] = None, force_binding : Annotated[Optional[StrictStr], Field(description="Optionally force the metadata to only include one binding.")] = None, **kwargs) -> SAMLMetadata:  # noqa: E501
        """providers_saml_metadata_retrieve  # noqa: E501

        Return metadata as XML string  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_metadata_retrieve(id, download, force_binding, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param download:
        :type download: bool
        :param force_binding: Optionally force the metadata to only include one binding.
        :type force_binding: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SAMLMetadata
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_saml_metadata_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_saml_metadata_retrieve_with_http_info(id, download, force_binding, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_saml_metadata_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], download : Optional[StrictBool] = None, force_binding : Annotated[Optional[StrictStr], Field(description="Optionally force the metadata to only include one binding.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_saml_metadata_retrieve  # noqa: E501

        Return metadata as XML string  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_metadata_retrieve_with_http_info(id, download, force_binding, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param download:
        :type download: bool
        :param force_binding: Optionally force the metadata to only include one binding.
        :type force_binding: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SAMLMetadata, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'download',
            'force_binding'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_saml_metadata_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('download') is not None:  # noqa: E501
            _query_params.append(('download', _params['download']))

        if _params.get('force_binding') is not None:  # noqa: E501
            _query_params.append(('force_binding', _params['force_binding']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "SAMLMetadata",
            '404': None,
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/saml/{id}/metadata/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_saml_partial_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], patched_saml_provider_request : Optional[PatchedSAMLProviderRequest] = None, **kwargs) -> SAMLProvider:  # noqa: E501
        """providers_saml_partial_update  # noqa: E501

        SAMLProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_partial_update(id, patched_saml_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param patched_saml_provider_request:
        :type patched_saml_provider_request: PatchedSAMLProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SAMLProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_saml_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_saml_partial_update_with_http_info(id, patched_saml_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_saml_partial_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], patched_saml_provider_request : Optional[PatchedSAMLProviderRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_saml_partial_update  # noqa: E501

        SAMLProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_partial_update_with_http_info(id, patched_saml_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param patched_saml_provider_request:
        :type patched_saml_provider_request: PatchedSAMLProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SAMLProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'patched_saml_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_saml_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_saml_provider_request'] is not None:
            _body_params = _params['patched_saml_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "SAMLProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/saml/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_saml_preview_user_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], **kwargs) -> PropertyMappingPreview:  # noqa: E501
        """providers_saml_preview_user_retrieve  # noqa: E501

        Preview user data for provider  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_preview_user_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PropertyMappingPreview
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_saml_preview_user_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_saml_preview_user_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_saml_preview_user_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_saml_preview_user_retrieve  # noqa: E501

        Preview user data for provider  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_preview_user_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PropertyMappingPreview, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_saml_preview_user_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PropertyMappingPreview",
            '400': None,
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/saml/{id}/preview_user/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_saml_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], **kwargs) -> SAMLProvider:  # noqa: E501
        """providers_saml_retrieve  # noqa: E501

        SAMLProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SAMLProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_saml_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_saml_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_saml_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_saml_retrieve  # noqa: E501

        SAMLProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SAMLProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_saml_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "SAMLProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/saml/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_saml_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], saml_provider_request : SAMLProviderRequest, **kwargs) -> SAMLProvider:  # noqa: E501
        """providers_saml_update  # noqa: E501

        SAMLProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_update(id, saml_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param saml_provider_request: (required)
        :type saml_provider_request: SAMLProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SAMLProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_saml_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_saml_update_with_http_info(id, saml_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_saml_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], saml_provider_request : SAMLProviderRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_saml_update  # noqa: E501

        SAMLProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_update_with_http_info(id, saml_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param saml_provider_request: (required)
        :type saml_provider_request: SAMLProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SAMLProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'saml_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_saml_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['saml_provider_request'] is not None:
            _body_params = _params['saml_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "SAMLProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/saml/{id}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_saml_used_by_list(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """providers_saml_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_used_by_list(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_saml_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_saml_used_by_list_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_saml_used_by_list_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SAML Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_saml_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_saml_used_by_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SAML Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_saml_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/saml/{id}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_scim_create(self, scim_provider_request : SCIMProviderRequest, **kwargs) -> SCIMProvider:  # noqa: E501
        """providers_scim_create  # noqa: E501

        SCIMProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_create(scim_provider_request, async_req=True)
        >>> result = thread.get()

        :param scim_provider_request: (required)
        :type scim_provider_request: SCIMProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SCIMProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_scim_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_scim_create_with_http_info(scim_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_scim_create_with_http_info(self, scim_provider_request : SCIMProviderRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_scim_create  # noqa: E501

        SCIMProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_create_with_http_info(scim_provider_request, async_req=True)
        >>> result = thread.get()

        :param scim_provider_request: (required)
        :type scim_provider_request: SCIMProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SCIMProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'scim_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_scim_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['scim_provider_request'] is not None:
            _body_params = _params['scim_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "SCIMProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/scim/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_scim_destroy(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SCIM Provider.")], **kwargs) -> None:  # noqa: E501
        """providers_scim_destroy  # noqa: E501

        SCIMProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_destroy(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SCIM Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_scim_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_scim_destroy_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_scim_destroy_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SCIM Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_scim_destroy  # noqa: E501

        SCIMProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_destroy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SCIM Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_scim_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/providers/scim/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_scim_list(self, exclude_users_service_account : Optional[StrictBool] = None, filter_group : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, url : Optional[StrictStr] = None, **kwargs) -> PaginatedSCIMProviderList:  # noqa: E501
        """providers_scim_list  # noqa: E501

        SCIMProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_list(exclude_users_service_account, filter_group, name, ordering, page, page_size, search, url, async_req=True)
        >>> result = thread.get()

        :param exclude_users_service_account:
        :type exclude_users_service_account: bool
        :param filter_group:
        :type filter_group: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param url:
        :type url: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedSCIMProviderList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_scim_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_scim_list_with_http_info(exclude_users_service_account, filter_group, name, ordering, page, page_size, search, url, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_scim_list_with_http_info(self, exclude_users_service_account : Optional[StrictBool] = None, filter_group : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, url : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_scim_list  # noqa: E501

        SCIMProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_list_with_http_info(exclude_users_service_account, filter_group, name, ordering, page, page_size, search, url, async_req=True)
        >>> result = thread.get()

        :param exclude_users_service_account:
        :type exclude_users_service_account: bool
        :param filter_group:
        :type filter_group: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param url:
        :type url: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedSCIMProviderList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'exclude_users_service_account',
            'filter_group',
            'name',
            'ordering',
            'page',
            'page_size',
            'search',
            'url'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_scim_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('exclude_users_service_account') is not None:  # noqa: E501
            _query_params.append(('exclude_users_service_account', _params['exclude_users_service_account']))

        if _params.get('filter_group') is not None:  # noqa: E501
            _query_params.append(('filter_group', _params['filter_group']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('url') is not None:  # noqa: E501
            _query_params.append(('url', _params['url']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedSCIMProviderList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/scim/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_scim_partial_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SCIM Provider.")], patched_scim_provider_request : Optional[PatchedSCIMProviderRequest] = None, **kwargs) -> SCIMProvider:  # noqa: E501
        """providers_scim_partial_update  # noqa: E501

        SCIMProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_partial_update(id, patched_scim_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SCIM Provider. (required)
        :type id: int
        :param patched_scim_provider_request:
        :type patched_scim_provider_request: PatchedSCIMProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SCIMProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_scim_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_scim_partial_update_with_http_info(id, patched_scim_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_scim_partial_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SCIM Provider.")], patched_scim_provider_request : Optional[PatchedSCIMProviderRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_scim_partial_update  # noqa: E501

        SCIMProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_partial_update_with_http_info(id, patched_scim_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SCIM Provider. (required)
        :type id: int
        :param patched_scim_provider_request:
        :type patched_scim_provider_request: PatchedSCIMProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SCIMProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'patched_scim_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_scim_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_scim_provider_request'] is not None:
            _body_params = _params['patched_scim_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "SCIMProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/scim/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_scim_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SCIM Provider.")], **kwargs) -> SCIMProvider:  # noqa: E501
        """providers_scim_retrieve  # noqa: E501

        SCIMProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SCIM Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SCIMProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_scim_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_scim_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_scim_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SCIM Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_scim_retrieve  # noqa: E501

        SCIMProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SCIM Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SCIMProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_scim_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "SCIMProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/scim/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_scim_sync_status_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SCIM Provider.")], **kwargs) -> Task:  # noqa: E501
        """providers_scim_sync_status_retrieve  # noqa: E501

        Get provider's sync status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_sync_status_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SCIM Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Task
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_scim_sync_status_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_scim_sync_status_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_scim_sync_status_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SCIM Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_scim_sync_status_retrieve  # noqa: E501

        Get provider's sync status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_sync_status_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SCIM Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Task, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_scim_sync_status_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Task",
            '404': None,
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/scim/{id}/sync_status/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_scim_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SCIM Provider.")], scim_provider_request : SCIMProviderRequest, **kwargs) -> SCIMProvider:  # noqa: E501
        """providers_scim_update  # noqa: E501

        SCIMProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_update(id, scim_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SCIM Provider. (required)
        :type id: int
        :param scim_provider_request: (required)
        :type scim_provider_request: SCIMProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SCIMProvider
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_scim_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_scim_update_with_http_info(id, scim_provider_request, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_scim_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SCIM Provider.")], scim_provider_request : SCIMProviderRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """providers_scim_update  # noqa: E501

        SCIMProvider Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_update_with_http_info(id, scim_provider_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SCIM Provider. (required)
        :type id: int
        :param scim_provider_request: (required)
        :type scim_provider_request: SCIMProviderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SCIMProvider, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'scim_provider_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_scim_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['scim_provider_request'] is not None:
            _body_params = _params['scim_provider_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "SCIMProvider",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/scim/{id}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_scim_used_by_list(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SCIM Provider.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """providers_scim_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_used_by_list(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SCIM Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the providers_scim_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.providers_scim_used_by_list_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def providers_scim_used_by_list_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this SCIM Provider.")], **kwargs) -> ApiResponse:  # noqa: E501
        """providers_scim_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_scim_used_by_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this SCIM Provider. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_scim_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/providers/scim/{id}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
