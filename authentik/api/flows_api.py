# coding: utf-8

"""
    authentik

    Making authentication simple.

    The version of the OpenAPI document: 2023.6.1
    Contact: hello@goauthentik.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr, conlist

from typing import List, Optional, Union

from authentik.models.cache import Cache
from authentik.models.challenge_types import ChallengeTypes
from authentik.models.file_path_request import FilePathRequest
from authentik.models.flow import Flow
from authentik.models.flow_challenge_response_request import FlowChallengeResponseRequest
from authentik.models.flow_diagram import FlowDiagram
from authentik.models.flow_import_result import FlowImportResult
from authentik.models.flow_inspection import FlowInspection
from authentik.models.flow_request import FlowRequest
from authentik.models.flow_stage_binding import FlowStageBinding
from authentik.models.flow_stage_binding_request import FlowStageBindingRequest
from authentik.models.link import Link
from authentik.models.paginated_flow_list import PaginatedFlowList
from authentik.models.paginated_flow_stage_binding_list import PaginatedFlowStageBindingList
from authentik.models.patched_flow_request import PatchedFlowRequest
from authentik.models.patched_flow_stage_binding_request import PatchedFlowStageBindingRequest
from authentik.models.used_by import UsedBy

from authentik.api_client import ApiClient
from authentik.api_response import ApiResponse
from authentik.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class FlowsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def flows_bindings_create(self, flow_stage_binding_request : FlowStageBindingRequest, **kwargs) -> FlowStageBinding:  # noqa: E501
        """flows_bindings_create  # noqa: E501

        FlowStageBinding Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_create(flow_stage_binding_request, async_req=True)
        >>> result = thread.get()

        :param flow_stage_binding_request: (required)
        :type flow_stage_binding_request: FlowStageBindingRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FlowStageBinding
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_bindings_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_bindings_create_with_http_info(flow_stage_binding_request, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_bindings_create_with_http_info(self, flow_stage_binding_request : FlowStageBindingRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_bindings_create  # noqa: E501

        FlowStageBinding Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_create_with_http_info(flow_stage_binding_request, async_req=True)
        >>> result = thread.get()

        :param flow_stage_binding_request: (required)
        :type flow_stage_binding_request: FlowStageBindingRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FlowStageBinding, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'flow_stage_binding_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_bindings_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['flow_stage_binding_request'] is not None:
            _body_params = _params['flow_stage_binding_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "FlowStageBinding",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/bindings/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_bindings_destroy(self, fsb_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Flow Stage Binding.")], **kwargs) -> None:  # noqa: E501
        """flows_bindings_destroy  # noqa: E501

        FlowStageBinding Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_destroy(fsb_uuid, async_req=True)
        >>> result = thread.get()

        :param fsb_uuid: A UUID string identifying this Flow Stage Binding. (required)
        :type fsb_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_bindings_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_bindings_destroy_with_http_info(fsb_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_bindings_destroy_with_http_info(self, fsb_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Flow Stage Binding.")], **kwargs) -> ApiResponse:  # noqa: E501
        """flows_bindings_destroy  # noqa: E501

        FlowStageBinding Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_destroy_with_http_info(fsb_uuid, async_req=True)
        >>> result = thread.get()

        :param fsb_uuid: A UUID string identifying this Flow Stage Binding. (required)
        :type fsb_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'fsb_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_bindings_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['fsb_uuid']:
            _path_params['fsb_uuid'] = _params['fsb_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/flows/bindings/{fsb_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_bindings_list(self, evaluate_on_plan : Optional[StrictBool] = None, fsb_uuid : Optional[StrictStr] = None, invalid_response_action : Annotated[Optional[StrictStr], Field(description="Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.  * `retry` - Retry * `restart` - Restart * `restart_with_context` - Restart With Context")] = None, order : Optional[StrictInt] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, pbm_uuid : Optional[StrictStr] = None, policies : Optional[conlist(StrictStr)] = None, policy_engine_mode : Annotated[Optional[StrictStr], Field(description="* `all` - all, all policies must pass * `any` - any, any policy must pass")] = None, re_evaluate_policies : Optional[StrictBool] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage : Optional[StrictStr] = None, target : Optional[StrictStr] = None, **kwargs) -> PaginatedFlowStageBindingList:  # noqa: E501
        """flows_bindings_list  # noqa: E501

        FlowStageBinding Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_list(evaluate_on_plan, fsb_uuid, invalid_response_action, order, ordering, page, page_size, pbm_uuid, policies, policy_engine_mode, re_evaluate_policies, search, stage, target, async_req=True)
        >>> result = thread.get()

        :param evaluate_on_plan:
        :type evaluate_on_plan: bool
        :param fsb_uuid:
        :type fsb_uuid: str
        :param invalid_response_action: Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.  * `retry` - Retry * `restart` - Restart * `restart_with_context` - Restart With Context
        :type invalid_response_action: str
        :param order:
        :type order: int
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param pbm_uuid:
        :type pbm_uuid: str
        :param policies:
        :type policies: List[str]
        :param policy_engine_mode: * `all` - all, all policies must pass * `any` - any, any policy must pass
        :type policy_engine_mode: str
        :param re_evaluate_policies:
        :type re_evaluate_policies: bool
        :param search: A search term.
        :type search: str
        :param stage:
        :type stage: str
        :param target:
        :type target: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedFlowStageBindingList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_bindings_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_bindings_list_with_http_info(evaluate_on_plan, fsb_uuid, invalid_response_action, order, ordering, page, page_size, pbm_uuid, policies, policy_engine_mode, re_evaluate_policies, search, stage, target, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_bindings_list_with_http_info(self, evaluate_on_plan : Optional[StrictBool] = None, fsb_uuid : Optional[StrictStr] = None, invalid_response_action : Annotated[Optional[StrictStr], Field(description="Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.  * `retry` - Retry * `restart` - Restart * `restart_with_context` - Restart With Context")] = None, order : Optional[StrictInt] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, pbm_uuid : Optional[StrictStr] = None, policies : Optional[conlist(StrictStr)] = None, policy_engine_mode : Annotated[Optional[StrictStr], Field(description="* `all` - all, all policies must pass * `any` - any, any policy must pass")] = None, re_evaluate_policies : Optional[StrictBool] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage : Optional[StrictStr] = None, target : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_bindings_list  # noqa: E501

        FlowStageBinding Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_list_with_http_info(evaluate_on_plan, fsb_uuid, invalid_response_action, order, ordering, page, page_size, pbm_uuid, policies, policy_engine_mode, re_evaluate_policies, search, stage, target, async_req=True)
        >>> result = thread.get()

        :param evaluate_on_plan:
        :type evaluate_on_plan: bool
        :param fsb_uuid:
        :type fsb_uuid: str
        :param invalid_response_action: Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.  * `retry` - Retry * `restart` - Restart * `restart_with_context` - Restart With Context
        :type invalid_response_action: str
        :param order:
        :type order: int
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param pbm_uuid:
        :type pbm_uuid: str
        :param policies:
        :type policies: List[str]
        :param policy_engine_mode: * `all` - all, all policies must pass * `any` - any, any policy must pass
        :type policy_engine_mode: str
        :param re_evaluate_policies:
        :type re_evaluate_policies: bool
        :param search: A search term.
        :type search: str
        :param stage:
        :type stage: str
        :param target:
        :type target: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedFlowStageBindingList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'evaluate_on_plan',
            'fsb_uuid',
            'invalid_response_action',
            'order',
            'ordering',
            'page',
            'page_size',
            'pbm_uuid',
            'policies',
            'policy_engine_mode',
            're_evaluate_policies',
            'search',
            'stage',
            'target'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_bindings_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('evaluate_on_plan') is not None:  # noqa: E501
            _query_params.append(('evaluate_on_plan', _params['evaluate_on_plan']))

        if _params.get('fsb_uuid') is not None:  # noqa: E501
            _query_params.append(('fsb_uuid', _params['fsb_uuid']))

        if _params.get('invalid_response_action') is not None:  # noqa: E501
            _query_params.append(('invalid_response_action', _params['invalid_response_action']))

        if _params.get('order') is not None:  # noqa: E501
            _query_params.append(('order', _params['order']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('pbm_uuid') is not None:  # noqa: E501
            _query_params.append(('pbm_uuid', _params['pbm_uuid']))

        if _params.get('policies') is not None:  # noqa: E501
            _query_params.append(('policies', _params['policies']))
            _collection_formats['policies'] = 'multi'

        if _params.get('policy_engine_mode') is not None:  # noqa: E501
            _query_params.append(('policy_engine_mode', _params['policy_engine_mode']))

        if _params.get('re_evaluate_policies') is not None:  # noqa: E501
            _query_params.append(('re_evaluate_policies', _params['re_evaluate_policies']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('stage') is not None:  # noqa: E501
            _query_params.append(('stage', _params['stage']))

        if _params.get('target') is not None:  # noqa: E501
            _query_params.append(('target', _params['target']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedFlowStageBindingList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/bindings/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_bindings_partial_update(self, fsb_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Flow Stage Binding.")], patched_flow_stage_binding_request : Optional[PatchedFlowStageBindingRequest] = None, **kwargs) -> FlowStageBinding:  # noqa: E501
        """flows_bindings_partial_update  # noqa: E501

        FlowStageBinding Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_partial_update(fsb_uuid, patched_flow_stage_binding_request, async_req=True)
        >>> result = thread.get()

        :param fsb_uuid: A UUID string identifying this Flow Stage Binding. (required)
        :type fsb_uuid: str
        :param patched_flow_stage_binding_request:
        :type patched_flow_stage_binding_request: PatchedFlowStageBindingRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FlowStageBinding
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_bindings_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_bindings_partial_update_with_http_info(fsb_uuid, patched_flow_stage_binding_request, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_bindings_partial_update_with_http_info(self, fsb_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Flow Stage Binding.")], patched_flow_stage_binding_request : Optional[PatchedFlowStageBindingRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_bindings_partial_update  # noqa: E501

        FlowStageBinding Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_partial_update_with_http_info(fsb_uuid, patched_flow_stage_binding_request, async_req=True)
        >>> result = thread.get()

        :param fsb_uuid: A UUID string identifying this Flow Stage Binding. (required)
        :type fsb_uuid: str
        :param patched_flow_stage_binding_request:
        :type patched_flow_stage_binding_request: PatchedFlowStageBindingRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FlowStageBinding, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'fsb_uuid',
            'patched_flow_stage_binding_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_bindings_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['fsb_uuid']:
            _path_params['fsb_uuid'] = _params['fsb_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_flow_stage_binding_request'] is not None:
            _body_params = _params['patched_flow_stage_binding_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "FlowStageBinding",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/bindings/{fsb_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_bindings_retrieve(self, fsb_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Flow Stage Binding.")], **kwargs) -> FlowStageBinding:  # noqa: E501
        """flows_bindings_retrieve  # noqa: E501

        FlowStageBinding Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_retrieve(fsb_uuid, async_req=True)
        >>> result = thread.get()

        :param fsb_uuid: A UUID string identifying this Flow Stage Binding. (required)
        :type fsb_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FlowStageBinding
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_bindings_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_bindings_retrieve_with_http_info(fsb_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_bindings_retrieve_with_http_info(self, fsb_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Flow Stage Binding.")], **kwargs) -> ApiResponse:  # noqa: E501
        """flows_bindings_retrieve  # noqa: E501

        FlowStageBinding Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_retrieve_with_http_info(fsb_uuid, async_req=True)
        >>> result = thread.get()

        :param fsb_uuid: A UUID string identifying this Flow Stage Binding. (required)
        :type fsb_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FlowStageBinding, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'fsb_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_bindings_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['fsb_uuid']:
            _path_params['fsb_uuid'] = _params['fsb_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "FlowStageBinding",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/bindings/{fsb_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_bindings_update(self, fsb_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Flow Stage Binding.")], flow_stage_binding_request : FlowStageBindingRequest, **kwargs) -> FlowStageBinding:  # noqa: E501
        """flows_bindings_update  # noqa: E501

        FlowStageBinding Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_update(fsb_uuid, flow_stage_binding_request, async_req=True)
        >>> result = thread.get()

        :param fsb_uuid: A UUID string identifying this Flow Stage Binding. (required)
        :type fsb_uuid: str
        :param flow_stage_binding_request: (required)
        :type flow_stage_binding_request: FlowStageBindingRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FlowStageBinding
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_bindings_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_bindings_update_with_http_info(fsb_uuid, flow_stage_binding_request, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_bindings_update_with_http_info(self, fsb_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Flow Stage Binding.")], flow_stage_binding_request : FlowStageBindingRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_bindings_update  # noqa: E501

        FlowStageBinding Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_update_with_http_info(fsb_uuid, flow_stage_binding_request, async_req=True)
        >>> result = thread.get()

        :param fsb_uuid: A UUID string identifying this Flow Stage Binding. (required)
        :type fsb_uuid: str
        :param flow_stage_binding_request: (required)
        :type flow_stage_binding_request: FlowStageBindingRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FlowStageBinding, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'fsb_uuid',
            'flow_stage_binding_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_bindings_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['fsb_uuid']:
            _path_params['fsb_uuid'] = _params['fsb_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['flow_stage_binding_request'] is not None:
            _body_params = _params['flow_stage_binding_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "FlowStageBinding",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/bindings/{fsb_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_bindings_used_by_list(self, fsb_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Flow Stage Binding.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """flows_bindings_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_used_by_list(fsb_uuid, async_req=True)
        >>> result = thread.get()

        :param fsb_uuid: A UUID string identifying this Flow Stage Binding. (required)
        :type fsb_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_bindings_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_bindings_used_by_list_with_http_info(fsb_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_bindings_used_by_list_with_http_info(self, fsb_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Flow Stage Binding.")], **kwargs) -> ApiResponse:  # noqa: E501
        """flows_bindings_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_bindings_used_by_list_with_http_info(fsb_uuid, async_req=True)
        >>> result = thread.get()

        :param fsb_uuid: A UUID string identifying this Flow Stage Binding. (required)
        :type fsb_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'fsb_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_bindings_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['fsb_uuid']:
            _path_params['fsb_uuid'] = _params['fsb_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/bindings/{fsb_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_executor_get(self, flow_slug : StrictStr, query : Annotated[StrictStr, Field(..., description="Querystring as received")], **kwargs) -> ChallengeTypes:  # noqa: E501
        """flows_executor_get  # noqa: E501

        Get the next pending challenge from the currently active flow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_executor_get(flow_slug, query, async_req=True)
        >>> result = thread.get()

        :param flow_slug: (required)
        :type flow_slug: str
        :param query: Querystring as received (required)
        :type query: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ChallengeTypes
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_executor_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_executor_get_with_http_info(flow_slug, query, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_executor_get_with_http_info(self, flow_slug : StrictStr, query : Annotated[StrictStr, Field(..., description="Querystring as received")], **kwargs) -> ApiResponse:  # noqa: E501
        """flows_executor_get  # noqa: E501

        Get the next pending challenge from the currently active flow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_executor_get_with_http_info(flow_slug, query, async_req=True)
        >>> result = thread.get()

        :param flow_slug: (required)
        :type flow_slug: str
        :param query: Querystring as received (required)
        :type query: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ChallengeTypes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'flow_slug',
            'query'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_executor_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['flow_slug']:
            _path_params['flow_slug'] = _params['flow_slug']


        # process the query parameters
        _query_params = []
        if _params.get('query') is not None:  # noqa: E501
            _query_params.append(('query', _params['query']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "ChallengeTypes",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/executor/{flow_slug}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_executor_solve(self, flow_slug : StrictStr, query : Annotated[StrictStr, Field(..., description="Querystring as received")], flow_challenge_response_request : Optional[FlowChallengeResponseRequest] = None, **kwargs) -> ChallengeTypes:  # noqa: E501
        """flows_executor_solve  # noqa: E501

        Solve the previously retrieved challenge and advanced to the next stage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_executor_solve(flow_slug, query, flow_challenge_response_request, async_req=True)
        >>> result = thread.get()

        :param flow_slug: (required)
        :type flow_slug: str
        :param query: Querystring as received (required)
        :type query: str
        :param flow_challenge_response_request:
        :type flow_challenge_response_request: FlowChallengeResponseRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ChallengeTypes
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_executor_solve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_executor_solve_with_http_info(flow_slug, query, flow_challenge_response_request, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_executor_solve_with_http_info(self, flow_slug : StrictStr, query : Annotated[StrictStr, Field(..., description="Querystring as received")], flow_challenge_response_request : Optional[FlowChallengeResponseRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_executor_solve  # noqa: E501

        Solve the previously retrieved challenge and advanced to the next stage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_executor_solve_with_http_info(flow_slug, query, flow_challenge_response_request, async_req=True)
        >>> result = thread.get()

        :param flow_slug: (required)
        :type flow_slug: str
        :param query: Querystring as received (required)
        :type query: str
        :param flow_challenge_response_request:
        :type flow_challenge_response_request: FlowChallengeResponseRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ChallengeTypes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'flow_slug',
            'query',
            'flow_challenge_response_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_executor_solve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['flow_slug']:
            _path_params['flow_slug'] = _params['flow_slug']


        # process the query parameters
        _query_params = []
        if _params.get('query') is not None:  # noqa: E501
            _query_params.append(('query', _params['query']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['flow_challenge_response_request'] is not None:
            _body_params = _params['flow_challenge_response_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "ChallengeTypes",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/executor/{flow_slug}/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_inspector_get(self, flow_slug : StrictStr, **kwargs) -> FlowInspection:  # noqa: E501
        """flows_inspector_get  # noqa: E501

        Get current flow state and record it  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_inspector_get(flow_slug, async_req=True)
        >>> result = thread.get()

        :param flow_slug: (required)
        :type flow_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FlowInspection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_inspector_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_inspector_get_with_http_info(flow_slug, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_inspector_get_with_http_info(self, flow_slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_inspector_get  # noqa: E501

        Get current flow state and record it  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_inspector_get_with_http_info(flow_slug, async_req=True)
        >>> result = thread.get()

        :param flow_slug: (required)
        :type flow_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FlowInspection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'flow_slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_inspector_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['flow_slug']:
            _path_params['flow_slug'] = _params['flow_slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "FlowInspection",
            '400': None,
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/inspector/{flow_slug}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_cache_clear_create(self, **kwargs) -> None:  # noqa: E501
        """flows_instances_cache_clear_create  # noqa: E501

        Clear flow cache  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_cache_clear_create(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_cache_clear_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_cache_clear_create_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_cache_clear_create_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_cache_clear_create  # noqa: E501

        Clear flow cache  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_cache_clear_create_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_cache_clear_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/flows/instances/cache_clear/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_cache_info_retrieve(self, **kwargs) -> Cache:  # noqa: E501
        """flows_instances_cache_info_retrieve  # noqa: E501

        Info about cached flows  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_cache_info_retrieve(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cache
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_cache_info_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_cache_info_retrieve_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_cache_info_retrieve_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_cache_info_retrieve  # noqa: E501

        Info about cached flows  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_cache_info_retrieve_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cache, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_cache_info_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Cache",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/instances/cache_info/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_create(self, flow_request : FlowRequest, **kwargs) -> Flow:  # noqa: E501
        """flows_instances_create  # noqa: E501

        Flow Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_create(flow_request, async_req=True)
        >>> result = thread.get()

        :param flow_request: (required)
        :type flow_request: FlowRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Flow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_create_with_http_info(flow_request, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_create_with_http_info(self, flow_request : FlowRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_create  # noqa: E501

        Flow Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_create_with_http_info(flow_request, async_req=True)
        >>> result = thread.get()

        :param flow_request: (required)
        :type flow_request: FlowRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Flow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'flow_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['flow_request'] is not None:
            _body_params = _params['flow_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "Flow",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/instances/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_destroy(self, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """flows_instances_destroy  # noqa: E501

        Flow Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_destroy(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_destroy_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_destroy_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_destroy  # noqa: E501

        Flow Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_destroy_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/flows/instances/{slug}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_diagram_retrieve(self, slug : StrictStr, **kwargs) -> FlowDiagram:  # noqa: E501
        """flows_instances_diagram_retrieve  # noqa: E501

        Return diagram for flow with slug `slug`, in the format used by flowchart.js  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_diagram_retrieve(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FlowDiagram
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_diagram_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_diagram_retrieve_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_diagram_retrieve_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_diagram_retrieve  # noqa: E501

        Return diagram for flow with slug `slug`, in the format used by flowchart.js  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_diagram_retrieve_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FlowDiagram, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_diagram_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "FlowDiagram",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/instances/{slug}/diagram/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_execute_retrieve(self, slug : StrictStr, **kwargs) -> Link:  # noqa: E501
        """flows_instances_execute_retrieve  # noqa: E501

        Execute flow for current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_execute_retrieve(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Link
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_execute_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_execute_retrieve_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_execute_retrieve_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_execute_retrieve  # noqa: E501

        Execute flow for current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_execute_retrieve_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Link, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_execute_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Link",
            '400': None,
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/instances/{slug}/execute/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_export_retrieve(self, slug : StrictStr, **kwargs) -> bytearray:  # noqa: E501
        """flows_instances_export_retrieve  # noqa: E501

        Export flow to .yaml file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_export_retrieve(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_export_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_export_retrieve_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_export_retrieve_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_export_retrieve  # noqa: E501

        Export flow to .yaml file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_export_retrieve_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_export_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "bytearray",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/instances/{slug}/export/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_import_create(self, file : Optional[Union[StrictBytes, StrictStr]] = None, clear : Optional[StrictBool] = None, **kwargs) -> FlowImportResult:  # noqa: E501
        """flows_instances_import_create  # noqa: E501

        Import flow from .yaml file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_import_create(file, clear, async_req=True)
        >>> result = thread.get()

        :param file:
        :type file: bytearray
        :param clear:
        :type clear: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FlowImportResult
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_import_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_import_create_with_http_info(file, clear, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_import_create_with_http_info(self, file : Optional[Union[StrictBytes, StrictStr]] = None, clear : Optional[StrictBool] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_import_create  # noqa: E501

        Import flow from .yaml file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_import_create_with_http_info(file, clear, async_req=True)
        >>> result = thread.get()

        :param file:
        :type file: bytearray
        :param clear:
        :type clear: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FlowImportResult, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'file',
            'clear'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_import_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        if _params['file']:
            _files['file'] = _params['file']

        if _params['clear']:
            _form_params.append(('clear', _params['clear']))

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '204': "FlowImportResult",
            '400': "FlowImportResult",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/instances/import/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_list(self, denied_action : Annotated[Optional[StrictStr], Field(description="Configure what should happen when a flow denies access to a user.  * `message_continue` - Message Continue * `message` - Message * `continue` - Continue")] = None, designation : Annotated[Optional[StrictStr], Field(description="Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.  * `authentication` - Authentication * `authorization` - Authorization * `invalidation` - Invalidation * `enrollment` - Enrollment * `unenrollment` - Unrenollment * `recovery` - Recovery * `stage_configuration` - Stage Configuration")] = None, flow_uuid : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, slug : Optional[StrictStr] = None, **kwargs) -> PaginatedFlowList:  # noqa: E501
        """flows_instances_list  # noqa: E501

        Flow Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_list(denied_action, designation, flow_uuid, name, ordering, page, page_size, search, slug, async_req=True)
        >>> result = thread.get()

        :param denied_action: Configure what should happen when a flow denies access to a user.  * `message_continue` - Message Continue * `message` - Message * `continue` - Continue
        :type denied_action: str
        :param designation: Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.  * `authentication` - Authentication * `authorization` - Authorization * `invalidation` - Invalidation * `enrollment` - Enrollment * `unenrollment` - Unrenollment * `recovery` - Recovery * `stage_configuration` - Stage Configuration
        :type designation: str
        :param flow_uuid:
        :type flow_uuid: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param slug:
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedFlowList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_list_with_http_info(denied_action, designation, flow_uuid, name, ordering, page, page_size, search, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_list_with_http_info(self, denied_action : Annotated[Optional[StrictStr], Field(description="Configure what should happen when a flow denies access to a user.  * `message_continue` - Message Continue * `message` - Message * `continue` - Continue")] = None, designation : Annotated[Optional[StrictStr], Field(description="Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.  * `authentication` - Authentication * `authorization` - Authorization * `invalidation` - Invalidation * `enrollment` - Enrollment * `unenrollment` - Unrenollment * `recovery` - Recovery * `stage_configuration` - Stage Configuration")] = None, flow_uuid : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, slug : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_list  # noqa: E501

        Flow Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_list_with_http_info(denied_action, designation, flow_uuid, name, ordering, page, page_size, search, slug, async_req=True)
        >>> result = thread.get()

        :param denied_action: Configure what should happen when a flow denies access to a user.  * `message_continue` - Message Continue * `message` - Message * `continue` - Continue
        :type denied_action: str
        :param designation: Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.  * `authentication` - Authentication * `authorization` - Authorization * `invalidation` - Invalidation * `enrollment` - Enrollment * `unenrollment` - Unrenollment * `recovery` - Recovery * `stage_configuration` - Stage Configuration
        :type designation: str
        :param flow_uuid:
        :type flow_uuid: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param slug:
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedFlowList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'denied_action',
            'designation',
            'flow_uuid',
            'name',
            'ordering',
            'page',
            'page_size',
            'search',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('denied_action') is not None:  # noqa: E501
            _query_params.append(('denied_action', _params['denied_action']))

        if _params.get('designation') is not None:  # noqa: E501
            _query_params.append(('designation', _params['designation']))

        if _params.get('flow_uuid') is not None:  # noqa: E501
            _query_params.append(('flow_uuid', _params['flow_uuid']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('slug') is not None:  # noqa: E501
            _query_params.append(('slug', _params['slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedFlowList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/instances/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_partial_update(self, slug : StrictStr, patched_flow_request : Optional[PatchedFlowRequest] = None, **kwargs) -> Flow:  # noqa: E501
        """flows_instances_partial_update  # noqa: E501

        Flow Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_partial_update(slug, patched_flow_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param patched_flow_request:
        :type patched_flow_request: PatchedFlowRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Flow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_partial_update_with_http_info(slug, patched_flow_request, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_partial_update_with_http_info(self, slug : StrictStr, patched_flow_request : Optional[PatchedFlowRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_partial_update  # noqa: E501

        Flow Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_partial_update_with_http_info(slug, patched_flow_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param patched_flow_request:
        :type patched_flow_request: PatchedFlowRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Flow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'patched_flow_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_flow_request'] is not None:
            _body_params = _params['patched_flow_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Flow",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/instances/{slug}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_retrieve(self, slug : StrictStr, **kwargs) -> Flow:  # noqa: E501
        """flows_instances_retrieve  # noqa: E501

        Flow Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_retrieve(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Flow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_retrieve_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_retrieve_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_retrieve  # noqa: E501

        Flow Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_retrieve_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Flow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Flow",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/instances/{slug}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_set_background_create(self, slug : StrictStr, file : Optional[Union[StrictBytes, StrictStr]] = None, clear : Optional[StrictBool] = None, **kwargs) -> None:  # noqa: E501
        """flows_instances_set_background_create  # noqa: E501

        Set Flow background  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_set_background_create(slug, file, clear, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param file:
        :type file: bytearray
        :param clear:
        :type clear: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_set_background_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_set_background_create_with_http_info(slug, file, clear, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_set_background_create_with_http_info(self, slug : StrictStr, file : Optional[Union[StrictBytes, StrictStr]] = None, clear : Optional[StrictBool] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_set_background_create  # noqa: E501

        Set Flow background  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_set_background_create_with_http_info(slug, file, clear, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param file:
        :type file: bytearray
        :param clear:
        :type clear: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'slug',
            'file',
            'clear'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_set_background_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        if _params['file']:
            _files['file'] = _params['file']

        if _params['clear']:
            _form_params.append(('clear', _params['clear']))

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/flows/instances/{slug}/set_background/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_set_background_url_create(self, slug : StrictStr, file_path_request : FilePathRequest, **kwargs) -> None:  # noqa: E501
        """flows_instances_set_background_url_create  # noqa: E501

        Set Flow background (as URL)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_set_background_url_create(slug, file_path_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param file_path_request: (required)
        :type file_path_request: FilePathRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_set_background_url_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_set_background_url_create_with_http_info(slug, file_path_request, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_set_background_url_create_with_http_info(self, slug : StrictStr, file_path_request : FilePathRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_set_background_url_create  # noqa: E501

        Set Flow background (as URL)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_set_background_url_create_with_http_info(slug, file_path_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param file_path_request: (required)
        :type file_path_request: FilePathRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'slug',
            'file_path_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_set_background_url_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['file_path_request'] is not None:
            _body_params = _params['file_path_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/flows/instances/{slug}/set_background_url/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_update(self, slug : StrictStr, flow_request : FlowRequest, **kwargs) -> Flow:  # noqa: E501
        """flows_instances_update  # noqa: E501

        Flow Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_update(slug, flow_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param flow_request: (required)
        :type flow_request: FlowRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Flow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_update_with_http_info(slug, flow_request, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_update_with_http_info(self, slug : StrictStr, flow_request : FlowRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_update  # noqa: E501

        Flow Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_update_with_http_info(slug, flow_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param flow_request: (required)
        :type flow_request: FlowRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Flow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'flow_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['flow_request'] is not None:
            _body_params = _params['flow_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Flow",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/instances/{slug}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def flows_instances_used_by_list(self, slug : StrictStr, **kwargs) -> List[UsedBy]:  # noqa: E501
        """flows_instances_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_used_by_list(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the flows_instances_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.flows_instances_used_by_list_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def flows_instances_used_by_list_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """flows_instances_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.flows_instances_used_by_list_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flows_instances_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/flows/instances/{slug}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
