# coding: utf-8

"""
    authentik

    Making authentication simple.

    The version of the OpenAPI document: 2023.6.1
    Contact: hello@goauthentik.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from datetime import datetime

from pydantic import Field, StrictBool, StrictInt, StrictStr, conlist

from typing import List, Optional

from authentik.models.authenticate_web_authn_stage import AuthenticateWebAuthnStage
from authentik.models.authenticate_web_authn_stage_request import AuthenticateWebAuthnStageRequest
from authentik.models.authenticator_duo_stage import AuthenticatorDuoStage
from authentik.models.authenticator_duo_stage_device_import_response import AuthenticatorDuoStageDeviceImportResponse
from authentik.models.authenticator_duo_stage_manual_device_import_request import AuthenticatorDuoStageManualDeviceImportRequest
from authentik.models.authenticator_duo_stage_request import AuthenticatorDuoStageRequest
from authentik.models.authenticator_sms_stage import AuthenticatorSMSStage
from authentik.models.authenticator_sms_stage_request import AuthenticatorSMSStageRequest
from authentik.models.authenticator_static_stage import AuthenticatorStaticStage
from authentik.models.authenticator_static_stage_request import AuthenticatorStaticStageRequest
from authentik.models.authenticator_totp_stage import AuthenticatorTOTPStage
from authentik.models.authenticator_totp_stage_request import AuthenticatorTOTPStageRequest
from authentik.models.authenticator_validate_stage import AuthenticatorValidateStage
from authentik.models.authenticator_validate_stage_request import AuthenticatorValidateStageRequest
from authentik.models.captcha_stage import CaptchaStage
from authentik.models.captcha_stage_request import CaptchaStageRequest
from authentik.models.consent_stage import ConsentStage
from authentik.models.consent_stage_request import ConsentStageRequest
from authentik.models.deny_stage import DenyStage
from authentik.models.deny_stage_request import DenyStageRequest
from authentik.models.dummy_stage import DummyStage
from authentik.models.dummy_stage_request import DummyStageRequest
from authentik.models.duo_device_enrollment_status import DuoDeviceEnrollmentStatus
from authentik.models.email_stage import EmailStage
from authentik.models.email_stage_request import EmailStageRequest
from authentik.models.identification_stage import IdentificationStage
from authentik.models.identification_stage_request import IdentificationStageRequest
from authentik.models.invitation import Invitation
from authentik.models.invitation_request import InvitationRequest
from authentik.models.invitation_stage import InvitationStage
from authentik.models.invitation_stage_request import InvitationStageRequest
from authentik.models.paginated_authenticate_web_authn_stage_list import PaginatedAuthenticateWebAuthnStageList
from authentik.models.paginated_authenticator_duo_stage_list import PaginatedAuthenticatorDuoStageList
from authentik.models.paginated_authenticator_sms_stage_list import PaginatedAuthenticatorSMSStageList
from authentik.models.paginated_authenticator_static_stage_list import PaginatedAuthenticatorStaticStageList
from authentik.models.paginated_authenticator_totp_stage_list import PaginatedAuthenticatorTOTPStageList
from authentik.models.paginated_authenticator_validate_stage_list import PaginatedAuthenticatorValidateStageList
from authentik.models.paginated_captcha_stage_list import PaginatedCaptchaStageList
from authentik.models.paginated_consent_stage_list import PaginatedConsentStageList
from authentik.models.paginated_deny_stage_list import PaginatedDenyStageList
from authentik.models.paginated_dummy_stage_list import PaginatedDummyStageList
from authentik.models.paginated_email_stage_list import PaginatedEmailStageList
from authentik.models.paginated_identification_stage_list import PaginatedIdentificationStageList
from authentik.models.paginated_invitation_list import PaginatedInvitationList
from authentik.models.paginated_invitation_stage_list import PaginatedInvitationStageList
from authentik.models.paginated_password_stage_list import PaginatedPasswordStageList
from authentik.models.paginated_prompt_list import PaginatedPromptList
from authentik.models.paginated_prompt_stage_list import PaginatedPromptStageList
from authentik.models.paginated_stage_list import PaginatedStageList
from authentik.models.paginated_user_delete_stage_list import PaginatedUserDeleteStageList
from authentik.models.paginated_user_login_stage_list import PaginatedUserLoginStageList
from authentik.models.paginated_user_logout_stage_list import PaginatedUserLogoutStageList
from authentik.models.paginated_user_write_stage_list import PaginatedUserWriteStageList
from authentik.models.password_stage import PasswordStage
from authentik.models.password_stage_request import PasswordStageRequest
from authentik.models.patched_authenticate_web_authn_stage_request import PatchedAuthenticateWebAuthnStageRequest
from authentik.models.patched_authenticator_duo_stage_request import PatchedAuthenticatorDuoStageRequest
from authentik.models.patched_authenticator_sms_stage_request import PatchedAuthenticatorSMSStageRequest
from authentik.models.patched_authenticator_static_stage_request import PatchedAuthenticatorStaticStageRequest
from authentik.models.patched_authenticator_totp_stage_request import PatchedAuthenticatorTOTPStageRequest
from authentik.models.patched_authenticator_validate_stage_request import PatchedAuthenticatorValidateStageRequest
from authentik.models.patched_captcha_stage_request import PatchedCaptchaStageRequest
from authentik.models.patched_consent_stage_request import PatchedConsentStageRequest
from authentik.models.patched_deny_stage_request import PatchedDenyStageRequest
from authentik.models.patched_dummy_stage_request import PatchedDummyStageRequest
from authentik.models.patched_email_stage_request import PatchedEmailStageRequest
from authentik.models.patched_identification_stage_request import PatchedIdentificationStageRequest
from authentik.models.patched_invitation_request import PatchedInvitationRequest
from authentik.models.patched_invitation_stage_request import PatchedInvitationStageRequest
from authentik.models.patched_password_stage_request import PatchedPasswordStageRequest
from authentik.models.patched_prompt_request import PatchedPromptRequest
from authentik.models.patched_prompt_stage_request import PatchedPromptStageRequest
from authentik.models.patched_user_delete_stage_request import PatchedUserDeleteStageRequest
from authentik.models.patched_user_login_stage_request import PatchedUserLoginStageRequest
from authentik.models.patched_user_logout_stage_request import PatchedUserLogoutStageRequest
from authentik.models.patched_user_write_stage_request import PatchedUserWriteStageRequest
from authentik.models.prompt import Prompt
from authentik.models.prompt_challenge import PromptChallenge
from authentik.models.prompt_request import PromptRequest
from authentik.models.prompt_stage import PromptStage
from authentik.models.prompt_stage_request import PromptStageRequest
from authentik.models.stage import Stage
from authentik.models.type_create import TypeCreate
from authentik.models.used_by import UsedBy
from authentik.models.user_delete_stage import UserDeleteStage
from authentik.models.user_delete_stage_request import UserDeleteStageRequest
from authentik.models.user_login_stage import UserLoginStage
from authentik.models.user_login_stage_request import UserLoginStageRequest
from authentik.models.user_logout_stage import UserLogoutStage
from authentik.models.user_logout_stage_request import UserLogoutStageRequest
from authentik.models.user_setting import UserSetting
from authentik.models.user_write_stage import UserWriteStage
from authentik.models.user_write_stage_request import UserWriteStageRequest

from authentik.api_client import ApiClient
from authentik.api_response import ApiResponse
from authentik.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class StagesApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def stages_all_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this stage.")], **kwargs) -> None:  # noqa: E501
        """stages_all_destroy  # noqa: E501

        Stage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_all_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_all_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_all_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_all_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_all_destroy  # noqa: E501

        Stage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_all_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_all_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/all/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_all_list(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> PaginatedStageList:  # noqa: E501
        """stages_all_list  # noqa: E501

        Stage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_all_list(name, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_all_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_all_list_with_http_info(name, ordering, page, page_size, search, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_all_list_with_http_info(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_all_list  # noqa: E501

        Stage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_all_list_with_http_info(name, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'name',
            'ordering',
            'page',
            'page_size',
            'search'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_all_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/all/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_all_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this stage.")], **kwargs) -> Stage:  # noqa: E501
        """stages_all_retrieve  # noqa: E501

        Stage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_all_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Stage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_all_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_all_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_all_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_all_retrieve  # noqa: E501

        Stage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_all_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Stage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_all_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Stage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/all/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_all_types_list(self, **kwargs) -> List[TypeCreate]:  # noqa: E501
        """stages_all_types_list  # noqa: E501

        Get all creatable stage types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_all_types_list(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[TypeCreate]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_all_types_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_all_types_list_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def stages_all_types_list_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_all_types_list  # noqa: E501

        Get all creatable stage types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_all_types_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[TypeCreate], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_all_types_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[TypeCreate]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/all/types/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_all_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_all_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_all_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_all_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_all_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_all_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_all_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_all_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_all_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/all/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_all_user_settings_list(self, **kwargs) -> List[UserSetting]:  # noqa: E501
        """stages_all_user_settings_list  # noqa: E501

        Get all stages the user can configure  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_all_user_settings_list(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UserSetting]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_all_user_settings_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_all_user_settings_list_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def stages_all_user_settings_list_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_all_user_settings_list  # noqa: E501

        Get all stages the user can configure  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_all_user_settings_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UserSetting], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_all_user_settings_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UserSetting]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/all/user_settings/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_duo_create(self, authenticator_duo_stage_request : AuthenticatorDuoStageRequest, **kwargs) -> AuthenticatorDuoStage:  # noqa: E501
        """stages_authenticator_duo_create  # noqa: E501

        AuthenticatorDuoStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_create(authenticator_duo_stage_request, async_req=True)
        >>> result = thread.get()

        :param authenticator_duo_stage_request: (required)
        :type authenticator_duo_stage_request: AuthenticatorDuoStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorDuoStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_duo_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_duo_create_with_http_info(authenticator_duo_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_duo_create_with_http_info(self, authenticator_duo_stage_request : AuthenticatorDuoStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_duo_create  # noqa: E501

        AuthenticatorDuoStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_create_with_http_info(authenticator_duo_stage_request, async_req=True)
        >>> result = thread.get()

        :param authenticator_duo_stage_request: (required)
        :type authenticator_duo_stage_request: AuthenticatorDuoStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorDuoStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authenticator_duo_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_duo_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['authenticator_duo_stage_request'] is not None:
            _body_params = _params['authenticator_duo_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "AuthenticatorDuoStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/duo/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_duo_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_authenticator_duo_destroy  # noqa: E501

        AuthenticatorDuoStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_duo_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_duo_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_duo_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_duo_destroy  # noqa: E501

        AuthenticatorDuoStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_duo_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/authenticator/duo/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_duo_enrollment_status_create(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], **kwargs) -> DuoDeviceEnrollmentStatus:  # noqa: E501
        """stages_authenticator_duo_enrollment_status_create  # noqa: E501

        Check enrollment status of user details in current session  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_enrollment_status_create(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DuoDeviceEnrollmentStatus
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_duo_enrollment_status_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_duo_enrollment_status_create_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_duo_enrollment_status_create_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_duo_enrollment_status_create  # noqa: E501

        Check enrollment status of user details in current session  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_enrollment_status_create_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DuoDeviceEnrollmentStatus, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_duo_enrollment_status_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "DuoDeviceEnrollmentStatus",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/duo/{stage_uuid}/enrollment_status/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_duo_import_device_manual_create(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], authenticator_duo_stage_manual_device_import_request : AuthenticatorDuoStageManualDeviceImportRequest, **kwargs) -> None:  # noqa: E501
        """stages_authenticator_duo_import_device_manual_create  # noqa: E501

        Import duo devices into authentik  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_import_device_manual_create(stage_uuid, authenticator_duo_stage_manual_device_import_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param authenticator_duo_stage_manual_device_import_request: (required)
        :type authenticator_duo_stage_manual_device_import_request: AuthenticatorDuoStageManualDeviceImportRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_duo_import_device_manual_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_duo_import_device_manual_create_with_http_info(stage_uuid, authenticator_duo_stage_manual_device_import_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_duo_import_device_manual_create_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], authenticator_duo_stage_manual_device_import_request : AuthenticatorDuoStageManualDeviceImportRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_duo_import_device_manual_create  # noqa: E501

        Import duo devices into authentik  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_import_device_manual_create_with_http_info(stage_uuid, authenticator_duo_stage_manual_device_import_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param authenticator_duo_stage_manual_device_import_request: (required)
        :type authenticator_duo_stage_manual_device_import_request: AuthenticatorDuoStageManualDeviceImportRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'authenticator_duo_stage_manual_device_import_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_duo_import_device_manual_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['authenticator_duo_stage_manual_device_import_request'] is not None:
            _body_params = _params['authenticator_duo_stage_manual_device_import_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/authenticator/duo/{stage_uuid}/import_device_manual/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_duo_import_devices_automatic_create(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], **kwargs) -> AuthenticatorDuoStageDeviceImportResponse:  # noqa: E501
        """stages_authenticator_duo_import_devices_automatic_create  # noqa: E501

        Import duo devices into authentik  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_import_devices_automatic_create(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorDuoStageDeviceImportResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_duo_import_devices_automatic_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_duo_import_devices_automatic_create_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_duo_import_devices_automatic_create_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_duo_import_devices_automatic_create  # noqa: E501

        Import duo devices into authentik  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_import_devices_automatic_create_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorDuoStageDeviceImportResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_duo_import_devices_automatic_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorDuoStageDeviceImportResponse",
            '400': None,
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/duo/{stage_uuid}/import_devices_automatic/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_duo_list(self, api_hostname : Optional[StrictStr] = None, client_id : Optional[StrictStr] = None, configure_flow : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> PaginatedAuthenticatorDuoStageList:  # noqa: E501
        """stages_authenticator_duo_list  # noqa: E501

        AuthenticatorDuoStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_list(api_hostname, client_id, configure_flow, name, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param api_hostname:
        :type api_hostname: str
        :param client_id:
        :type client_id: str
        :param configure_flow:
        :type configure_flow: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedAuthenticatorDuoStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_duo_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_duo_list_with_http_info(api_hostname, client_id, configure_flow, name, ordering, page, page_size, search, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_duo_list_with_http_info(self, api_hostname : Optional[StrictStr] = None, client_id : Optional[StrictStr] = None, configure_flow : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_duo_list  # noqa: E501

        AuthenticatorDuoStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_list_with_http_info(api_hostname, client_id, configure_flow, name, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param api_hostname:
        :type api_hostname: str
        :param client_id:
        :type client_id: str
        :param configure_flow:
        :type configure_flow: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedAuthenticatorDuoStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_hostname',
            'client_id',
            'configure_flow',
            'name',
            'ordering',
            'page',
            'page_size',
            'search'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_duo_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('api_hostname') is not None:  # noqa: E501
            _query_params.append(('api_hostname', _params['api_hostname']))

        if _params.get('client_id') is not None:  # noqa: E501
            _query_params.append(('client_id', _params['client_id']))

        if _params.get('configure_flow') is not None:  # noqa: E501
            _query_params.append(('configure_flow', _params['configure_flow']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedAuthenticatorDuoStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/duo/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_duo_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], patched_authenticator_duo_stage_request : Optional[PatchedAuthenticatorDuoStageRequest] = None, **kwargs) -> AuthenticatorDuoStage:  # noqa: E501
        """stages_authenticator_duo_partial_update  # noqa: E501

        AuthenticatorDuoStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_partial_update(stage_uuid, patched_authenticator_duo_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param patched_authenticator_duo_stage_request:
        :type patched_authenticator_duo_stage_request: PatchedAuthenticatorDuoStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorDuoStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_duo_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_duo_partial_update_with_http_info(stage_uuid, patched_authenticator_duo_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_duo_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], patched_authenticator_duo_stage_request : Optional[PatchedAuthenticatorDuoStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_duo_partial_update  # noqa: E501

        AuthenticatorDuoStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_partial_update_with_http_info(stage_uuid, patched_authenticator_duo_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param patched_authenticator_duo_stage_request:
        :type patched_authenticator_duo_stage_request: PatchedAuthenticatorDuoStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorDuoStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_authenticator_duo_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_duo_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_authenticator_duo_stage_request'] is not None:
            _body_params = _params['patched_authenticator_duo_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorDuoStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/duo/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_duo_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], **kwargs) -> AuthenticatorDuoStage:  # noqa: E501
        """stages_authenticator_duo_retrieve  # noqa: E501

        AuthenticatorDuoStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorDuoStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_duo_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_duo_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_duo_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_duo_retrieve  # noqa: E501

        AuthenticatorDuoStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorDuoStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_duo_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorDuoStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/duo/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_duo_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], authenticator_duo_stage_request : AuthenticatorDuoStageRequest, **kwargs) -> AuthenticatorDuoStage:  # noqa: E501
        """stages_authenticator_duo_update  # noqa: E501

        AuthenticatorDuoStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_update(stage_uuid, authenticator_duo_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param authenticator_duo_stage_request: (required)
        :type authenticator_duo_stage_request: AuthenticatorDuoStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorDuoStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_duo_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_duo_update_with_http_info(stage_uuid, authenticator_duo_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_duo_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], authenticator_duo_stage_request : AuthenticatorDuoStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_duo_update  # noqa: E501

        AuthenticatorDuoStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_update_with_http_info(stage_uuid, authenticator_duo_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param authenticator_duo_stage_request: (required)
        :type authenticator_duo_stage_request: AuthenticatorDuoStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorDuoStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'authenticator_duo_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_duo_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['authenticator_duo_stage_request'] is not None:
            _body_params = _params['authenticator_duo_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorDuoStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/duo/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_duo_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_authenticator_duo_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_duo_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_duo_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_duo_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Duo Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_duo_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_duo_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Duo Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_duo_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/duo/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_sms_create(self, authenticator_sms_stage_request : AuthenticatorSMSStageRequest, **kwargs) -> AuthenticatorSMSStage:  # noqa: E501
        """stages_authenticator_sms_create  # noqa: E501

        AuthenticatorSMSStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_create(authenticator_sms_stage_request, async_req=True)
        >>> result = thread.get()

        :param authenticator_sms_stage_request: (required)
        :type authenticator_sms_stage_request: AuthenticatorSMSStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorSMSStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_sms_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_sms_create_with_http_info(authenticator_sms_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_sms_create_with_http_info(self, authenticator_sms_stage_request : AuthenticatorSMSStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_sms_create  # noqa: E501

        AuthenticatorSMSStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_create_with_http_info(authenticator_sms_stage_request, async_req=True)
        >>> result = thread.get()

        :param authenticator_sms_stage_request: (required)
        :type authenticator_sms_stage_request: AuthenticatorSMSStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorSMSStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authenticator_sms_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_sms_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['authenticator_sms_stage_request'] is not None:
            _body_params = _params['authenticator_sms_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "AuthenticatorSMSStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/sms/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_sms_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this SMS Authenticator Setup Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_authenticator_sms_destroy  # noqa: E501

        AuthenticatorSMSStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this SMS Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_sms_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_sms_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_sms_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this SMS Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_sms_destroy  # noqa: E501

        AuthenticatorSMSStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this SMS Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_sms_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/authenticator/sms/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_sms_list(self, account_sid : Optional[StrictStr] = None, auth : Optional[StrictStr] = None, auth_password : Optional[StrictStr] = None, auth_type : Annotated[Optional[StrictStr], Field(description="* `basic` - Basic * `bearer` - Bearer")] = None, configure_flow : Optional[StrictStr] = None, friendly_name : Optional[StrictStr] = None, from_number : Optional[StrictStr] = None, mapping : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, provider : Annotated[Optional[StrictStr], Field(description="* `twilio` - Twilio * `generic` - Generic")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, verify_only : Optional[StrictBool] = None, **kwargs) -> PaginatedAuthenticatorSMSStageList:  # noqa: E501
        """stages_authenticator_sms_list  # noqa: E501

        AuthenticatorSMSStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_list(account_sid, auth, auth_password, auth_type, configure_flow, friendly_name, from_number, mapping, name, ordering, page, page_size, provider, search, stage_uuid, verify_only, async_req=True)
        >>> result = thread.get()

        :param account_sid:
        :type account_sid: str
        :param auth:
        :type auth: str
        :param auth_password:
        :type auth_password: str
        :param auth_type: * `basic` - Basic * `bearer` - Bearer
        :type auth_type: str
        :param configure_flow:
        :type configure_flow: str
        :param friendly_name:
        :type friendly_name: str
        :param from_number:
        :type from_number: str
        :param mapping:
        :type mapping: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param provider: * `twilio` - Twilio * `generic` - Generic
        :type provider: str
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param verify_only:
        :type verify_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedAuthenticatorSMSStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_sms_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_sms_list_with_http_info(account_sid, auth, auth_password, auth_type, configure_flow, friendly_name, from_number, mapping, name, ordering, page, page_size, provider, search, stage_uuid, verify_only, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_sms_list_with_http_info(self, account_sid : Optional[StrictStr] = None, auth : Optional[StrictStr] = None, auth_password : Optional[StrictStr] = None, auth_type : Annotated[Optional[StrictStr], Field(description="* `basic` - Basic * `bearer` - Bearer")] = None, configure_flow : Optional[StrictStr] = None, friendly_name : Optional[StrictStr] = None, from_number : Optional[StrictStr] = None, mapping : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, provider : Annotated[Optional[StrictStr], Field(description="* `twilio` - Twilio * `generic` - Generic")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, verify_only : Optional[StrictBool] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_sms_list  # noqa: E501

        AuthenticatorSMSStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_list_with_http_info(account_sid, auth, auth_password, auth_type, configure_flow, friendly_name, from_number, mapping, name, ordering, page, page_size, provider, search, stage_uuid, verify_only, async_req=True)
        >>> result = thread.get()

        :param account_sid:
        :type account_sid: str
        :param auth:
        :type auth: str
        :param auth_password:
        :type auth_password: str
        :param auth_type: * `basic` - Basic * `bearer` - Bearer
        :type auth_type: str
        :param configure_flow:
        :type configure_flow: str
        :param friendly_name:
        :type friendly_name: str
        :param from_number:
        :type from_number: str
        :param mapping:
        :type mapping: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param provider: * `twilio` - Twilio * `generic` - Generic
        :type provider: str
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param verify_only:
        :type verify_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedAuthenticatorSMSStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'account_sid',
            'auth',
            'auth_password',
            'auth_type',
            'configure_flow',
            'friendly_name',
            'from_number',
            'mapping',
            'name',
            'ordering',
            'page',
            'page_size',
            'provider',
            'search',
            'stage_uuid',
            'verify_only'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_sms_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('account_sid') is not None:  # noqa: E501
            _query_params.append(('account_sid', _params['account_sid']))

        if _params.get('auth') is not None:  # noqa: E501
            _query_params.append(('auth', _params['auth']))

        if _params.get('auth_password') is not None:  # noqa: E501
            _query_params.append(('auth_password', _params['auth_password']))

        if _params.get('auth_type') is not None:  # noqa: E501
            _query_params.append(('auth_type', _params['auth_type']))

        if _params.get('configure_flow') is not None:  # noqa: E501
            _query_params.append(('configure_flow', _params['configure_flow']))

        if _params.get('friendly_name') is not None:  # noqa: E501
            _query_params.append(('friendly_name', _params['friendly_name']))

        if _params.get('from_number') is not None:  # noqa: E501
            _query_params.append(('from_number', _params['from_number']))

        if _params.get('mapping') is not None:  # noqa: E501
            _query_params.append(('mapping', _params['mapping']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('provider') is not None:  # noqa: E501
            _query_params.append(('provider', _params['provider']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('stage_uuid') is not None:  # noqa: E501
            _query_params.append(('stage_uuid', _params['stage_uuid']))

        if _params.get('verify_only') is not None:  # noqa: E501
            _query_params.append(('verify_only', _params['verify_only']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedAuthenticatorSMSStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/sms/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_sms_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this SMS Authenticator Setup Stage.")], patched_authenticator_sms_stage_request : Optional[PatchedAuthenticatorSMSStageRequest] = None, **kwargs) -> AuthenticatorSMSStage:  # noqa: E501
        """stages_authenticator_sms_partial_update  # noqa: E501

        AuthenticatorSMSStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_partial_update(stage_uuid, patched_authenticator_sms_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this SMS Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param patched_authenticator_sms_stage_request:
        :type patched_authenticator_sms_stage_request: PatchedAuthenticatorSMSStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorSMSStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_sms_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_sms_partial_update_with_http_info(stage_uuid, patched_authenticator_sms_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_sms_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this SMS Authenticator Setup Stage.")], patched_authenticator_sms_stage_request : Optional[PatchedAuthenticatorSMSStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_sms_partial_update  # noqa: E501

        AuthenticatorSMSStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_partial_update_with_http_info(stage_uuid, patched_authenticator_sms_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this SMS Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param patched_authenticator_sms_stage_request:
        :type patched_authenticator_sms_stage_request: PatchedAuthenticatorSMSStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorSMSStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_authenticator_sms_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_sms_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_authenticator_sms_stage_request'] is not None:
            _body_params = _params['patched_authenticator_sms_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorSMSStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/sms/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_sms_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this SMS Authenticator Setup Stage.")], **kwargs) -> AuthenticatorSMSStage:  # noqa: E501
        """stages_authenticator_sms_retrieve  # noqa: E501

        AuthenticatorSMSStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this SMS Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorSMSStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_sms_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_sms_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_sms_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this SMS Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_sms_retrieve  # noqa: E501

        AuthenticatorSMSStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this SMS Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorSMSStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_sms_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorSMSStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/sms/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_sms_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this SMS Authenticator Setup Stage.")], authenticator_sms_stage_request : AuthenticatorSMSStageRequest, **kwargs) -> AuthenticatorSMSStage:  # noqa: E501
        """stages_authenticator_sms_update  # noqa: E501

        AuthenticatorSMSStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_update(stage_uuid, authenticator_sms_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this SMS Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param authenticator_sms_stage_request: (required)
        :type authenticator_sms_stage_request: AuthenticatorSMSStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorSMSStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_sms_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_sms_update_with_http_info(stage_uuid, authenticator_sms_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_sms_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this SMS Authenticator Setup Stage.")], authenticator_sms_stage_request : AuthenticatorSMSStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_sms_update  # noqa: E501

        AuthenticatorSMSStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_update_with_http_info(stage_uuid, authenticator_sms_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this SMS Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param authenticator_sms_stage_request: (required)
        :type authenticator_sms_stage_request: AuthenticatorSMSStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorSMSStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'authenticator_sms_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_sms_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['authenticator_sms_stage_request'] is not None:
            _body_params = _params['authenticator_sms_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorSMSStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/sms/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_sms_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this SMS Authenticator Setup Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_authenticator_sms_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this SMS Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_sms_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_sms_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_sms_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this SMS Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_sms_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_sms_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this SMS Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_sms_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/sms/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_static_create(self, authenticator_static_stage_request : AuthenticatorStaticStageRequest, **kwargs) -> AuthenticatorStaticStage:  # noqa: E501
        """stages_authenticator_static_create  # noqa: E501

        AuthenticatorStaticStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_create(authenticator_static_stage_request, async_req=True)
        >>> result = thread.get()

        :param authenticator_static_stage_request: (required)
        :type authenticator_static_stage_request: AuthenticatorStaticStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorStaticStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_static_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_static_create_with_http_info(authenticator_static_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_static_create_with_http_info(self, authenticator_static_stage_request : AuthenticatorStaticStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_static_create  # noqa: E501

        AuthenticatorStaticStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_create_with_http_info(authenticator_static_stage_request, async_req=True)
        >>> result = thread.get()

        :param authenticator_static_stage_request: (required)
        :type authenticator_static_stage_request: AuthenticatorStaticStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorStaticStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authenticator_static_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_static_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['authenticator_static_stage_request'] is not None:
            _body_params = _params['authenticator_static_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "AuthenticatorStaticStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/static/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_static_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Static Authenticator Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_authenticator_static_destroy  # noqa: E501

        AuthenticatorStaticStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Static Authenticator Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_static_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_static_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_static_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Static Authenticator Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_static_destroy  # noqa: E501

        AuthenticatorStaticStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Static Authenticator Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_static_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/authenticator/static/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_static_list(self, configure_flow : Optional[StrictStr] = None, friendly_name : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, token_count : Optional[StrictInt] = None, token_length : Optional[StrictInt] = None, **kwargs) -> PaginatedAuthenticatorStaticStageList:  # noqa: E501
        """stages_authenticator_static_list  # noqa: E501

        AuthenticatorStaticStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_list(configure_flow, friendly_name, name, ordering, page, page_size, search, stage_uuid, token_count, token_length, async_req=True)
        >>> result = thread.get()

        :param configure_flow:
        :type configure_flow: str
        :param friendly_name:
        :type friendly_name: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param token_count:
        :type token_count: int
        :param token_length:
        :type token_length: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedAuthenticatorStaticStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_static_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_static_list_with_http_info(configure_flow, friendly_name, name, ordering, page, page_size, search, stage_uuid, token_count, token_length, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_static_list_with_http_info(self, configure_flow : Optional[StrictStr] = None, friendly_name : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, token_count : Optional[StrictInt] = None, token_length : Optional[StrictInt] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_static_list  # noqa: E501

        AuthenticatorStaticStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_list_with_http_info(configure_flow, friendly_name, name, ordering, page, page_size, search, stage_uuid, token_count, token_length, async_req=True)
        >>> result = thread.get()

        :param configure_flow:
        :type configure_flow: str
        :param friendly_name:
        :type friendly_name: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param token_count:
        :type token_count: int
        :param token_length:
        :type token_length: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedAuthenticatorStaticStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'configure_flow',
            'friendly_name',
            'name',
            'ordering',
            'page',
            'page_size',
            'search',
            'stage_uuid',
            'token_count',
            'token_length'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_static_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('configure_flow') is not None:  # noqa: E501
            _query_params.append(('configure_flow', _params['configure_flow']))

        if _params.get('friendly_name') is not None:  # noqa: E501
            _query_params.append(('friendly_name', _params['friendly_name']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('stage_uuid') is not None:  # noqa: E501
            _query_params.append(('stage_uuid', _params['stage_uuid']))

        if _params.get('token_count') is not None:  # noqa: E501
            _query_params.append(('token_count', _params['token_count']))

        if _params.get('token_length') is not None:  # noqa: E501
            _query_params.append(('token_length', _params['token_length']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedAuthenticatorStaticStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/static/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_static_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Static Authenticator Stage.")], patched_authenticator_static_stage_request : Optional[PatchedAuthenticatorStaticStageRequest] = None, **kwargs) -> AuthenticatorStaticStage:  # noqa: E501
        """stages_authenticator_static_partial_update  # noqa: E501

        AuthenticatorStaticStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_partial_update(stage_uuid, patched_authenticator_static_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Static Authenticator Stage. (required)
        :type stage_uuid: str
        :param patched_authenticator_static_stage_request:
        :type patched_authenticator_static_stage_request: PatchedAuthenticatorStaticStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorStaticStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_static_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_static_partial_update_with_http_info(stage_uuid, patched_authenticator_static_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_static_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Static Authenticator Stage.")], patched_authenticator_static_stage_request : Optional[PatchedAuthenticatorStaticStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_static_partial_update  # noqa: E501

        AuthenticatorStaticStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_partial_update_with_http_info(stage_uuid, patched_authenticator_static_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Static Authenticator Stage. (required)
        :type stage_uuid: str
        :param patched_authenticator_static_stage_request:
        :type patched_authenticator_static_stage_request: PatchedAuthenticatorStaticStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorStaticStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_authenticator_static_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_static_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_authenticator_static_stage_request'] is not None:
            _body_params = _params['patched_authenticator_static_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorStaticStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/static/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_static_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Static Authenticator Stage.")], **kwargs) -> AuthenticatorStaticStage:  # noqa: E501
        """stages_authenticator_static_retrieve  # noqa: E501

        AuthenticatorStaticStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Static Authenticator Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorStaticStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_static_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_static_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_static_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Static Authenticator Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_static_retrieve  # noqa: E501

        AuthenticatorStaticStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Static Authenticator Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorStaticStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_static_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorStaticStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/static/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_static_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Static Authenticator Stage.")], authenticator_static_stage_request : AuthenticatorStaticStageRequest, **kwargs) -> AuthenticatorStaticStage:  # noqa: E501
        """stages_authenticator_static_update  # noqa: E501

        AuthenticatorStaticStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_update(stage_uuid, authenticator_static_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Static Authenticator Stage. (required)
        :type stage_uuid: str
        :param authenticator_static_stage_request: (required)
        :type authenticator_static_stage_request: AuthenticatorStaticStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorStaticStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_static_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_static_update_with_http_info(stage_uuid, authenticator_static_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_static_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Static Authenticator Stage.")], authenticator_static_stage_request : AuthenticatorStaticStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_static_update  # noqa: E501

        AuthenticatorStaticStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_update_with_http_info(stage_uuid, authenticator_static_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Static Authenticator Stage. (required)
        :type stage_uuid: str
        :param authenticator_static_stage_request: (required)
        :type authenticator_static_stage_request: AuthenticatorStaticStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorStaticStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'authenticator_static_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_static_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['authenticator_static_stage_request'] is not None:
            _body_params = _params['authenticator_static_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorStaticStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/static/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_static_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Static Authenticator Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_authenticator_static_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Static Authenticator Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_static_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_static_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_static_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Static Authenticator Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_static_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_static_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Static Authenticator Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_static_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/static/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_totp_create(self, authenticator_totp_stage_request : AuthenticatorTOTPStageRequest, **kwargs) -> AuthenticatorTOTPStage:  # noqa: E501
        """stages_authenticator_totp_create  # noqa: E501

        AuthenticatorTOTPStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_create(authenticator_totp_stage_request, async_req=True)
        >>> result = thread.get()

        :param authenticator_totp_stage_request: (required)
        :type authenticator_totp_stage_request: AuthenticatorTOTPStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorTOTPStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_totp_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_totp_create_with_http_info(authenticator_totp_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_totp_create_with_http_info(self, authenticator_totp_stage_request : AuthenticatorTOTPStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_totp_create  # noqa: E501

        AuthenticatorTOTPStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_create_with_http_info(authenticator_totp_stage_request, async_req=True)
        >>> result = thread.get()

        :param authenticator_totp_stage_request: (required)
        :type authenticator_totp_stage_request: AuthenticatorTOTPStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorTOTPStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authenticator_totp_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_totp_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['authenticator_totp_stage_request'] is not None:
            _body_params = _params['authenticator_totp_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "AuthenticatorTOTPStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/totp/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_totp_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this TOTP Authenticator Setup Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_authenticator_totp_destroy  # noqa: E501

        AuthenticatorTOTPStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this TOTP Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_totp_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_totp_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_totp_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this TOTP Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_totp_destroy  # noqa: E501

        AuthenticatorTOTPStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this TOTP Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_totp_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/authenticator/totp/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_totp_list(self, configure_flow : Optional[StrictStr] = None, digits : Annotated[Optional[StrictInt], Field(description="* `6` - 6 digits, widely compatible * `8` - 8 digits, not compatible with apps like Google Authenticator")] = None, friendly_name : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, **kwargs) -> PaginatedAuthenticatorTOTPStageList:  # noqa: E501
        """stages_authenticator_totp_list  # noqa: E501

        AuthenticatorTOTPStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_list(configure_flow, digits, friendly_name, name, ordering, page, page_size, search, stage_uuid, async_req=True)
        >>> result = thread.get()

        :param configure_flow:
        :type configure_flow: str
        :param digits: * `6` - 6 digits, widely compatible * `8` - 8 digits, not compatible with apps like Google Authenticator
        :type digits: int
        :param friendly_name:
        :type friendly_name: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedAuthenticatorTOTPStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_totp_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_totp_list_with_http_info(configure_flow, digits, friendly_name, name, ordering, page, page_size, search, stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_totp_list_with_http_info(self, configure_flow : Optional[StrictStr] = None, digits : Annotated[Optional[StrictInt], Field(description="* `6` - 6 digits, widely compatible * `8` - 8 digits, not compatible with apps like Google Authenticator")] = None, friendly_name : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_totp_list  # noqa: E501

        AuthenticatorTOTPStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_list_with_http_info(configure_flow, digits, friendly_name, name, ordering, page, page_size, search, stage_uuid, async_req=True)
        >>> result = thread.get()

        :param configure_flow:
        :type configure_flow: str
        :param digits: * `6` - 6 digits, widely compatible * `8` - 8 digits, not compatible with apps like Google Authenticator
        :type digits: int
        :param friendly_name:
        :type friendly_name: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedAuthenticatorTOTPStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'configure_flow',
            'digits',
            'friendly_name',
            'name',
            'ordering',
            'page',
            'page_size',
            'search',
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_totp_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('configure_flow') is not None:  # noqa: E501
            _query_params.append(('configure_flow', _params['configure_flow']))

        if _params.get('digits') is not None:  # noqa: E501
            _query_params.append(('digits', _params['digits']))

        if _params.get('friendly_name') is not None:  # noqa: E501
            _query_params.append(('friendly_name', _params['friendly_name']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('stage_uuid') is not None:  # noqa: E501
            _query_params.append(('stage_uuid', _params['stage_uuid']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedAuthenticatorTOTPStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/totp/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_totp_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this TOTP Authenticator Setup Stage.")], patched_authenticator_totp_stage_request : Optional[PatchedAuthenticatorTOTPStageRequest] = None, **kwargs) -> AuthenticatorTOTPStage:  # noqa: E501
        """stages_authenticator_totp_partial_update  # noqa: E501

        AuthenticatorTOTPStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_partial_update(stage_uuid, patched_authenticator_totp_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this TOTP Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param patched_authenticator_totp_stage_request:
        :type patched_authenticator_totp_stage_request: PatchedAuthenticatorTOTPStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorTOTPStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_totp_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_totp_partial_update_with_http_info(stage_uuid, patched_authenticator_totp_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_totp_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this TOTP Authenticator Setup Stage.")], patched_authenticator_totp_stage_request : Optional[PatchedAuthenticatorTOTPStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_totp_partial_update  # noqa: E501

        AuthenticatorTOTPStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_partial_update_with_http_info(stage_uuid, patched_authenticator_totp_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this TOTP Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param patched_authenticator_totp_stage_request:
        :type patched_authenticator_totp_stage_request: PatchedAuthenticatorTOTPStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorTOTPStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_authenticator_totp_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_totp_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_authenticator_totp_stage_request'] is not None:
            _body_params = _params['patched_authenticator_totp_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorTOTPStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/totp/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_totp_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this TOTP Authenticator Setup Stage.")], **kwargs) -> AuthenticatorTOTPStage:  # noqa: E501
        """stages_authenticator_totp_retrieve  # noqa: E501

        AuthenticatorTOTPStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this TOTP Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorTOTPStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_totp_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_totp_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_totp_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this TOTP Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_totp_retrieve  # noqa: E501

        AuthenticatorTOTPStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this TOTP Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorTOTPStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_totp_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorTOTPStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/totp/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_totp_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this TOTP Authenticator Setup Stage.")], authenticator_totp_stage_request : AuthenticatorTOTPStageRequest, **kwargs) -> AuthenticatorTOTPStage:  # noqa: E501
        """stages_authenticator_totp_update  # noqa: E501

        AuthenticatorTOTPStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_update(stage_uuid, authenticator_totp_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this TOTP Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param authenticator_totp_stage_request: (required)
        :type authenticator_totp_stage_request: AuthenticatorTOTPStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorTOTPStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_totp_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_totp_update_with_http_info(stage_uuid, authenticator_totp_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_totp_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this TOTP Authenticator Setup Stage.")], authenticator_totp_stage_request : AuthenticatorTOTPStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_totp_update  # noqa: E501

        AuthenticatorTOTPStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_update_with_http_info(stage_uuid, authenticator_totp_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this TOTP Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param authenticator_totp_stage_request: (required)
        :type authenticator_totp_stage_request: AuthenticatorTOTPStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorTOTPStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'authenticator_totp_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_totp_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['authenticator_totp_stage_request'] is not None:
            _body_params = _params['authenticator_totp_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorTOTPStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/totp/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_totp_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this TOTP Authenticator Setup Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_authenticator_totp_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this TOTP Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_totp_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_totp_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_totp_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this TOTP Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_totp_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_totp_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this TOTP Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_totp_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/totp/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_validate_create(self, authenticator_validate_stage_request : AuthenticatorValidateStageRequest, **kwargs) -> AuthenticatorValidateStage:  # noqa: E501
        """stages_authenticator_validate_create  # noqa: E501

        AuthenticatorValidateStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_create(authenticator_validate_stage_request, async_req=True)
        >>> result = thread.get()

        :param authenticator_validate_stage_request: (required)
        :type authenticator_validate_stage_request: AuthenticatorValidateStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorValidateStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_validate_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_validate_create_with_http_info(authenticator_validate_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_validate_create_with_http_info(self, authenticator_validate_stage_request : AuthenticatorValidateStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_validate_create  # noqa: E501

        AuthenticatorValidateStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_create_with_http_info(authenticator_validate_stage_request, async_req=True)
        >>> result = thread.get()

        :param authenticator_validate_stage_request: (required)
        :type authenticator_validate_stage_request: AuthenticatorValidateStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorValidateStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authenticator_validate_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_validate_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['authenticator_validate_stage_request'] is not None:
            _body_params = _params['authenticator_validate_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "AuthenticatorValidateStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/validate/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_validate_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Authenticator Validation Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_authenticator_validate_destroy  # noqa: E501

        AuthenticatorValidateStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Authenticator Validation Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_validate_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_validate_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_validate_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Authenticator Validation Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_validate_destroy  # noqa: E501

        AuthenticatorValidateStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Authenticator Validation Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_validate_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/authenticator/validate/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_validate_list(self, configuration_stages : Optional[conlist(StrictStr)] = None, name : Optional[StrictStr] = None, not_configured_action : Annotated[Optional[StrictStr], Field(description="* `skip` - Skip * `deny` - Deny * `configure` - Configure")] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> PaginatedAuthenticatorValidateStageList:  # noqa: E501
        """stages_authenticator_validate_list  # noqa: E501

        AuthenticatorValidateStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_list(configuration_stages, name, not_configured_action, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param configuration_stages:
        :type configuration_stages: List[str]
        :param name:
        :type name: str
        :param not_configured_action: * `skip` - Skip * `deny` - Deny * `configure` - Configure
        :type not_configured_action: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedAuthenticatorValidateStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_validate_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_validate_list_with_http_info(configuration_stages, name, not_configured_action, ordering, page, page_size, search, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_validate_list_with_http_info(self, configuration_stages : Optional[conlist(StrictStr)] = None, name : Optional[StrictStr] = None, not_configured_action : Annotated[Optional[StrictStr], Field(description="* `skip` - Skip * `deny` - Deny * `configure` - Configure")] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_validate_list  # noqa: E501

        AuthenticatorValidateStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_list_with_http_info(configuration_stages, name, not_configured_action, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param configuration_stages:
        :type configuration_stages: List[str]
        :param name:
        :type name: str
        :param not_configured_action: * `skip` - Skip * `deny` - Deny * `configure` - Configure
        :type not_configured_action: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedAuthenticatorValidateStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'configuration_stages',
            'name',
            'not_configured_action',
            'ordering',
            'page',
            'page_size',
            'search'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_validate_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('configuration_stages') is not None:  # noqa: E501
            _query_params.append(('configuration_stages', _params['configuration_stages']))
            _collection_formats['configuration_stages'] = 'multi'

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('not_configured_action') is not None:  # noqa: E501
            _query_params.append(('not_configured_action', _params['not_configured_action']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedAuthenticatorValidateStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/validate/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_validate_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Authenticator Validation Stage.")], patched_authenticator_validate_stage_request : Optional[PatchedAuthenticatorValidateStageRequest] = None, **kwargs) -> AuthenticatorValidateStage:  # noqa: E501
        """stages_authenticator_validate_partial_update  # noqa: E501

        AuthenticatorValidateStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_partial_update(stage_uuid, patched_authenticator_validate_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Authenticator Validation Stage. (required)
        :type stage_uuid: str
        :param patched_authenticator_validate_stage_request:
        :type patched_authenticator_validate_stage_request: PatchedAuthenticatorValidateStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorValidateStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_validate_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_validate_partial_update_with_http_info(stage_uuid, patched_authenticator_validate_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_validate_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Authenticator Validation Stage.")], patched_authenticator_validate_stage_request : Optional[PatchedAuthenticatorValidateStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_validate_partial_update  # noqa: E501

        AuthenticatorValidateStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_partial_update_with_http_info(stage_uuid, patched_authenticator_validate_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Authenticator Validation Stage. (required)
        :type stage_uuid: str
        :param patched_authenticator_validate_stage_request:
        :type patched_authenticator_validate_stage_request: PatchedAuthenticatorValidateStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorValidateStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_authenticator_validate_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_validate_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_authenticator_validate_stage_request'] is not None:
            _body_params = _params['patched_authenticator_validate_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorValidateStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/validate/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_validate_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Authenticator Validation Stage.")], **kwargs) -> AuthenticatorValidateStage:  # noqa: E501
        """stages_authenticator_validate_retrieve  # noqa: E501

        AuthenticatorValidateStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Authenticator Validation Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorValidateStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_validate_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_validate_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_validate_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Authenticator Validation Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_validate_retrieve  # noqa: E501

        AuthenticatorValidateStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Authenticator Validation Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorValidateStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_validate_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorValidateStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/validate/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_validate_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Authenticator Validation Stage.")], authenticator_validate_stage_request : AuthenticatorValidateStageRequest, **kwargs) -> AuthenticatorValidateStage:  # noqa: E501
        """stages_authenticator_validate_update  # noqa: E501

        AuthenticatorValidateStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_update(stage_uuid, authenticator_validate_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Authenticator Validation Stage. (required)
        :type stage_uuid: str
        :param authenticator_validate_stage_request: (required)
        :type authenticator_validate_stage_request: AuthenticatorValidateStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticatorValidateStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_validate_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_validate_update_with_http_info(stage_uuid, authenticator_validate_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_validate_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Authenticator Validation Stage.")], authenticator_validate_stage_request : AuthenticatorValidateStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_validate_update  # noqa: E501

        AuthenticatorValidateStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_update_with_http_info(stage_uuid, authenticator_validate_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Authenticator Validation Stage. (required)
        :type stage_uuid: str
        :param authenticator_validate_stage_request: (required)
        :type authenticator_validate_stage_request: AuthenticatorValidateStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticatorValidateStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'authenticator_validate_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_validate_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['authenticator_validate_stage_request'] is not None:
            _body_params = _params['authenticator_validate_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticatorValidateStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/validate/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_validate_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Authenticator Validation Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_authenticator_validate_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Authenticator Validation Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_validate_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_validate_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_validate_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Authenticator Validation Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_validate_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_validate_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Authenticator Validation Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_validate_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/validate/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_webauthn_create(self, authenticate_web_authn_stage_request : AuthenticateWebAuthnStageRequest, **kwargs) -> AuthenticateWebAuthnStage:  # noqa: E501
        """stages_authenticator_webauthn_create  # noqa: E501

        AuthenticateWebAuthnStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_create(authenticate_web_authn_stage_request, async_req=True)
        >>> result = thread.get()

        :param authenticate_web_authn_stage_request: (required)
        :type authenticate_web_authn_stage_request: AuthenticateWebAuthnStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticateWebAuthnStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_webauthn_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_webauthn_create_with_http_info(authenticate_web_authn_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_webauthn_create_with_http_info(self, authenticate_web_authn_stage_request : AuthenticateWebAuthnStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_webauthn_create  # noqa: E501

        AuthenticateWebAuthnStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_create_with_http_info(authenticate_web_authn_stage_request, async_req=True)
        >>> result = thread.get()

        :param authenticate_web_authn_stage_request: (required)
        :type authenticate_web_authn_stage_request: AuthenticateWebAuthnStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticateWebAuthnStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authenticate_web_authn_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_webauthn_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['authenticate_web_authn_stage_request'] is not None:
            _body_params = _params['authenticate_web_authn_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "AuthenticateWebAuthnStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/webauthn/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_webauthn_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this WebAuthn Authenticator Setup Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_authenticator_webauthn_destroy  # noqa: E501

        AuthenticateWebAuthnStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this WebAuthn Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_webauthn_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_webauthn_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_webauthn_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this WebAuthn Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_webauthn_destroy  # noqa: E501

        AuthenticateWebAuthnStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this WebAuthn Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_webauthn_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/authenticator/webauthn/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_webauthn_list(self, authenticator_attachment : Annotated[Optional[StrictStr], Field(description="* `platform` - Platform * `cross-platform` - Cross Platform")] = None, configure_flow : Optional[StrictStr] = None, friendly_name : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, resident_key_requirement : Annotated[Optional[StrictStr], Field(description="* `discouraged` - Discouraged * `preferred` - Preferred * `required` - Required")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, user_verification : Annotated[Optional[StrictStr], Field(description="* `required` - Required * `preferred` - Preferred * `discouraged` - Discouraged")] = None, **kwargs) -> PaginatedAuthenticateWebAuthnStageList:  # noqa: E501
        """stages_authenticator_webauthn_list  # noqa: E501

        AuthenticateWebAuthnStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_list(authenticator_attachment, configure_flow, friendly_name, name, ordering, page, page_size, resident_key_requirement, search, stage_uuid, user_verification, async_req=True)
        >>> result = thread.get()

        :param authenticator_attachment: * `platform` - Platform * `cross-platform` - Cross Platform
        :type authenticator_attachment: str
        :param configure_flow:
        :type configure_flow: str
        :param friendly_name:
        :type friendly_name: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param resident_key_requirement: * `discouraged` - Discouraged * `preferred` - Preferred * `required` - Required
        :type resident_key_requirement: str
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param user_verification: * `required` - Required * `preferred` - Preferred * `discouraged` - Discouraged
        :type user_verification: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedAuthenticateWebAuthnStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_webauthn_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_webauthn_list_with_http_info(authenticator_attachment, configure_flow, friendly_name, name, ordering, page, page_size, resident_key_requirement, search, stage_uuid, user_verification, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_webauthn_list_with_http_info(self, authenticator_attachment : Annotated[Optional[StrictStr], Field(description="* `platform` - Platform * `cross-platform` - Cross Platform")] = None, configure_flow : Optional[StrictStr] = None, friendly_name : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, resident_key_requirement : Annotated[Optional[StrictStr], Field(description="* `discouraged` - Discouraged * `preferred` - Preferred * `required` - Required")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, user_verification : Annotated[Optional[StrictStr], Field(description="* `required` - Required * `preferred` - Preferred * `discouraged` - Discouraged")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_webauthn_list  # noqa: E501

        AuthenticateWebAuthnStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_list_with_http_info(authenticator_attachment, configure_flow, friendly_name, name, ordering, page, page_size, resident_key_requirement, search, stage_uuid, user_verification, async_req=True)
        >>> result = thread.get()

        :param authenticator_attachment: * `platform` - Platform * `cross-platform` - Cross Platform
        :type authenticator_attachment: str
        :param configure_flow:
        :type configure_flow: str
        :param friendly_name:
        :type friendly_name: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param resident_key_requirement: * `discouraged` - Discouraged * `preferred` - Preferred * `required` - Required
        :type resident_key_requirement: str
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param user_verification: * `required` - Required * `preferred` - Preferred * `discouraged` - Discouraged
        :type user_verification: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedAuthenticateWebAuthnStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authenticator_attachment',
            'configure_flow',
            'friendly_name',
            'name',
            'ordering',
            'page',
            'page_size',
            'resident_key_requirement',
            'search',
            'stage_uuid',
            'user_verification'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_webauthn_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('authenticator_attachment') is not None:  # noqa: E501
            _query_params.append(('authenticator_attachment', _params['authenticator_attachment']))

        if _params.get('configure_flow') is not None:  # noqa: E501
            _query_params.append(('configure_flow', _params['configure_flow']))

        if _params.get('friendly_name') is not None:  # noqa: E501
            _query_params.append(('friendly_name', _params['friendly_name']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('resident_key_requirement') is not None:  # noqa: E501
            _query_params.append(('resident_key_requirement', _params['resident_key_requirement']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('stage_uuid') is not None:  # noqa: E501
            _query_params.append(('stage_uuid', _params['stage_uuid']))

        if _params.get('user_verification') is not None:  # noqa: E501
            _query_params.append(('user_verification', _params['user_verification']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedAuthenticateWebAuthnStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/webauthn/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_webauthn_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this WebAuthn Authenticator Setup Stage.")], patched_authenticate_web_authn_stage_request : Optional[PatchedAuthenticateWebAuthnStageRequest] = None, **kwargs) -> AuthenticateWebAuthnStage:  # noqa: E501
        """stages_authenticator_webauthn_partial_update  # noqa: E501

        AuthenticateWebAuthnStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_partial_update(stage_uuid, patched_authenticate_web_authn_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this WebAuthn Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param patched_authenticate_web_authn_stage_request:
        :type patched_authenticate_web_authn_stage_request: PatchedAuthenticateWebAuthnStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticateWebAuthnStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_webauthn_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_webauthn_partial_update_with_http_info(stage_uuid, patched_authenticate_web_authn_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_webauthn_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this WebAuthn Authenticator Setup Stage.")], patched_authenticate_web_authn_stage_request : Optional[PatchedAuthenticateWebAuthnStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_webauthn_partial_update  # noqa: E501

        AuthenticateWebAuthnStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_partial_update_with_http_info(stage_uuid, patched_authenticate_web_authn_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this WebAuthn Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param patched_authenticate_web_authn_stage_request:
        :type patched_authenticate_web_authn_stage_request: PatchedAuthenticateWebAuthnStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticateWebAuthnStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_authenticate_web_authn_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_webauthn_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_authenticate_web_authn_stage_request'] is not None:
            _body_params = _params['patched_authenticate_web_authn_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticateWebAuthnStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/webauthn/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_webauthn_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this WebAuthn Authenticator Setup Stage.")], **kwargs) -> AuthenticateWebAuthnStage:  # noqa: E501
        """stages_authenticator_webauthn_retrieve  # noqa: E501

        AuthenticateWebAuthnStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this WebAuthn Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticateWebAuthnStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_webauthn_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_webauthn_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_webauthn_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this WebAuthn Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_webauthn_retrieve  # noqa: E501

        AuthenticateWebAuthnStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this WebAuthn Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticateWebAuthnStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_webauthn_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticateWebAuthnStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/webauthn/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_webauthn_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this WebAuthn Authenticator Setup Stage.")], authenticate_web_authn_stage_request : AuthenticateWebAuthnStageRequest, **kwargs) -> AuthenticateWebAuthnStage:  # noqa: E501
        """stages_authenticator_webauthn_update  # noqa: E501

        AuthenticateWebAuthnStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_update(stage_uuid, authenticate_web_authn_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this WebAuthn Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param authenticate_web_authn_stage_request: (required)
        :type authenticate_web_authn_stage_request: AuthenticateWebAuthnStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AuthenticateWebAuthnStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_webauthn_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_webauthn_update_with_http_info(stage_uuid, authenticate_web_authn_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_webauthn_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this WebAuthn Authenticator Setup Stage.")], authenticate_web_authn_stage_request : AuthenticateWebAuthnStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_webauthn_update  # noqa: E501

        AuthenticateWebAuthnStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_update_with_http_info(stage_uuid, authenticate_web_authn_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this WebAuthn Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param authenticate_web_authn_stage_request: (required)
        :type authenticate_web_authn_stage_request: AuthenticateWebAuthnStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AuthenticateWebAuthnStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'authenticate_web_authn_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_webauthn_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['authenticate_web_authn_stage_request'] is not None:
            _body_params = _params['authenticate_web_authn_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "AuthenticateWebAuthnStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/webauthn/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_authenticator_webauthn_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this WebAuthn Authenticator Setup Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_authenticator_webauthn_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this WebAuthn Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_authenticator_webauthn_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_authenticator_webauthn_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_authenticator_webauthn_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this WebAuthn Authenticator Setup Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_authenticator_webauthn_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_authenticator_webauthn_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this WebAuthn Authenticator Setup Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_authenticator_webauthn_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/authenticator/webauthn/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_captcha_create(self, captcha_stage_request : CaptchaStageRequest, **kwargs) -> CaptchaStage:  # noqa: E501
        """stages_captcha_create  # noqa: E501

        CaptchaStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_create(captcha_stage_request, async_req=True)
        >>> result = thread.get()

        :param captcha_stage_request: (required)
        :type captcha_stage_request: CaptchaStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CaptchaStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_captcha_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_captcha_create_with_http_info(captcha_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_captcha_create_with_http_info(self, captcha_stage_request : CaptchaStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_captcha_create  # noqa: E501

        CaptchaStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_create_with_http_info(captcha_stage_request, async_req=True)
        >>> result = thread.get()

        :param captcha_stage_request: (required)
        :type captcha_stage_request: CaptchaStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CaptchaStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'captcha_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_captcha_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['captcha_stage_request'] is not None:
            _body_params = _params['captcha_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "CaptchaStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/captcha/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_captcha_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Captcha Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_captcha_destroy  # noqa: E501

        CaptchaStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Captcha Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_captcha_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_captcha_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_captcha_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Captcha Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_captcha_destroy  # noqa: E501

        CaptchaStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Captcha Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_captcha_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/captcha/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_captcha_list(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, public_key : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> PaginatedCaptchaStageList:  # noqa: E501
        """stages_captcha_list  # noqa: E501

        CaptchaStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_list(name, ordering, page, page_size, public_key, search, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param public_key:
        :type public_key: str
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedCaptchaStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_captcha_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_captcha_list_with_http_info(name, ordering, page, page_size, public_key, search, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_captcha_list_with_http_info(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, public_key : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_captcha_list  # noqa: E501

        CaptchaStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_list_with_http_info(name, ordering, page, page_size, public_key, search, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param public_key:
        :type public_key: str
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedCaptchaStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'name',
            'ordering',
            'page',
            'page_size',
            'public_key',
            'search'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_captcha_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('public_key') is not None:  # noqa: E501
            _query_params.append(('public_key', _params['public_key']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedCaptchaStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/captcha/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_captcha_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Captcha Stage.")], patched_captcha_stage_request : Optional[PatchedCaptchaStageRequest] = None, **kwargs) -> CaptchaStage:  # noqa: E501
        """stages_captcha_partial_update  # noqa: E501

        CaptchaStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_partial_update(stage_uuid, patched_captcha_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Captcha Stage. (required)
        :type stage_uuid: str
        :param patched_captcha_stage_request:
        :type patched_captcha_stage_request: PatchedCaptchaStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CaptchaStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_captcha_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_captcha_partial_update_with_http_info(stage_uuid, patched_captcha_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_captcha_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Captcha Stage.")], patched_captcha_stage_request : Optional[PatchedCaptchaStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_captcha_partial_update  # noqa: E501

        CaptchaStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_partial_update_with_http_info(stage_uuid, patched_captcha_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Captcha Stage. (required)
        :type stage_uuid: str
        :param patched_captcha_stage_request:
        :type patched_captcha_stage_request: PatchedCaptchaStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CaptchaStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_captcha_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_captcha_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_captcha_stage_request'] is not None:
            _body_params = _params['patched_captcha_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "CaptchaStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/captcha/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_captcha_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Captcha Stage.")], **kwargs) -> CaptchaStage:  # noqa: E501
        """stages_captcha_retrieve  # noqa: E501

        CaptchaStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Captcha Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CaptchaStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_captcha_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_captcha_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_captcha_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Captcha Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_captcha_retrieve  # noqa: E501

        CaptchaStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Captcha Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CaptchaStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_captcha_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "CaptchaStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/captcha/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_captcha_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Captcha Stage.")], captcha_stage_request : CaptchaStageRequest, **kwargs) -> CaptchaStage:  # noqa: E501
        """stages_captcha_update  # noqa: E501

        CaptchaStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_update(stage_uuid, captcha_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Captcha Stage. (required)
        :type stage_uuid: str
        :param captcha_stage_request: (required)
        :type captcha_stage_request: CaptchaStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CaptchaStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_captcha_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_captcha_update_with_http_info(stage_uuid, captcha_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_captcha_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Captcha Stage.")], captcha_stage_request : CaptchaStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_captcha_update  # noqa: E501

        CaptchaStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_update_with_http_info(stage_uuid, captcha_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Captcha Stage. (required)
        :type stage_uuid: str
        :param captcha_stage_request: (required)
        :type captcha_stage_request: CaptchaStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CaptchaStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'captcha_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_captcha_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['captcha_stage_request'] is not None:
            _body_params = _params['captcha_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "CaptchaStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/captcha/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_captcha_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Captcha Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_captcha_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Captcha Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_captcha_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_captcha_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_captcha_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Captcha Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_captcha_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_captcha_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Captcha Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_captcha_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/captcha/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_consent_create(self, consent_stage_request : ConsentStageRequest, **kwargs) -> ConsentStage:  # noqa: E501
        """stages_consent_create  # noqa: E501

        ConsentStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_create(consent_stage_request, async_req=True)
        >>> result = thread.get()

        :param consent_stage_request: (required)
        :type consent_stage_request: ConsentStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ConsentStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_consent_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_consent_create_with_http_info(consent_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_consent_create_with_http_info(self, consent_stage_request : ConsentStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_consent_create  # noqa: E501

        ConsentStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_create_with_http_info(consent_stage_request, async_req=True)
        >>> result = thread.get()

        :param consent_stage_request: (required)
        :type consent_stage_request: ConsentStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ConsentStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'consent_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_consent_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['consent_stage_request'] is not None:
            _body_params = _params['consent_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "ConsentStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/consent/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_consent_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Consent Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_consent_destroy  # noqa: E501

        ConsentStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Consent Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_consent_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_consent_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_consent_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Consent Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_consent_destroy  # noqa: E501

        ConsentStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Consent Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_consent_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/consent/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_consent_list(self, consent_expire_in : Optional[StrictStr] = None, mode : Annotated[Optional[StrictStr], Field(description="* `always_require` - Always Require * `permanent` - Permanent * `expiring` - Expiring")] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, **kwargs) -> PaginatedConsentStageList:  # noqa: E501
        """stages_consent_list  # noqa: E501

        ConsentStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_list(consent_expire_in, mode, name, ordering, page, page_size, search, stage_uuid, async_req=True)
        >>> result = thread.get()

        :param consent_expire_in:
        :type consent_expire_in: str
        :param mode: * `always_require` - Always Require * `permanent` - Permanent * `expiring` - Expiring
        :type mode: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedConsentStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_consent_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_consent_list_with_http_info(consent_expire_in, mode, name, ordering, page, page_size, search, stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_consent_list_with_http_info(self, consent_expire_in : Optional[StrictStr] = None, mode : Annotated[Optional[StrictStr], Field(description="* `always_require` - Always Require * `permanent` - Permanent * `expiring` - Expiring")] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_consent_list  # noqa: E501

        ConsentStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_list_with_http_info(consent_expire_in, mode, name, ordering, page, page_size, search, stage_uuid, async_req=True)
        >>> result = thread.get()

        :param consent_expire_in:
        :type consent_expire_in: str
        :param mode: * `always_require` - Always Require * `permanent` - Permanent * `expiring` - Expiring
        :type mode: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedConsentStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'consent_expire_in',
            'mode',
            'name',
            'ordering',
            'page',
            'page_size',
            'search',
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_consent_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('consent_expire_in') is not None:  # noqa: E501
            _query_params.append(('consent_expire_in', _params['consent_expire_in']))

        if _params.get('mode') is not None:  # noqa: E501
            _query_params.append(('mode', _params['mode']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('stage_uuid') is not None:  # noqa: E501
            _query_params.append(('stage_uuid', _params['stage_uuid']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedConsentStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/consent/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_consent_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Consent Stage.")], patched_consent_stage_request : Optional[PatchedConsentStageRequest] = None, **kwargs) -> ConsentStage:  # noqa: E501
        """stages_consent_partial_update  # noqa: E501

        ConsentStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_partial_update(stage_uuid, patched_consent_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Consent Stage. (required)
        :type stage_uuid: str
        :param patched_consent_stage_request:
        :type patched_consent_stage_request: PatchedConsentStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ConsentStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_consent_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_consent_partial_update_with_http_info(stage_uuid, patched_consent_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_consent_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Consent Stage.")], patched_consent_stage_request : Optional[PatchedConsentStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_consent_partial_update  # noqa: E501

        ConsentStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_partial_update_with_http_info(stage_uuid, patched_consent_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Consent Stage. (required)
        :type stage_uuid: str
        :param patched_consent_stage_request:
        :type patched_consent_stage_request: PatchedConsentStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ConsentStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_consent_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_consent_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_consent_stage_request'] is not None:
            _body_params = _params['patched_consent_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "ConsentStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/consent/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_consent_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Consent Stage.")], **kwargs) -> ConsentStage:  # noqa: E501
        """stages_consent_retrieve  # noqa: E501

        ConsentStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Consent Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ConsentStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_consent_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_consent_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_consent_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Consent Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_consent_retrieve  # noqa: E501

        ConsentStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Consent Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ConsentStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_consent_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "ConsentStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/consent/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_consent_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Consent Stage.")], consent_stage_request : ConsentStageRequest, **kwargs) -> ConsentStage:  # noqa: E501
        """stages_consent_update  # noqa: E501

        ConsentStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_update(stage_uuid, consent_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Consent Stage. (required)
        :type stage_uuid: str
        :param consent_stage_request: (required)
        :type consent_stage_request: ConsentStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ConsentStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_consent_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_consent_update_with_http_info(stage_uuid, consent_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_consent_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Consent Stage.")], consent_stage_request : ConsentStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_consent_update  # noqa: E501

        ConsentStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_update_with_http_info(stage_uuid, consent_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Consent Stage. (required)
        :type stage_uuid: str
        :param consent_stage_request: (required)
        :type consent_stage_request: ConsentStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ConsentStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'consent_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_consent_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['consent_stage_request'] is not None:
            _body_params = _params['consent_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "ConsentStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/consent/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_consent_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Consent Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_consent_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Consent Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_consent_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_consent_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_consent_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Consent Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_consent_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_consent_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Consent Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_consent_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/consent/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_deny_create(self, deny_stage_request : DenyStageRequest, **kwargs) -> DenyStage:  # noqa: E501
        """stages_deny_create  # noqa: E501

        DenyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_create(deny_stage_request, async_req=True)
        >>> result = thread.get()

        :param deny_stage_request: (required)
        :type deny_stage_request: DenyStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DenyStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_deny_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_deny_create_with_http_info(deny_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_deny_create_with_http_info(self, deny_stage_request : DenyStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_deny_create  # noqa: E501

        DenyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_create_with_http_info(deny_stage_request, async_req=True)
        >>> result = thread.get()

        :param deny_stage_request: (required)
        :type deny_stage_request: DenyStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DenyStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'deny_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_deny_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['deny_stage_request'] is not None:
            _body_params = _params['deny_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "DenyStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/deny/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_deny_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Deny Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_deny_destroy  # noqa: E501

        DenyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Deny Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_deny_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_deny_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_deny_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Deny Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_deny_destroy  # noqa: E501

        DenyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Deny Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_deny_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/deny/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_deny_list(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, **kwargs) -> PaginatedDenyStageList:  # noqa: E501
        """stages_deny_list  # noqa: E501

        DenyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_list(name, ordering, page, page_size, search, stage_uuid, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedDenyStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_deny_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_deny_list_with_http_info(name, ordering, page, page_size, search, stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_deny_list_with_http_info(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_deny_list  # noqa: E501

        DenyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_list_with_http_info(name, ordering, page, page_size, search, stage_uuid, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedDenyStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'name',
            'ordering',
            'page',
            'page_size',
            'search',
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_deny_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('stage_uuid') is not None:  # noqa: E501
            _query_params.append(('stage_uuid', _params['stage_uuid']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedDenyStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/deny/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_deny_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Deny Stage.")], patched_deny_stage_request : Optional[PatchedDenyStageRequest] = None, **kwargs) -> DenyStage:  # noqa: E501
        """stages_deny_partial_update  # noqa: E501

        DenyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_partial_update(stage_uuid, patched_deny_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Deny Stage. (required)
        :type stage_uuid: str
        :param patched_deny_stage_request:
        :type patched_deny_stage_request: PatchedDenyStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DenyStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_deny_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_deny_partial_update_with_http_info(stage_uuid, patched_deny_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_deny_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Deny Stage.")], patched_deny_stage_request : Optional[PatchedDenyStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_deny_partial_update  # noqa: E501

        DenyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_partial_update_with_http_info(stage_uuid, patched_deny_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Deny Stage. (required)
        :type stage_uuid: str
        :param patched_deny_stage_request:
        :type patched_deny_stage_request: PatchedDenyStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DenyStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_deny_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_deny_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_deny_stage_request'] is not None:
            _body_params = _params['patched_deny_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "DenyStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/deny/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_deny_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Deny Stage.")], **kwargs) -> DenyStage:  # noqa: E501
        """stages_deny_retrieve  # noqa: E501

        DenyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Deny Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DenyStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_deny_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_deny_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_deny_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Deny Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_deny_retrieve  # noqa: E501

        DenyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Deny Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DenyStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_deny_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "DenyStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/deny/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_deny_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Deny Stage.")], deny_stage_request : DenyStageRequest, **kwargs) -> DenyStage:  # noqa: E501
        """stages_deny_update  # noqa: E501

        DenyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_update(stage_uuid, deny_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Deny Stage. (required)
        :type stage_uuid: str
        :param deny_stage_request: (required)
        :type deny_stage_request: DenyStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DenyStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_deny_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_deny_update_with_http_info(stage_uuid, deny_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_deny_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Deny Stage.")], deny_stage_request : DenyStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_deny_update  # noqa: E501

        DenyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_update_with_http_info(stage_uuid, deny_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Deny Stage. (required)
        :type stage_uuid: str
        :param deny_stage_request: (required)
        :type deny_stage_request: DenyStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DenyStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'deny_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_deny_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['deny_stage_request'] is not None:
            _body_params = _params['deny_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "DenyStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/deny/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_deny_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Deny Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_deny_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Deny Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_deny_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_deny_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_deny_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Deny Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_deny_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_deny_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Deny Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_deny_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/deny/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_dummy_create(self, dummy_stage_request : DummyStageRequest, **kwargs) -> DummyStage:  # noqa: E501
        """stages_dummy_create  # noqa: E501

        DummyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_create(dummy_stage_request, async_req=True)
        >>> result = thread.get()

        :param dummy_stage_request: (required)
        :type dummy_stage_request: DummyStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DummyStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_dummy_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_dummy_create_with_http_info(dummy_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_dummy_create_with_http_info(self, dummy_stage_request : DummyStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_dummy_create  # noqa: E501

        DummyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_create_with_http_info(dummy_stage_request, async_req=True)
        >>> result = thread.get()

        :param dummy_stage_request: (required)
        :type dummy_stage_request: DummyStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DummyStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'dummy_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_dummy_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['dummy_stage_request'] is not None:
            _body_params = _params['dummy_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "DummyStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/dummy/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_dummy_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Dummy Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_dummy_destroy  # noqa: E501

        DummyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Dummy Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_dummy_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_dummy_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_dummy_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Dummy Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_dummy_destroy  # noqa: E501

        DummyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Dummy Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_dummy_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/dummy/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_dummy_list(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, throw_error : Optional[StrictBool] = None, **kwargs) -> PaginatedDummyStageList:  # noqa: E501
        """stages_dummy_list  # noqa: E501

        DummyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_list(name, ordering, page, page_size, search, stage_uuid, throw_error, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param throw_error:
        :type throw_error: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedDummyStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_dummy_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_dummy_list_with_http_info(name, ordering, page, page_size, search, stage_uuid, throw_error, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_dummy_list_with_http_info(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, throw_error : Optional[StrictBool] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_dummy_list  # noqa: E501

        DummyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_list_with_http_info(name, ordering, page, page_size, search, stage_uuid, throw_error, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param throw_error:
        :type throw_error: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedDummyStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'name',
            'ordering',
            'page',
            'page_size',
            'search',
            'stage_uuid',
            'throw_error'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_dummy_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('stage_uuid') is not None:  # noqa: E501
            _query_params.append(('stage_uuid', _params['stage_uuid']))

        if _params.get('throw_error') is not None:  # noqa: E501
            _query_params.append(('throw_error', _params['throw_error']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedDummyStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/dummy/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_dummy_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Dummy Stage.")], patched_dummy_stage_request : Optional[PatchedDummyStageRequest] = None, **kwargs) -> DummyStage:  # noqa: E501
        """stages_dummy_partial_update  # noqa: E501

        DummyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_partial_update(stage_uuid, patched_dummy_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Dummy Stage. (required)
        :type stage_uuid: str
        :param patched_dummy_stage_request:
        :type patched_dummy_stage_request: PatchedDummyStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DummyStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_dummy_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_dummy_partial_update_with_http_info(stage_uuid, patched_dummy_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_dummy_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Dummy Stage.")], patched_dummy_stage_request : Optional[PatchedDummyStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_dummy_partial_update  # noqa: E501

        DummyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_partial_update_with_http_info(stage_uuid, patched_dummy_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Dummy Stage. (required)
        :type stage_uuid: str
        :param patched_dummy_stage_request:
        :type patched_dummy_stage_request: PatchedDummyStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DummyStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_dummy_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_dummy_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_dummy_stage_request'] is not None:
            _body_params = _params['patched_dummy_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "DummyStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/dummy/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_dummy_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Dummy Stage.")], **kwargs) -> DummyStage:  # noqa: E501
        """stages_dummy_retrieve  # noqa: E501

        DummyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Dummy Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DummyStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_dummy_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_dummy_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_dummy_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Dummy Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_dummy_retrieve  # noqa: E501

        DummyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Dummy Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DummyStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_dummy_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "DummyStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/dummy/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_dummy_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Dummy Stage.")], dummy_stage_request : DummyStageRequest, **kwargs) -> DummyStage:  # noqa: E501
        """stages_dummy_update  # noqa: E501

        DummyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_update(stage_uuid, dummy_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Dummy Stage. (required)
        :type stage_uuid: str
        :param dummy_stage_request: (required)
        :type dummy_stage_request: DummyStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DummyStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_dummy_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_dummy_update_with_http_info(stage_uuid, dummy_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_dummy_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Dummy Stage.")], dummy_stage_request : DummyStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_dummy_update  # noqa: E501

        DummyStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_update_with_http_info(stage_uuid, dummy_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Dummy Stage. (required)
        :type stage_uuid: str
        :param dummy_stage_request: (required)
        :type dummy_stage_request: DummyStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DummyStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'dummy_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_dummy_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['dummy_stage_request'] is not None:
            _body_params = _params['dummy_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "DummyStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/dummy/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_dummy_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Dummy Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_dummy_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Dummy Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_dummy_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_dummy_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_dummy_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Dummy Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_dummy_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_dummy_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Dummy Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_dummy_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/dummy/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_email_create(self, email_stage_request : EmailStageRequest, **kwargs) -> EmailStage:  # noqa: E501
        """stages_email_create  # noqa: E501

        EmailStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_create(email_stage_request, async_req=True)
        >>> result = thread.get()

        :param email_stage_request: (required)
        :type email_stage_request: EmailStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmailStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_email_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_email_create_with_http_info(email_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_email_create_with_http_info(self, email_stage_request : EmailStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_email_create  # noqa: E501

        EmailStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_create_with_http_info(email_stage_request, async_req=True)
        >>> result = thread.get()

        :param email_stage_request: (required)
        :type email_stage_request: EmailStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmailStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'email_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_email_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['email_stage_request'] is not None:
            _body_params = _params['email_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "EmailStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/email/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_email_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Email Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_email_destroy  # noqa: E501

        EmailStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Email Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_email_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_email_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_email_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Email Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_email_destroy  # noqa: E501

        EmailStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Email Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_email_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/email/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_email_list(self, activate_user_on_success : Optional[StrictBool] = None, from_address : Optional[StrictStr] = None, host : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, port : Optional[StrictInt] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, subject : Optional[StrictStr] = None, template : Optional[StrictStr] = None, timeout : Optional[StrictInt] = None, token_expiry : Optional[StrictInt] = None, use_global_settings : Optional[StrictBool] = None, use_ssl : Optional[StrictBool] = None, use_tls : Optional[StrictBool] = None, username : Optional[StrictStr] = None, **kwargs) -> PaginatedEmailStageList:  # noqa: E501
        """stages_email_list  # noqa: E501

        EmailStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_list(activate_user_on_success, from_address, host, name, ordering, page, page_size, port, search, subject, template, timeout, token_expiry, use_global_settings, use_ssl, use_tls, username, async_req=True)
        >>> result = thread.get()

        :param activate_user_on_success:
        :type activate_user_on_success: bool
        :param from_address:
        :type from_address: str
        :param host:
        :type host: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param port:
        :type port: int
        :param search: A search term.
        :type search: str
        :param subject:
        :type subject: str
        :param template:
        :type template: str
        :param timeout:
        :type timeout: int
        :param token_expiry:
        :type token_expiry: int
        :param use_global_settings:
        :type use_global_settings: bool
        :param use_ssl:
        :type use_ssl: bool
        :param use_tls:
        :type use_tls: bool
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedEmailStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_email_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_email_list_with_http_info(activate_user_on_success, from_address, host, name, ordering, page, page_size, port, search, subject, template, timeout, token_expiry, use_global_settings, use_ssl, use_tls, username, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_email_list_with_http_info(self, activate_user_on_success : Optional[StrictBool] = None, from_address : Optional[StrictStr] = None, host : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, port : Optional[StrictInt] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, subject : Optional[StrictStr] = None, template : Optional[StrictStr] = None, timeout : Optional[StrictInt] = None, token_expiry : Optional[StrictInt] = None, use_global_settings : Optional[StrictBool] = None, use_ssl : Optional[StrictBool] = None, use_tls : Optional[StrictBool] = None, username : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_email_list  # noqa: E501

        EmailStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_list_with_http_info(activate_user_on_success, from_address, host, name, ordering, page, page_size, port, search, subject, template, timeout, token_expiry, use_global_settings, use_ssl, use_tls, username, async_req=True)
        >>> result = thread.get()

        :param activate_user_on_success:
        :type activate_user_on_success: bool
        :param from_address:
        :type from_address: str
        :param host:
        :type host: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param port:
        :type port: int
        :param search: A search term.
        :type search: str
        :param subject:
        :type subject: str
        :param template:
        :type template: str
        :param timeout:
        :type timeout: int
        :param token_expiry:
        :type token_expiry: int
        :param use_global_settings:
        :type use_global_settings: bool
        :param use_ssl:
        :type use_ssl: bool
        :param use_tls:
        :type use_tls: bool
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedEmailStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'activate_user_on_success',
            'from_address',
            'host',
            'name',
            'ordering',
            'page',
            'page_size',
            'port',
            'search',
            'subject',
            'template',
            'timeout',
            'token_expiry',
            'use_global_settings',
            'use_ssl',
            'use_tls',
            'username'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_email_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('activate_user_on_success') is not None:  # noqa: E501
            _query_params.append(('activate_user_on_success', _params['activate_user_on_success']))

        if _params.get('from_address') is not None:  # noqa: E501
            _query_params.append(('from_address', _params['from_address']))

        if _params.get('host') is not None:  # noqa: E501
            _query_params.append(('host', _params['host']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('port') is not None:  # noqa: E501
            _query_params.append(('port', _params['port']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('subject') is not None:  # noqa: E501
            _query_params.append(('subject', _params['subject']))

        if _params.get('template') is not None:  # noqa: E501
            _query_params.append(('template', _params['template']))

        if _params.get('timeout') is not None:  # noqa: E501
            _query_params.append(('timeout', _params['timeout']))

        if _params.get('token_expiry') is not None:  # noqa: E501
            _query_params.append(('token_expiry', _params['token_expiry']))

        if _params.get('use_global_settings') is not None:  # noqa: E501
            _query_params.append(('use_global_settings', _params['use_global_settings']))

        if _params.get('use_ssl') is not None:  # noqa: E501
            _query_params.append(('use_ssl', _params['use_ssl']))

        if _params.get('use_tls') is not None:  # noqa: E501
            _query_params.append(('use_tls', _params['use_tls']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedEmailStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/email/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_email_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Email Stage.")], patched_email_stage_request : Optional[PatchedEmailStageRequest] = None, **kwargs) -> EmailStage:  # noqa: E501
        """stages_email_partial_update  # noqa: E501

        EmailStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_partial_update(stage_uuid, patched_email_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Email Stage. (required)
        :type stage_uuid: str
        :param patched_email_stage_request:
        :type patched_email_stage_request: PatchedEmailStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmailStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_email_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_email_partial_update_with_http_info(stage_uuid, patched_email_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_email_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Email Stage.")], patched_email_stage_request : Optional[PatchedEmailStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_email_partial_update  # noqa: E501

        EmailStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_partial_update_with_http_info(stage_uuid, patched_email_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Email Stage. (required)
        :type stage_uuid: str
        :param patched_email_stage_request:
        :type patched_email_stage_request: PatchedEmailStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmailStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_email_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_email_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_email_stage_request'] is not None:
            _body_params = _params['patched_email_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "EmailStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/email/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_email_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Email Stage.")], **kwargs) -> EmailStage:  # noqa: E501
        """stages_email_retrieve  # noqa: E501

        EmailStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Email Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmailStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_email_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_email_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_email_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Email Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_email_retrieve  # noqa: E501

        EmailStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Email Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmailStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_email_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "EmailStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/email/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_email_templates_list(self, **kwargs) -> List[TypeCreate]:  # noqa: E501
        """stages_email_templates_list  # noqa: E501

        Get all available templates, including custom templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_templates_list(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[TypeCreate]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_email_templates_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_email_templates_list_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def stages_email_templates_list_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_email_templates_list  # noqa: E501

        Get all available templates, including custom templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_templates_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[TypeCreate], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_email_templates_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[TypeCreate]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/email/templates/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_email_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Email Stage.")], email_stage_request : EmailStageRequest, **kwargs) -> EmailStage:  # noqa: E501
        """stages_email_update  # noqa: E501

        EmailStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_update(stage_uuid, email_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Email Stage. (required)
        :type stage_uuid: str
        :param email_stage_request: (required)
        :type email_stage_request: EmailStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmailStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_email_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_email_update_with_http_info(stage_uuid, email_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_email_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Email Stage.")], email_stage_request : EmailStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_email_update  # noqa: E501

        EmailStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_update_with_http_info(stage_uuid, email_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Email Stage. (required)
        :type stage_uuid: str
        :param email_stage_request: (required)
        :type email_stage_request: EmailStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmailStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'email_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_email_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['email_stage_request'] is not None:
            _body_params = _params['email_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "EmailStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/email/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_email_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Email Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_email_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Email Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_email_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_email_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_email_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Email Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_email_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_email_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Email Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_email_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/email/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_identification_create(self, identification_stage_request : IdentificationStageRequest, **kwargs) -> IdentificationStage:  # noqa: E501
        """stages_identification_create  # noqa: E501

        IdentificationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_create(identification_stage_request, async_req=True)
        >>> result = thread.get()

        :param identification_stage_request: (required)
        :type identification_stage_request: IdentificationStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IdentificationStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_identification_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_identification_create_with_http_info(identification_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_identification_create_with_http_info(self, identification_stage_request : IdentificationStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_identification_create  # noqa: E501

        IdentificationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_create_with_http_info(identification_stage_request, async_req=True)
        >>> result = thread.get()

        :param identification_stage_request: (required)
        :type identification_stage_request: IdentificationStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IdentificationStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identification_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_identification_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['identification_stage_request'] is not None:
            _body_params = _params['identification_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "IdentificationStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/identification/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_identification_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Identification Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_identification_destroy  # noqa: E501

        IdentificationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Identification Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_identification_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_identification_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_identification_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Identification Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_identification_destroy  # noqa: E501

        IdentificationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Identification Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_identification_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/identification/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_identification_list(self, case_insensitive_matching : Optional[StrictBool] = None, enrollment_flow : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, password_stage : Optional[StrictStr] = None, passwordless_flow : Optional[StrictStr] = None, recovery_flow : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, show_matched_user : Optional[StrictBool] = None, show_source_labels : Optional[StrictBool] = None, **kwargs) -> PaginatedIdentificationStageList:  # noqa: E501
        """stages_identification_list  # noqa: E501

        IdentificationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_list(case_insensitive_matching, enrollment_flow, name, ordering, page, page_size, password_stage, passwordless_flow, recovery_flow, search, show_matched_user, show_source_labels, async_req=True)
        >>> result = thread.get()

        :param case_insensitive_matching:
        :type case_insensitive_matching: bool
        :param enrollment_flow:
        :type enrollment_flow: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param password_stage:
        :type password_stage: str
        :param passwordless_flow:
        :type passwordless_flow: str
        :param recovery_flow:
        :type recovery_flow: str
        :param search: A search term.
        :type search: str
        :param show_matched_user:
        :type show_matched_user: bool
        :param show_source_labels:
        :type show_source_labels: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedIdentificationStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_identification_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_identification_list_with_http_info(case_insensitive_matching, enrollment_flow, name, ordering, page, page_size, password_stage, passwordless_flow, recovery_flow, search, show_matched_user, show_source_labels, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_identification_list_with_http_info(self, case_insensitive_matching : Optional[StrictBool] = None, enrollment_flow : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, password_stage : Optional[StrictStr] = None, passwordless_flow : Optional[StrictStr] = None, recovery_flow : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, show_matched_user : Optional[StrictBool] = None, show_source_labels : Optional[StrictBool] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_identification_list  # noqa: E501

        IdentificationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_list_with_http_info(case_insensitive_matching, enrollment_flow, name, ordering, page, page_size, password_stage, passwordless_flow, recovery_flow, search, show_matched_user, show_source_labels, async_req=True)
        >>> result = thread.get()

        :param case_insensitive_matching:
        :type case_insensitive_matching: bool
        :param enrollment_flow:
        :type enrollment_flow: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param password_stage:
        :type password_stage: str
        :param passwordless_flow:
        :type passwordless_flow: str
        :param recovery_flow:
        :type recovery_flow: str
        :param search: A search term.
        :type search: str
        :param show_matched_user:
        :type show_matched_user: bool
        :param show_source_labels:
        :type show_source_labels: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedIdentificationStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'case_insensitive_matching',
            'enrollment_flow',
            'name',
            'ordering',
            'page',
            'page_size',
            'password_stage',
            'passwordless_flow',
            'recovery_flow',
            'search',
            'show_matched_user',
            'show_source_labels'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_identification_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('case_insensitive_matching') is not None:  # noqa: E501
            _query_params.append(('case_insensitive_matching', _params['case_insensitive_matching']))

        if _params.get('enrollment_flow') is not None:  # noqa: E501
            _query_params.append(('enrollment_flow', _params['enrollment_flow']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('password_stage') is not None:  # noqa: E501
            _query_params.append(('password_stage', _params['password_stage']))

        if _params.get('passwordless_flow') is not None:  # noqa: E501
            _query_params.append(('passwordless_flow', _params['passwordless_flow']))

        if _params.get('recovery_flow') is not None:  # noqa: E501
            _query_params.append(('recovery_flow', _params['recovery_flow']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('show_matched_user') is not None:  # noqa: E501
            _query_params.append(('show_matched_user', _params['show_matched_user']))

        if _params.get('show_source_labels') is not None:  # noqa: E501
            _query_params.append(('show_source_labels', _params['show_source_labels']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedIdentificationStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/identification/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_identification_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Identification Stage.")], patched_identification_stage_request : Optional[PatchedIdentificationStageRequest] = None, **kwargs) -> IdentificationStage:  # noqa: E501
        """stages_identification_partial_update  # noqa: E501

        IdentificationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_partial_update(stage_uuid, patched_identification_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Identification Stage. (required)
        :type stage_uuid: str
        :param patched_identification_stage_request:
        :type patched_identification_stage_request: PatchedIdentificationStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IdentificationStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_identification_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_identification_partial_update_with_http_info(stage_uuid, patched_identification_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_identification_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Identification Stage.")], patched_identification_stage_request : Optional[PatchedIdentificationStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_identification_partial_update  # noqa: E501

        IdentificationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_partial_update_with_http_info(stage_uuid, patched_identification_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Identification Stage. (required)
        :type stage_uuid: str
        :param patched_identification_stage_request:
        :type patched_identification_stage_request: PatchedIdentificationStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IdentificationStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_identification_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_identification_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_identification_stage_request'] is not None:
            _body_params = _params['patched_identification_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "IdentificationStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/identification/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_identification_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Identification Stage.")], **kwargs) -> IdentificationStage:  # noqa: E501
        """stages_identification_retrieve  # noqa: E501

        IdentificationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Identification Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IdentificationStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_identification_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_identification_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_identification_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Identification Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_identification_retrieve  # noqa: E501

        IdentificationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Identification Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IdentificationStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_identification_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "IdentificationStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/identification/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_identification_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Identification Stage.")], identification_stage_request : IdentificationStageRequest, **kwargs) -> IdentificationStage:  # noqa: E501
        """stages_identification_update  # noqa: E501

        IdentificationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_update(stage_uuid, identification_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Identification Stage. (required)
        :type stage_uuid: str
        :param identification_stage_request: (required)
        :type identification_stage_request: IdentificationStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IdentificationStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_identification_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_identification_update_with_http_info(stage_uuid, identification_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_identification_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Identification Stage.")], identification_stage_request : IdentificationStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_identification_update  # noqa: E501

        IdentificationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_update_with_http_info(stage_uuid, identification_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Identification Stage. (required)
        :type stage_uuid: str
        :param identification_stage_request: (required)
        :type identification_stage_request: IdentificationStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IdentificationStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'identification_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_identification_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['identification_stage_request'] is not None:
            _body_params = _params['identification_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "IdentificationStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/identification/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_identification_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Identification Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_identification_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Identification Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_identification_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_identification_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_identification_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Identification Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_identification_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_identification_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Identification Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_identification_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/identification/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_invitations_create(self, invitation_request : InvitationRequest, **kwargs) -> Invitation:  # noqa: E501
        """stages_invitation_invitations_create  # noqa: E501

        Invitation Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_create(invitation_request, async_req=True)
        >>> result = thread.get()

        :param invitation_request: (required)
        :type invitation_request: InvitationRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Invitation
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_invitations_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_invitations_create_with_http_info(invitation_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_invitations_create_with_http_info(self, invitation_request : InvitationRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_invitations_create  # noqa: E501

        Invitation Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_create_with_http_info(invitation_request, async_req=True)
        >>> result = thread.get()

        :param invitation_request: (required)
        :type invitation_request: InvitationRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Invitation, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'invitation_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_invitations_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['invitation_request'] is not None:
            _body_params = _params['invitation_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "Invitation",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/invitation/invitations/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_invitations_destroy(self, invite_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation.")], **kwargs) -> None:  # noqa: E501
        """stages_invitation_invitations_destroy  # noqa: E501

        Invitation Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_destroy(invite_uuid, async_req=True)
        >>> result = thread.get()

        :param invite_uuid: A UUID string identifying this Invitation. (required)
        :type invite_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_invitations_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_invitations_destroy_with_http_info(invite_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_invitations_destroy_with_http_info(self, invite_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_invitations_destroy  # noqa: E501

        Invitation Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_destroy_with_http_info(invite_uuid, async_req=True)
        >>> result = thread.get()

        :param invite_uuid: A UUID string identifying this Invitation. (required)
        :type invite_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'invite_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_invitations_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['invite_uuid']:
            _path_params['invite_uuid'] = _params['invite_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/invitation/invitations/{invite_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_invitations_list(self, created_by__username : Optional[StrictStr] = None, expires : Optional[datetime] = None, flow__slug : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> PaginatedInvitationList:  # noqa: E501
        """stages_invitation_invitations_list  # noqa: E501

        Invitation Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_list(created_by__username, expires, flow__slug, name, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param created_by__username:
        :type created_by__username: str
        :param expires:
        :type expires: datetime
        :param flow__slug:
        :type flow__slug: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedInvitationList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_invitations_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_invitations_list_with_http_info(created_by__username, expires, flow__slug, name, ordering, page, page_size, search, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_invitations_list_with_http_info(self, created_by__username : Optional[StrictStr] = None, expires : Optional[datetime] = None, flow__slug : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_invitations_list  # noqa: E501

        Invitation Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_list_with_http_info(created_by__username, expires, flow__slug, name, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param created_by__username:
        :type created_by__username: str
        :param expires:
        :type expires: datetime
        :param flow__slug:
        :type flow__slug: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedInvitationList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'created_by__username',
            'expires',
            'flow__slug',
            'name',
            'ordering',
            'page',
            'page_size',
            'search'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_invitations_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('created_by__username') is not None:  # noqa: E501
            _query_params.append(('created_by__username', _params['created_by__username']))

        if _params.get('expires') is not None:  # noqa: E501
            if isinstance(_params['expires'], datetime):
                _query_params.append(('expires', _params['expires'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('expires', _params['expires']))

        if _params.get('flow__slug') is not None:  # noqa: E501
            _query_params.append(('flow__slug', _params['flow__slug']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedInvitationList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/invitation/invitations/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_invitations_partial_update(self, invite_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation.")], patched_invitation_request : Optional[PatchedInvitationRequest] = None, **kwargs) -> Invitation:  # noqa: E501
        """stages_invitation_invitations_partial_update  # noqa: E501

        Invitation Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_partial_update(invite_uuid, patched_invitation_request, async_req=True)
        >>> result = thread.get()

        :param invite_uuid: A UUID string identifying this Invitation. (required)
        :type invite_uuid: str
        :param patched_invitation_request:
        :type patched_invitation_request: PatchedInvitationRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Invitation
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_invitations_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_invitations_partial_update_with_http_info(invite_uuid, patched_invitation_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_invitations_partial_update_with_http_info(self, invite_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation.")], patched_invitation_request : Optional[PatchedInvitationRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_invitations_partial_update  # noqa: E501

        Invitation Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_partial_update_with_http_info(invite_uuid, patched_invitation_request, async_req=True)
        >>> result = thread.get()

        :param invite_uuid: A UUID string identifying this Invitation. (required)
        :type invite_uuid: str
        :param patched_invitation_request:
        :type patched_invitation_request: PatchedInvitationRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Invitation, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'invite_uuid',
            'patched_invitation_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_invitations_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['invite_uuid']:
            _path_params['invite_uuid'] = _params['invite_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_invitation_request'] is not None:
            _body_params = _params['patched_invitation_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Invitation",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/invitation/invitations/{invite_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_invitations_retrieve(self, invite_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation.")], **kwargs) -> Invitation:  # noqa: E501
        """stages_invitation_invitations_retrieve  # noqa: E501

        Invitation Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_retrieve(invite_uuid, async_req=True)
        >>> result = thread.get()

        :param invite_uuid: A UUID string identifying this Invitation. (required)
        :type invite_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Invitation
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_invitations_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_invitations_retrieve_with_http_info(invite_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_invitations_retrieve_with_http_info(self, invite_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_invitations_retrieve  # noqa: E501

        Invitation Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_retrieve_with_http_info(invite_uuid, async_req=True)
        >>> result = thread.get()

        :param invite_uuid: A UUID string identifying this Invitation. (required)
        :type invite_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Invitation, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'invite_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_invitations_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['invite_uuid']:
            _path_params['invite_uuid'] = _params['invite_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Invitation",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/invitation/invitations/{invite_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_invitations_update(self, invite_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation.")], invitation_request : InvitationRequest, **kwargs) -> Invitation:  # noqa: E501
        """stages_invitation_invitations_update  # noqa: E501

        Invitation Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_update(invite_uuid, invitation_request, async_req=True)
        >>> result = thread.get()

        :param invite_uuid: A UUID string identifying this Invitation. (required)
        :type invite_uuid: str
        :param invitation_request: (required)
        :type invitation_request: InvitationRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Invitation
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_invitations_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_invitations_update_with_http_info(invite_uuid, invitation_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_invitations_update_with_http_info(self, invite_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation.")], invitation_request : InvitationRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_invitations_update  # noqa: E501

        Invitation Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_update_with_http_info(invite_uuid, invitation_request, async_req=True)
        >>> result = thread.get()

        :param invite_uuid: A UUID string identifying this Invitation. (required)
        :type invite_uuid: str
        :param invitation_request: (required)
        :type invitation_request: InvitationRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Invitation, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'invite_uuid',
            'invitation_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_invitations_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['invite_uuid']:
            _path_params['invite_uuid'] = _params['invite_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['invitation_request'] is not None:
            _body_params = _params['invitation_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Invitation",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/invitation/invitations/{invite_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_invitations_used_by_list(self, invite_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_invitation_invitations_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_used_by_list(invite_uuid, async_req=True)
        >>> result = thread.get()

        :param invite_uuid: A UUID string identifying this Invitation. (required)
        :type invite_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_invitations_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_invitations_used_by_list_with_http_info(invite_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_invitations_used_by_list_with_http_info(self, invite_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_invitations_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_invitations_used_by_list_with_http_info(invite_uuid, async_req=True)
        >>> result = thread.get()

        :param invite_uuid: A UUID string identifying this Invitation. (required)
        :type invite_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'invite_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_invitations_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['invite_uuid']:
            _path_params['invite_uuid'] = _params['invite_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/invitation/invitations/{invite_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_stages_create(self, invitation_stage_request : InvitationStageRequest, **kwargs) -> InvitationStage:  # noqa: E501
        """stages_invitation_stages_create  # noqa: E501

        InvitationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_create(invitation_stage_request, async_req=True)
        >>> result = thread.get()

        :param invitation_stage_request: (required)
        :type invitation_stage_request: InvitationStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InvitationStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_stages_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_stages_create_with_http_info(invitation_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_stages_create_with_http_info(self, invitation_stage_request : InvitationStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_stages_create  # noqa: E501

        InvitationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_create_with_http_info(invitation_stage_request, async_req=True)
        >>> result = thread.get()

        :param invitation_stage_request: (required)
        :type invitation_stage_request: InvitationStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InvitationStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'invitation_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_stages_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['invitation_stage_request'] is not None:
            _body_params = _params['invitation_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "InvitationStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/invitation/stages/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_stages_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_invitation_stages_destroy  # noqa: E501

        InvitationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Invitation Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_stages_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_stages_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_stages_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_stages_destroy  # noqa: E501

        InvitationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Invitation Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_stages_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/invitation/stages/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_stages_list(self, continue_flow_without_invitation : Optional[StrictBool] = None, name : Optional[StrictStr] = None, no_flows : Optional[StrictBool] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, **kwargs) -> PaginatedInvitationStageList:  # noqa: E501
        """stages_invitation_stages_list  # noqa: E501

        InvitationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_list(continue_flow_without_invitation, name, no_flows, ordering, page, page_size, search, stage_uuid, async_req=True)
        >>> result = thread.get()

        :param continue_flow_without_invitation:
        :type continue_flow_without_invitation: bool
        :param name:
        :type name: str
        :param no_flows:
        :type no_flows: bool
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedInvitationStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_stages_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_stages_list_with_http_info(continue_flow_without_invitation, name, no_flows, ordering, page, page_size, search, stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_stages_list_with_http_info(self, continue_flow_without_invitation : Optional[StrictBool] = None, name : Optional[StrictStr] = None, no_flows : Optional[StrictBool] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_stages_list  # noqa: E501

        InvitationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_list_with_http_info(continue_flow_without_invitation, name, no_flows, ordering, page, page_size, search, stage_uuid, async_req=True)
        >>> result = thread.get()

        :param continue_flow_without_invitation:
        :type continue_flow_without_invitation: bool
        :param name:
        :type name: str
        :param no_flows:
        :type no_flows: bool
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedInvitationStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'continue_flow_without_invitation',
            'name',
            'no_flows',
            'ordering',
            'page',
            'page_size',
            'search',
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_stages_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('continue_flow_without_invitation') is not None:  # noqa: E501
            _query_params.append(('continue_flow_without_invitation', _params['continue_flow_without_invitation']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('no_flows') is not None:  # noqa: E501
            _query_params.append(('no_flows', _params['no_flows']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('stage_uuid') is not None:  # noqa: E501
            _query_params.append(('stage_uuid', _params['stage_uuid']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedInvitationStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/invitation/stages/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_stages_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation Stage.")], patched_invitation_stage_request : Optional[PatchedInvitationStageRequest] = None, **kwargs) -> InvitationStage:  # noqa: E501
        """stages_invitation_stages_partial_update  # noqa: E501

        InvitationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_partial_update(stage_uuid, patched_invitation_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Invitation Stage. (required)
        :type stage_uuid: str
        :param patched_invitation_stage_request:
        :type patched_invitation_stage_request: PatchedInvitationStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InvitationStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_stages_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_stages_partial_update_with_http_info(stage_uuid, patched_invitation_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_stages_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation Stage.")], patched_invitation_stage_request : Optional[PatchedInvitationStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_stages_partial_update  # noqa: E501

        InvitationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_partial_update_with_http_info(stage_uuid, patched_invitation_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Invitation Stage. (required)
        :type stage_uuid: str
        :param patched_invitation_stage_request:
        :type patched_invitation_stage_request: PatchedInvitationStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InvitationStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_invitation_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_stages_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_invitation_stage_request'] is not None:
            _body_params = _params['patched_invitation_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "InvitationStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/invitation/stages/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_stages_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation Stage.")], **kwargs) -> InvitationStage:  # noqa: E501
        """stages_invitation_stages_retrieve  # noqa: E501

        InvitationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Invitation Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InvitationStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_stages_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_stages_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_stages_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_stages_retrieve  # noqa: E501

        InvitationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Invitation Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InvitationStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_stages_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "InvitationStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/invitation/stages/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_stages_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation Stage.")], invitation_stage_request : InvitationStageRequest, **kwargs) -> InvitationStage:  # noqa: E501
        """stages_invitation_stages_update  # noqa: E501

        InvitationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_update(stage_uuid, invitation_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Invitation Stage. (required)
        :type stage_uuid: str
        :param invitation_stage_request: (required)
        :type invitation_stage_request: InvitationStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InvitationStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_stages_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_stages_update_with_http_info(stage_uuid, invitation_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_stages_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation Stage.")], invitation_stage_request : InvitationStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_stages_update  # noqa: E501

        InvitationStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_update_with_http_info(stage_uuid, invitation_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Invitation Stage. (required)
        :type stage_uuid: str
        :param invitation_stage_request: (required)
        :type invitation_stage_request: InvitationStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InvitationStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'invitation_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_stages_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['invitation_stage_request'] is not None:
            _body_params = _params['invitation_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "InvitationStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/invitation/stages/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_invitation_stages_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_invitation_stages_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Invitation Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_invitation_stages_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_invitation_stages_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_invitation_stages_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Invitation Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_invitation_stages_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_invitation_stages_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Invitation Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_invitation_stages_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/invitation/stages/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_password_create(self, password_stage_request : PasswordStageRequest, **kwargs) -> PasswordStage:  # noqa: E501
        """stages_password_create  # noqa: E501

        PasswordStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_create(password_stage_request, async_req=True)
        >>> result = thread.get()

        :param password_stage_request: (required)
        :type password_stage_request: PasswordStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PasswordStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_password_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_password_create_with_http_info(password_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_password_create_with_http_info(self, password_stage_request : PasswordStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_password_create  # noqa: E501

        PasswordStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_create_with_http_info(password_stage_request, async_req=True)
        >>> result = thread.get()

        :param password_stage_request: (required)
        :type password_stage_request: PasswordStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PasswordStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'password_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_password_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['password_stage_request'] is not None:
            _body_params = _params['password_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "PasswordStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/password/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_password_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Password Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_password_destroy  # noqa: E501

        PasswordStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Password Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_password_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_password_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_password_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Password Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_password_destroy  # noqa: E501

        PasswordStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Password Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_password_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/password/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_password_list(self, configure_flow : Optional[StrictStr] = None, failed_attempts_before_cancel : Optional[StrictInt] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> PaginatedPasswordStageList:  # noqa: E501
        """stages_password_list  # noqa: E501

        PasswordStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_list(configure_flow, failed_attempts_before_cancel, name, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param configure_flow:
        :type configure_flow: str
        :param failed_attempts_before_cancel:
        :type failed_attempts_before_cancel: int
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedPasswordStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_password_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_password_list_with_http_info(configure_flow, failed_attempts_before_cancel, name, ordering, page, page_size, search, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_password_list_with_http_info(self, configure_flow : Optional[StrictStr] = None, failed_attempts_before_cancel : Optional[StrictInt] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_password_list  # noqa: E501

        PasswordStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_list_with_http_info(configure_flow, failed_attempts_before_cancel, name, ordering, page, page_size, search, async_req=True)
        >>> result = thread.get()

        :param configure_flow:
        :type configure_flow: str
        :param failed_attempts_before_cancel:
        :type failed_attempts_before_cancel: int
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedPasswordStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'configure_flow',
            'failed_attempts_before_cancel',
            'name',
            'ordering',
            'page',
            'page_size',
            'search'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_password_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('configure_flow') is not None:  # noqa: E501
            _query_params.append(('configure_flow', _params['configure_flow']))

        if _params.get('failed_attempts_before_cancel') is not None:  # noqa: E501
            _query_params.append(('failed_attempts_before_cancel', _params['failed_attempts_before_cancel']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedPasswordStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/password/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_password_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Password Stage.")], patched_password_stage_request : Optional[PatchedPasswordStageRequest] = None, **kwargs) -> PasswordStage:  # noqa: E501
        """stages_password_partial_update  # noqa: E501

        PasswordStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_partial_update(stage_uuid, patched_password_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Password Stage. (required)
        :type stage_uuid: str
        :param patched_password_stage_request:
        :type patched_password_stage_request: PatchedPasswordStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PasswordStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_password_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_password_partial_update_with_http_info(stage_uuid, patched_password_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_password_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Password Stage.")], patched_password_stage_request : Optional[PatchedPasswordStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_password_partial_update  # noqa: E501

        PasswordStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_partial_update_with_http_info(stage_uuid, patched_password_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Password Stage. (required)
        :type stage_uuid: str
        :param patched_password_stage_request:
        :type patched_password_stage_request: PatchedPasswordStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PasswordStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_password_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_password_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_password_stage_request'] is not None:
            _body_params = _params['patched_password_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PasswordStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/password/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_password_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Password Stage.")], **kwargs) -> PasswordStage:  # noqa: E501
        """stages_password_retrieve  # noqa: E501

        PasswordStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Password Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PasswordStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_password_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_password_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_password_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Password Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_password_retrieve  # noqa: E501

        PasswordStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Password Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PasswordStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_password_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PasswordStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/password/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_password_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Password Stage.")], password_stage_request : PasswordStageRequest, **kwargs) -> PasswordStage:  # noqa: E501
        """stages_password_update  # noqa: E501

        PasswordStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_update(stage_uuid, password_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Password Stage. (required)
        :type stage_uuid: str
        :param password_stage_request: (required)
        :type password_stage_request: PasswordStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PasswordStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_password_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_password_update_with_http_info(stage_uuid, password_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_password_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Password Stage.")], password_stage_request : PasswordStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_password_update  # noqa: E501

        PasswordStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_update_with_http_info(stage_uuid, password_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Password Stage. (required)
        :type stage_uuid: str
        :param password_stage_request: (required)
        :type password_stage_request: PasswordStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PasswordStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'password_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_password_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['password_stage_request'] is not None:
            _body_params = _params['password_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PasswordStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/password/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_password_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Password Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_password_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Password Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_password_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_password_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_password_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Password Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_password_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_password_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Password Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_password_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/password/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_prompts_create(self, prompt_request : PromptRequest, **kwargs) -> Prompt:  # noqa: E501
        """stages_prompt_prompts_create  # noqa: E501

        Prompt Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_create(prompt_request, async_req=True)
        >>> result = thread.get()

        :param prompt_request: (required)
        :type prompt_request: PromptRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Prompt
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_prompts_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_prompts_create_with_http_info(prompt_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_prompts_create_with_http_info(self, prompt_request : PromptRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_prompts_create  # noqa: E501

        Prompt Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_create_with_http_info(prompt_request, async_req=True)
        >>> result = thread.get()

        :param prompt_request: (required)
        :type prompt_request: PromptRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Prompt, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'prompt_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_prompts_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['prompt_request'] is not None:
            _body_params = _params['prompt_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "Prompt",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/prompt/prompts/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_prompts_destroy(self, prompt_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt.")], **kwargs) -> None:  # noqa: E501
        """stages_prompt_prompts_destroy  # noqa: E501

        Prompt Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_destroy(prompt_uuid, async_req=True)
        >>> result = thread.get()

        :param prompt_uuid: A UUID string identifying this Prompt. (required)
        :type prompt_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_prompts_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_prompts_destroy_with_http_info(prompt_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_prompts_destroy_with_http_info(self, prompt_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_prompts_destroy  # noqa: E501

        Prompt Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_destroy_with_http_info(prompt_uuid, async_req=True)
        >>> result = thread.get()

        :param prompt_uuid: A UUID string identifying this Prompt. (required)
        :type prompt_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'prompt_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_prompts_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['prompt_uuid']:
            _path_params['prompt_uuid'] = _params['prompt_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/prompt/prompts/{prompt_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_prompts_list(self, field_key : Optional[StrictStr] = None, label : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, placeholder : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, type : Annotated[Optional[StrictStr], Field(description="* `text` - Text: Simple Text input * `text_area` - Text area: Multiline Text Input. * `text_read_only` - Text (read-only): Simple Text input, but cannot be edited. * `text_area_read_only` - Text area (read-only): Multiline Text input, but cannot be edited. * `username` - Username: Same as Text input, but checks for and prevents duplicate usernames. * `email` - Email: Text field with Email type. * `password` - Password: Masked input, multiple inputs of this type on the same prompt need to be identical. * `number` - Number * `checkbox` - Checkbox * `radio-button-group` - Fixed choice field rendered as a group of radio buttons. * `dropdown` - Fixed choice field rendered as a dropdown. * `date` - Date * `date-time` - Date Time * `file` - File: File upload for arbitrary files. File content will be available in flow context as data-URI * `separator` - Separator: Static Separator Line * `hidden` - Hidden: Hidden field, can be used to insert data into form. * `static` - Static: Static value, displayed as-is. * `ak-locale` - authentik: Selection of locales authentik supports")] = None, **kwargs) -> PaginatedPromptList:  # noqa: E501
        """stages_prompt_prompts_list  # noqa: E501

        Prompt Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_list(field_key, label, name, ordering, page, page_size, placeholder, search, type, async_req=True)
        >>> result = thread.get()

        :param field_key:
        :type field_key: str
        :param label:
        :type label: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param placeholder:
        :type placeholder: str
        :param search: A search term.
        :type search: str
        :param type: * `text` - Text: Simple Text input * `text_area` - Text area: Multiline Text Input. * `text_read_only` - Text (read-only): Simple Text input, but cannot be edited. * `text_area_read_only` - Text area (read-only): Multiline Text input, but cannot be edited. * `username` - Username: Same as Text input, but checks for and prevents duplicate usernames. * `email` - Email: Text field with Email type. * `password` - Password: Masked input, multiple inputs of this type on the same prompt need to be identical. * `number` - Number * `checkbox` - Checkbox * `radio-button-group` - Fixed choice field rendered as a group of radio buttons. * `dropdown` - Fixed choice field rendered as a dropdown. * `date` - Date * `date-time` - Date Time * `file` - File: File upload for arbitrary files. File content will be available in flow context as data-URI * `separator` - Separator: Static Separator Line * `hidden` - Hidden: Hidden field, can be used to insert data into form. * `static` - Static: Static value, displayed as-is. * `ak-locale` - authentik: Selection of locales authentik supports
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedPromptList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_prompts_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_prompts_list_with_http_info(field_key, label, name, ordering, page, page_size, placeholder, search, type, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_prompts_list_with_http_info(self, field_key : Optional[StrictStr] = None, label : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, placeholder : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, type : Annotated[Optional[StrictStr], Field(description="* `text` - Text: Simple Text input * `text_area` - Text area: Multiline Text Input. * `text_read_only` - Text (read-only): Simple Text input, but cannot be edited. * `text_area_read_only` - Text area (read-only): Multiline Text input, but cannot be edited. * `username` - Username: Same as Text input, but checks for and prevents duplicate usernames. * `email` - Email: Text field with Email type. * `password` - Password: Masked input, multiple inputs of this type on the same prompt need to be identical. * `number` - Number * `checkbox` - Checkbox * `radio-button-group` - Fixed choice field rendered as a group of radio buttons. * `dropdown` - Fixed choice field rendered as a dropdown. * `date` - Date * `date-time` - Date Time * `file` - File: File upload for arbitrary files. File content will be available in flow context as data-URI * `separator` - Separator: Static Separator Line * `hidden` - Hidden: Hidden field, can be used to insert data into form. * `static` - Static: Static value, displayed as-is. * `ak-locale` - authentik: Selection of locales authentik supports")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_prompts_list  # noqa: E501

        Prompt Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_list_with_http_info(field_key, label, name, ordering, page, page_size, placeholder, search, type, async_req=True)
        >>> result = thread.get()

        :param field_key:
        :type field_key: str
        :param label:
        :type label: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param placeholder:
        :type placeholder: str
        :param search: A search term.
        :type search: str
        :param type: * `text` - Text: Simple Text input * `text_area` - Text area: Multiline Text Input. * `text_read_only` - Text (read-only): Simple Text input, but cannot be edited. * `text_area_read_only` - Text area (read-only): Multiline Text input, but cannot be edited. * `username` - Username: Same as Text input, but checks for and prevents duplicate usernames. * `email` - Email: Text field with Email type. * `password` - Password: Masked input, multiple inputs of this type on the same prompt need to be identical. * `number` - Number * `checkbox` - Checkbox * `radio-button-group` - Fixed choice field rendered as a group of radio buttons. * `dropdown` - Fixed choice field rendered as a dropdown. * `date` - Date * `date-time` - Date Time * `file` - File: File upload for arbitrary files. File content will be available in flow context as data-URI * `separator` - Separator: Static Separator Line * `hidden` - Hidden: Hidden field, can be used to insert data into form. * `static` - Static: Static value, displayed as-is. * `ak-locale` - authentik: Selection of locales authentik supports
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedPromptList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'field_key',
            'label',
            'name',
            'ordering',
            'page',
            'page_size',
            'placeholder',
            'search',
            'type'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_prompts_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('field_key') is not None:  # noqa: E501
            _query_params.append(('field_key', _params['field_key']))

        if _params.get('label') is not None:  # noqa: E501
            _query_params.append(('label', _params['label']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('placeholder') is not None:  # noqa: E501
            _query_params.append(('placeholder', _params['placeholder']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('type') is not None:  # noqa: E501
            _query_params.append(('type', _params['type']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedPromptList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/prompt/prompts/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_prompts_partial_update(self, prompt_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt.")], patched_prompt_request : Optional[PatchedPromptRequest] = None, **kwargs) -> Prompt:  # noqa: E501
        """stages_prompt_prompts_partial_update  # noqa: E501

        Prompt Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_partial_update(prompt_uuid, patched_prompt_request, async_req=True)
        >>> result = thread.get()

        :param prompt_uuid: A UUID string identifying this Prompt. (required)
        :type prompt_uuid: str
        :param patched_prompt_request:
        :type patched_prompt_request: PatchedPromptRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Prompt
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_prompts_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_prompts_partial_update_with_http_info(prompt_uuid, patched_prompt_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_prompts_partial_update_with_http_info(self, prompt_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt.")], patched_prompt_request : Optional[PatchedPromptRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_prompts_partial_update  # noqa: E501

        Prompt Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_partial_update_with_http_info(prompt_uuid, patched_prompt_request, async_req=True)
        >>> result = thread.get()

        :param prompt_uuid: A UUID string identifying this Prompt. (required)
        :type prompt_uuid: str
        :param patched_prompt_request:
        :type patched_prompt_request: PatchedPromptRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Prompt, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'prompt_uuid',
            'patched_prompt_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_prompts_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['prompt_uuid']:
            _path_params['prompt_uuid'] = _params['prompt_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_prompt_request'] is not None:
            _body_params = _params['patched_prompt_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Prompt",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/prompt/prompts/{prompt_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_prompts_preview_create(self, prompt_request : PromptRequest, **kwargs) -> PromptChallenge:  # noqa: E501
        """stages_prompt_prompts_preview_create  # noqa: E501

        Preview a prompt as a challenge, just like a flow would receive  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_preview_create(prompt_request, async_req=True)
        >>> result = thread.get()

        :param prompt_request: (required)
        :type prompt_request: PromptRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PromptChallenge
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_prompts_preview_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_prompts_preview_create_with_http_info(prompt_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_prompts_preview_create_with_http_info(self, prompt_request : PromptRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_prompts_preview_create  # noqa: E501

        Preview a prompt as a challenge, just like a flow would receive  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_preview_create_with_http_info(prompt_request, async_req=True)
        >>> result = thread.get()

        :param prompt_request: (required)
        :type prompt_request: PromptRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PromptChallenge, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'prompt_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_prompts_preview_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['prompt_request'] is not None:
            _body_params = _params['prompt_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PromptChallenge",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/prompt/prompts/preview/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_prompts_retrieve(self, prompt_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt.")], **kwargs) -> Prompt:  # noqa: E501
        """stages_prompt_prompts_retrieve  # noqa: E501

        Prompt Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_retrieve(prompt_uuid, async_req=True)
        >>> result = thread.get()

        :param prompt_uuid: A UUID string identifying this Prompt. (required)
        :type prompt_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Prompt
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_prompts_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_prompts_retrieve_with_http_info(prompt_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_prompts_retrieve_with_http_info(self, prompt_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_prompts_retrieve  # noqa: E501

        Prompt Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_retrieve_with_http_info(prompt_uuid, async_req=True)
        >>> result = thread.get()

        :param prompt_uuid: A UUID string identifying this Prompt. (required)
        :type prompt_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Prompt, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'prompt_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_prompts_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['prompt_uuid']:
            _path_params['prompt_uuid'] = _params['prompt_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Prompt",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/prompt/prompts/{prompt_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_prompts_update(self, prompt_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt.")], prompt_request : PromptRequest, **kwargs) -> Prompt:  # noqa: E501
        """stages_prompt_prompts_update  # noqa: E501

        Prompt Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_update(prompt_uuid, prompt_request, async_req=True)
        >>> result = thread.get()

        :param prompt_uuid: A UUID string identifying this Prompt. (required)
        :type prompt_uuid: str
        :param prompt_request: (required)
        :type prompt_request: PromptRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Prompt
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_prompts_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_prompts_update_with_http_info(prompt_uuid, prompt_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_prompts_update_with_http_info(self, prompt_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt.")], prompt_request : PromptRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_prompts_update  # noqa: E501

        Prompt Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_update_with_http_info(prompt_uuid, prompt_request, async_req=True)
        >>> result = thread.get()

        :param prompt_uuid: A UUID string identifying this Prompt. (required)
        :type prompt_uuid: str
        :param prompt_request: (required)
        :type prompt_request: PromptRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Prompt, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'prompt_uuid',
            'prompt_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_prompts_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['prompt_uuid']:
            _path_params['prompt_uuid'] = _params['prompt_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['prompt_request'] is not None:
            _body_params = _params['prompt_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Prompt",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/prompt/prompts/{prompt_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_prompts_used_by_list(self, prompt_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_prompt_prompts_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_used_by_list(prompt_uuid, async_req=True)
        >>> result = thread.get()

        :param prompt_uuid: A UUID string identifying this Prompt. (required)
        :type prompt_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_prompts_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_prompts_used_by_list_with_http_info(prompt_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_prompts_used_by_list_with_http_info(self, prompt_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_prompts_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_prompts_used_by_list_with_http_info(prompt_uuid, async_req=True)
        >>> result = thread.get()

        :param prompt_uuid: A UUID string identifying this Prompt. (required)
        :type prompt_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'prompt_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_prompts_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['prompt_uuid']:
            _path_params['prompt_uuid'] = _params['prompt_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/prompt/prompts/{prompt_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_stages_create(self, prompt_stage_request : PromptStageRequest, **kwargs) -> PromptStage:  # noqa: E501
        """stages_prompt_stages_create  # noqa: E501

        PromptStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_create(prompt_stage_request, async_req=True)
        >>> result = thread.get()

        :param prompt_stage_request: (required)
        :type prompt_stage_request: PromptStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PromptStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_stages_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_stages_create_with_http_info(prompt_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_stages_create_with_http_info(self, prompt_stage_request : PromptStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_stages_create  # noqa: E501

        PromptStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_create_with_http_info(prompt_stage_request, async_req=True)
        >>> result = thread.get()

        :param prompt_stage_request: (required)
        :type prompt_stage_request: PromptStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PromptStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'prompt_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_stages_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['prompt_stage_request'] is not None:
            _body_params = _params['prompt_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "PromptStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/prompt/stages/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_stages_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_prompt_stages_destroy  # noqa: E501

        PromptStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Prompt Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_stages_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_stages_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_stages_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_stages_destroy  # noqa: E501

        PromptStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Prompt Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_stages_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/prompt/stages/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_stages_list(self, fields : Optional[conlist(StrictStr)] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, validation_policies : Optional[conlist(StrictStr)] = None, **kwargs) -> PaginatedPromptStageList:  # noqa: E501
        """stages_prompt_stages_list  # noqa: E501

        PromptStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_list(fields, name, ordering, page, page_size, search, stage_uuid, validation_policies, async_req=True)
        >>> result = thread.get()

        :param fields:
        :type fields: List[str]
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param validation_policies:
        :type validation_policies: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedPromptStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_stages_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_stages_list_with_http_info(fields, name, ordering, page, page_size, search, stage_uuid, validation_policies, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_stages_list_with_http_info(self, fields : Optional[conlist(StrictStr)] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, validation_policies : Optional[conlist(StrictStr)] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_stages_list  # noqa: E501

        PromptStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_list_with_http_info(fields, name, ordering, page, page_size, search, stage_uuid, validation_policies, async_req=True)
        >>> result = thread.get()

        :param fields:
        :type fields: List[str]
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param validation_policies:
        :type validation_policies: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedPromptStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'fields',
            'name',
            'ordering',
            'page',
            'page_size',
            'search',
            'stage_uuid',
            'validation_policies'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_stages_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('fields') is not None:  # noqa: E501
            _query_params.append(('fields', _params['fields']))
            _collection_formats['fields'] = 'multi'

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('stage_uuid') is not None:  # noqa: E501
            _query_params.append(('stage_uuid', _params['stage_uuid']))

        if _params.get('validation_policies') is not None:  # noqa: E501
            _query_params.append(('validation_policies', _params['validation_policies']))
            _collection_formats['validation_policies'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedPromptStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/prompt/stages/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_stages_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt Stage.")], patched_prompt_stage_request : Optional[PatchedPromptStageRequest] = None, **kwargs) -> PromptStage:  # noqa: E501
        """stages_prompt_stages_partial_update  # noqa: E501

        PromptStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_partial_update(stage_uuid, patched_prompt_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Prompt Stage. (required)
        :type stage_uuid: str
        :param patched_prompt_stage_request:
        :type patched_prompt_stage_request: PatchedPromptStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PromptStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_stages_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_stages_partial_update_with_http_info(stage_uuid, patched_prompt_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_stages_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt Stage.")], patched_prompt_stage_request : Optional[PatchedPromptStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_stages_partial_update  # noqa: E501

        PromptStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_partial_update_with_http_info(stage_uuid, patched_prompt_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Prompt Stage. (required)
        :type stage_uuid: str
        :param patched_prompt_stage_request:
        :type patched_prompt_stage_request: PatchedPromptStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PromptStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_prompt_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_stages_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_prompt_stage_request'] is not None:
            _body_params = _params['patched_prompt_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PromptStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/prompt/stages/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_stages_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt Stage.")], **kwargs) -> PromptStage:  # noqa: E501
        """stages_prompt_stages_retrieve  # noqa: E501

        PromptStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Prompt Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PromptStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_stages_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_stages_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_stages_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_stages_retrieve  # noqa: E501

        PromptStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Prompt Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PromptStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_stages_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PromptStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/prompt/stages/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_stages_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt Stage.")], prompt_stage_request : PromptStageRequest, **kwargs) -> PromptStage:  # noqa: E501
        """stages_prompt_stages_update  # noqa: E501

        PromptStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_update(stage_uuid, prompt_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Prompt Stage. (required)
        :type stage_uuid: str
        :param prompt_stage_request: (required)
        :type prompt_stage_request: PromptStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PromptStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_stages_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_stages_update_with_http_info(stage_uuid, prompt_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_stages_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt Stage.")], prompt_stage_request : PromptStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_stages_update  # noqa: E501

        PromptStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_update_with_http_info(stage_uuid, prompt_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Prompt Stage. (required)
        :type stage_uuid: str
        :param prompt_stage_request: (required)
        :type prompt_stage_request: PromptStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PromptStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'prompt_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_stages_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['prompt_stage_request'] is not None:
            _body_params = _params['prompt_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PromptStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/prompt/stages/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_prompt_stages_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_prompt_stages_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Prompt Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_prompt_stages_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_prompt_stages_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_prompt_stages_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this Prompt Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_prompt_stages_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_prompt_stages_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this Prompt Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_prompt_stages_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/prompt/stages/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_delete_create(self, user_delete_stage_request : UserDeleteStageRequest, **kwargs) -> UserDeleteStage:  # noqa: E501
        """stages_user_delete_create  # noqa: E501

        UserDeleteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_create(user_delete_stage_request, async_req=True)
        >>> result = thread.get()

        :param user_delete_stage_request: (required)
        :type user_delete_stage_request: UserDeleteStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserDeleteStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_delete_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_delete_create_with_http_info(user_delete_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_delete_create_with_http_info(self, user_delete_stage_request : UserDeleteStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_delete_create  # noqa: E501

        UserDeleteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_create_with_http_info(user_delete_stage_request, async_req=True)
        >>> result = thread.get()

        :param user_delete_stage_request: (required)
        :type user_delete_stage_request: UserDeleteStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserDeleteStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'user_delete_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_delete_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['user_delete_stage_request'] is not None:
            _body_params = _params['user_delete_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "UserDeleteStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_delete/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_delete_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Delete Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_user_delete_destroy  # noqa: E501

        UserDeleteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Delete Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_delete_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_delete_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_delete_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Delete Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_delete_destroy  # noqa: E501

        UserDeleteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Delete Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_delete_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/user_delete/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_delete_list(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, **kwargs) -> PaginatedUserDeleteStageList:  # noqa: E501
        """stages_user_delete_list  # noqa: E501

        UserDeleteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_list(name, ordering, page, page_size, search, stage_uuid, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedUserDeleteStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_delete_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_delete_list_with_http_info(name, ordering, page, page_size, search, stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_delete_list_with_http_info(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_delete_list  # noqa: E501

        UserDeleteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_list_with_http_info(name, ordering, page, page_size, search, stage_uuid, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedUserDeleteStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'name',
            'ordering',
            'page',
            'page_size',
            'search',
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_delete_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('stage_uuid') is not None:  # noqa: E501
            _query_params.append(('stage_uuid', _params['stage_uuid']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedUserDeleteStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_delete/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_delete_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Delete Stage.")], patched_user_delete_stage_request : Optional[PatchedUserDeleteStageRequest] = None, **kwargs) -> UserDeleteStage:  # noqa: E501
        """stages_user_delete_partial_update  # noqa: E501

        UserDeleteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_partial_update(stage_uuid, patched_user_delete_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Delete Stage. (required)
        :type stage_uuid: str
        :param patched_user_delete_stage_request:
        :type patched_user_delete_stage_request: PatchedUserDeleteStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserDeleteStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_delete_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_delete_partial_update_with_http_info(stage_uuid, patched_user_delete_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_delete_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Delete Stage.")], patched_user_delete_stage_request : Optional[PatchedUserDeleteStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_delete_partial_update  # noqa: E501

        UserDeleteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_partial_update_with_http_info(stage_uuid, patched_user_delete_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Delete Stage. (required)
        :type stage_uuid: str
        :param patched_user_delete_stage_request:
        :type patched_user_delete_stage_request: PatchedUserDeleteStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserDeleteStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_user_delete_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_delete_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_user_delete_stage_request'] is not None:
            _body_params = _params['patched_user_delete_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserDeleteStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_delete/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_delete_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Delete Stage.")], **kwargs) -> UserDeleteStage:  # noqa: E501
        """stages_user_delete_retrieve  # noqa: E501

        UserDeleteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Delete Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserDeleteStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_delete_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_delete_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_delete_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Delete Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_delete_retrieve  # noqa: E501

        UserDeleteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Delete Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserDeleteStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_delete_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserDeleteStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_delete/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_delete_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Delete Stage.")], user_delete_stage_request : UserDeleteStageRequest, **kwargs) -> UserDeleteStage:  # noqa: E501
        """stages_user_delete_update  # noqa: E501

        UserDeleteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_update(stage_uuid, user_delete_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Delete Stage. (required)
        :type stage_uuid: str
        :param user_delete_stage_request: (required)
        :type user_delete_stage_request: UserDeleteStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserDeleteStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_delete_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_delete_update_with_http_info(stage_uuid, user_delete_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_delete_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Delete Stage.")], user_delete_stage_request : UserDeleteStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_delete_update  # noqa: E501

        UserDeleteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_update_with_http_info(stage_uuid, user_delete_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Delete Stage. (required)
        :type stage_uuid: str
        :param user_delete_stage_request: (required)
        :type user_delete_stage_request: UserDeleteStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserDeleteStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'user_delete_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_delete_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['user_delete_stage_request'] is not None:
            _body_params = _params['user_delete_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserDeleteStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_delete/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_delete_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Delete Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_user_delete_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Delete Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_delete_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_delete_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_delete_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Delete Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_delete_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_delete_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Delete Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_delete_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_delete/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_login_create(self, user_login_stage_request : UserLoginStageRequest, **kwargs) -> UserLoginStage:  # noqa: E501
        """stages_user_login_create  # noqa: E501

        UserLoginStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_create(user_login_stage_request, async_req=True)
        >>> result = thread.get()

        :param user_login_stage_request: (required)
        :type user_login_stage_request: UserLoginStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserLoginStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_login_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_login_create_with_http_info(user_login_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_login_create_with_http_info(self, user_login_stage_request : UserLoginStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_login_create  # noqa: E501

        UserLoginStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_create_with_http_info(user_login_stage_request, async_req=True)
        >>> result = thread.get()

        :param user_login_stage_request: (required)
        :type user_login_stage_request: UserLoginStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserLoginStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'user_login_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_login_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['user_login_stage_request'] is not None:
            _body_params = _params['user_login_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "UserLoginStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_login/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_login_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Login Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_user_login_destroy  # noqa: E501

        UserLoginStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Login Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_login_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_login_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_login_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Login Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_login_destroy  # noqa: E501

        UserLoginStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Login Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_login_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/user_login/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_login_list(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, remember_me_offset : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, session_duration : Optional[StrictStr] = None, stage_uuid : Optional[StrictStr] = None, terminate_other_sessions : Optional[StrictBool] = None, **kwargs) -> PaginatedUserLoginStageList:  # noqa: E501
        """stages_user_login_list  # noqa: E501

        UserLoginStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_list(name, ordering, page, page_size, remember_me_offset, search, session_duration, stage_uuid, terminate_other_sessions, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param remember_me_offset:
        :type remember_me_offset: str
        :param search: A search term.
        :type search: str
        :param session_duration:
        :type session_duration: str
        :param stage_uuid:
        :type stage_uuid: str
        :param terminate_other_sessions:
        :type terminate_other_sessions: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedUserLoginStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_login_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_login_list_with_http_info(name, ordering, page, page_size, remember_me_offset, search, session_duration, stage_uuid, terminate_other_sessions, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_login_list_with_http_info(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, remember_me_offset : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, session_duration : Optional[StrictStr] = None, stage_uuid : Optional[StrictStr] = None, terminate_other_sessions : Optional[StrictBool] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_login_list  # noqa: E501

        UserLoginStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_list_with_http_info(name, ordering, page, page_size, remember_me_offset, search, session_duration, stage_uuid, terminate_other_sessions, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param remember_me_offset:
        :type remember_me_offset: str
        :param search: A search term.
        :type search: str
        :param session_duration:
        :type session_duration: str
        :param stage_uuid:
        :type stage_uuid: str
        :param terminate_other_sessions:
        :type terminate_other_sessions: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedUserLoginStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'name',
            'ordering',
            'page',
            'page_size',
            'remember_me_offset',
            'search',
            'session_duration',
            'stage_uuid',
            'terminate_other_sessions'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_login_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('remember_me_offset') is not None:  # noqa: E501
            _query_params.append(('remember_me_offset', _params['remember_me_offset']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('session_duration') is not None:  # noqa: E501
            _query_params.append(('session_duration', _params['session_duration']))

        if _params.get('stage_uuid') is not None:  # noqa: E501
            _query_params.append(('stage_uuid', _params['stage_uuid']))

        if _params.get('terminate_other_sessions') is not None:  # noqa: E501
            _query_params.append(('terminate_other_sessions', _params['terminate_other_sessions']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedUserLoginStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_login/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_login_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Login Stage.")], patched_user_login_stage_request : Optional[PatchedUserLoginStageRequest] = None, **kwargs) -> UserLoginStage:  # noqa: E501
        """stages_user_login_partial_update  # noqa: E501

        UserLoginStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_partial_update(stage_uuid, patched_user_login_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Login Stage. (required)
        :type stage_uuid: str
        :param patched_user_login_stage_request:
        :type patched_user_login_stage_request: PatchedUserLoginStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserLoginStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_login_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_login_partial_update_with_http_info(stage_uuid, patched_user_login_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_login_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Login Stage.")], patched_user_login_stage_request : Optional[PatchedUserLoginStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_login_partial_update  # noqa: E501

        UserLoginStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_partial_update_with_http_info(stage_uuid, patched_user_login_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Login Stage. (required)
        :type stage_uuid: str
        :param patched_user_login_stage_request:
        :type patched_user_login_stage_request: PatchedUserLoginStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserLoginStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_user_login_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_login_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_user_login_stage_request'] is not None:
            _body_params = _params['patched_user_login_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserLoginStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_login/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_login_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Login Stage.")], **kwargs) -> UserLoginStage:  # noqa: E501
        """stages_user_login_retrieve  # noqa: E501

        UserLoginStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Login Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserLoginStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_login_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_login_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_login_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Login Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_login_retrieve  # noqa: E501

        UserLoginStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Login Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserLoginStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_login_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserLoginStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_login/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_login_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Login Stage.")], user_login_stage_request : UserLoginStageRequest, **kwargs) -> UserLoginStage:  # noqa: E501
        """stages_user_login_update  # noqa: E501

        UserLoginStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_update(stage_uuid, user_login_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Login Stage. (required)
        :type stage_uuid: str
        :param user_login_stage_request: (required)
        :type user_login_stage_request: UserLoginStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserLoginStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_login_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_login_update_with_http_info(stage_uuid, user_login_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_login_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Login Stage.")], user_login_stage_request : UserLoginStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_login_update  # noqa: E501

        UserLoginStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_update_with_http_info(stage_uuid, user_login_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Login Stage. (required)
        :type stage_uuid: str
        :param user_login_stage_request: (required)
        :type user_login_stage_request: UserLoginStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserLoginStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'user_login_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_login_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['user_login_stage_request'] is not None:
            _body_params = _params['user_login_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserLoginStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_login/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_login_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Login Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_user_login_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Login Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_login_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_login_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_login_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Login Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_login_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_login_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Login Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_login_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_login/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_logout_create(self, user_logout_stage_request : UserLogoutStageRequest, **kwargs) -> UserLogoutStage:  # noqa: E501
        """stages_user_logout_create  # noqa: E501

        UserLogoutStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_create(user_logout_stage_request, async_req=True)
        >>> result = thread.get()

        :param user_logout_stage_request: (required)
        :type user_logout_stage_request: UserLogoutStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserLogoutStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_logout_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_logout_create_with_http_info(user_logout_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_logout_create_with_http_info(self, user_logout_stage_request : UserLogoutStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_logout_create  # noqa: E501

        UserLogoutStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_create_with_http_info(user_logout_stage_request, async_req=True)
        >>> result = thread.get()

        :param user_logout_stage_request: (required)
        :type user_logout_stage_request: UserLogoutStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserLogoutStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'user_logout_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_logout_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['user_logout_stage_request'] is not None:
            _body_params = _params['user_logout_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "UserLogoutStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_logout/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_logout_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Logout Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_user_logout_destroy  # noqa: E501

        UserLogoutStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Logout Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_logout_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_logout_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_logout_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Logout Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_logout_destroy  # noqa: E501

        UserLogoutStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Logout Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_logout_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/user_logout/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_logout_list(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, **kwargs) -> PaginatedUserLogoutStageList:  # noqa: E501
        """stages_user_logout_list  # noqa: E501

        UserLogoutStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_list(name, ordering, page, page_size, search, stage_uuid, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedUserLogoutStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_logout_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_logout_list_with_http_info(name, ordering, page, page_size, search, stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_logout_list_with_http_info(self, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_logout_list  # noqa: E501

        UserLogoutStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_list_with_http_info(name, ordering, page, page_size, search, stage_uuid, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedUserLogoutStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'name',
            'ordering',
            'page',
            'page_size',
            'search',
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_logout_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('stage_uuid') is not None:  # noqa: E501
            _query_params.append(('stage_uuid', _params['stage_uuid']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedUserLogoutStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_logout/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_logout_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Logout Stage.")], patched_user_logout_stage_request : Optional[PatchedUserLogoutStageRequest] = None, **kwargs) -> UserLogoutStage:  # noqa: E501
        """stages_user_logout_partial_update  # noqa: E501

        UserLogoutStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_partial_update(stage_uuid, patched_user_logout_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Logout Stage. (required)
        :type stage_uuid: str
        :param patched_user_logout_stage_request:
        :type patched_user_logout_stage_request: PatchedUserLogoutStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserLogoutStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_logout_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_logout_partial_update_with_http_info(stage_uuid, patched_user_logout_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_logout_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Logout Stage.")], patched_user_logout_stage_request : Optional[PatchedUserLogoutStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_logout_partial_update  # noqa: E501

        UserLogoutStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_partial_update_with_http_info(stage_uuid, patched_user_logout_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Logout Stage. (required)
        :type stage_uuid: str
        :param patched_user_logout_stage_request:
        :type patched_user_logout_stage_request: PatchedUserLogoutStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserLogoutStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_user_logout_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_logout_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_user_logout_stage_request'] is not None:
            _body_params = _params['patched_user_logout_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserLogoutStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_logout/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_logout_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Logout Stage.")], **kwargs) -> UserLogoutStage:  # noqa: E501
        """stages_user_logout_retrieve  # noqa: E501

        UserLogoutStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Logout Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserLogoutStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_logout_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_logout_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_logout_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Logout Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_logout_retrieve  # noqa: E501

        UserLogoutStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Logout Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserLogoutStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_logout_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserLogoutStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_logout/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_logout_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Logout Stage.")], user_logout_stage_request : UserLogoutStageRequest, **kwargs) -> UserLogoutStage:  # noqa: E501
        """stages_user_logout_update  # noqa: E501

        UserLogoutStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_update(stage_uuid, user_logout_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Logout Stage. (required)
        :type stage_uuid: str
        :param user_logout_stage_request: (required)
        :type user_logout_stage_request: UserLogoutStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserLogoutStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_logout_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_logout_update_with_http_info(stage_uuid, user_logout_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_logout_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Logout Stage.")], user_logout_stage_request : UserLogoutStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_logout_update  # noqa: E501

        UserLogoutStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_update_with_http_info(stage_uuid, user_logout_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Logout Stage. (required)
        :type stage_uuid: str
        :param user_logout_stage_request: (required)
        :type user_logout_stage_request: UserLogoutStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserLogoutStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'user_logout_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_logout_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['user_logout_stage_request'] is not None:
            _body_params = _params['user_logout_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserLogoutStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_logout/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_logout_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Logout Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_user_logout_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Logout Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_logout_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_logout_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_logout_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Logout Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_logout_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_logout_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Logout Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_logout_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_logout/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_write_create(self, user_write_stage_request : UserWriteStageRequest, **kwargs) -> UserWriteStage:  # noqa: E501
        """stages_user_write_create  # noqa: E501

        UserWriteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_create(user_write_stage_request, async_req=True)
        >>> result = thread.get()

        :param user_write_stage_request: (required)
        :type user_write_stage_request: UserWriteStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserWriteStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_write_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_write_create_with_http_info(user_write_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_write_create_with_http_info(self, user_write_stage_request : UserWriteStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_write_create  # noqa: E501

        UserWriteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_create_with_http_info(user_write_stage_request, async_req=True)
        >>> result = thread.get()

        :param user_write_stage_request: (required)
        :type user_write_stage_request: UserWriteStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserWriteStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'user_write_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_write_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['user_write_stage_request'] is not None:
            _body_params = _params['user_write_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "UserWriteStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_write/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_write_destroy(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Write Stage.")], **kwargs) -> None:  # noqa: E501
        """stages_user_write_destroy  # noqa: E501

        UserWriteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_destroy(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Write Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_write_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_write_destroy_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_write_destroy_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Write Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_write_destroy  # noqa: E501

        UserWriteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_destroy_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Write Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_write_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/stages/user_write/{stage_uuid}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_write_list(self, create_users_as_inactive : Optional[StrictBool] = None, create_users_group : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, user_creation_mode : Annotated[Optional[StrictStr], Field(description="* `never_create` - Never Create * `create_when_required` - Create When Required * `always_create` - Always Create")] = None, user_path_template : Optional[StrictStr] = None, **kwargs) -> PaginatedUserWriteStageList:  # noqa: E501
        """stages_user_write_list  # noqa: E501

        UserWriteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_list(create_users_as_inactive, create_users_group, name, ordering, page, page_size, search, stage_uuid, user_creation_mode, user_path_template, async_req=True)
        >>> result = thread.get()

        :param create_users_as_inactive:
        :type create_users_as_inactive: bool
        :param create_users_group:
        :type create_users_group: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param user_creation_mode: * `never_create` - Never Create * `create_when_required` - Create When Required * `always_create` - Always Create
        :type user_creation_mode: str
        :param user_path_template:
        :type user_path_template: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedUserWriteStageList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_write_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_write_list_with_http_info(create_users_as_inactive, create_users_group, name, ordering, page, page_size, search, stage_uuid, user_creation_mode, user_path_template, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_write_list_with_http_info(self, create_users_as_inactive : Optional[StrictBool] = None, create_users_group : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, stage_uuid : Optional[StrictStr] = None, user_creation_mode : Annotated[Optional[StrictStr], Field(description="* `never_create` - Never Create * `create_when_required` - Create When Required * `always_create` - Always Create")] = None, user_path_template : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_write_list  # noqa: E501

        UserWriteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_list_with_http_info(create_users_as_inactive, create_users_group, name, ordering, page, page_size, search, stage_uuid, user_creation_mode, user_path_template, async_req=True)
        >>> result = thread.get()

        :param create_users_as_inactive:
        :type create_users_as_inactive: bool
        :param create_users_group:
        :type create_users_group: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param stage_uuid:
        :type stage_uuid: str
        :param user_creation_mode: * `never_create` - Never Create * `create_when_required` - Create When Required * `always_create` - Always Create
        :type user_creation_mode: str
        :param user_path_template:
        :type user_path_template: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedUserWriteStageList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'create_users_as_inactive',
            'create_users_group',
            'name',
            'ordering',
            'page',
            'page_size',
            'search',
            'stage_uuid',
            'user_creation_mode',
            'user_path_template'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_write_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('create_users_as_inactive') is not None:  # noqa: E501
            _query_params.append(('create_users_as_inactive', _params['create_users_as_inactive']))

        if _params.get('create_users_group') is not None:  # noqa: E501
            _query_params.append(('create_users_group', _params['create_users_group']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('stage_uuid') is not None:  # noqa: E501
            _query_params.append(('stage_uuid', _params['stage_uuid']))

        if _params.get('user_creation_mode') is not None:  # noqa: E501
            _query_params.append(('user_creation_mode', _params['user_creation_mode']))

        if _params.get('user_path_template') is not None:  # noqa: E501
            _query_params.append(('user_path_template', _params['user_path_template']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedUserWriteStageList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_write/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_write_partial_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Write Stage.")], patched_user_write_stage_request : Optional[PatchedUserWriteStageRequest] = None, **kwargs) -> UserWriteStage:  # noqa: E501
        """stages_user_write_partial_update  # noqa: E501

        UserWriteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_partial_update(stage_uuid, patched_user_write_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Write Stage. (required)
        :type stage_uuid: str
        :param patched_user_write_stage_request:
        :type patched_user_write_stage_request: PatchedUserWriteStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserWriteStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_write_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_write_partial_update_with_http_info(stage_uuid, patched_user_write_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_write_partial_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Write Stage.")], patched_user_write_stage_request : Optional[PatchedUserWriteStageRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_write_partial_update  # noqa: E501

        UserWriteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_partial_update_with_http_info(stage_uuid, patched_user_write_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Write Stage. (required)
        :type stage_uuid: str
        :param patched_user_write_stage_request:
        :type patched_user_write_stage_request: PatchedUserWriteStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserWriteStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'patched_user_write_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_write_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_user_write_stage_request'] is not None:
            _body_params = _params['patched_user_write_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserWriteStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_write/{stage_uuid}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_write_retrieve(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Write Stage.")], **kwargs) -> UserWriteStage:  # noqa: E501
        """stages_user_write_retrieve  # noqa: E501

        UserWriteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_retrieve(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Write Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserWriteStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_write_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_write_retrieve_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_write_retrieve_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Write Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_write_retrieve  # noqa: E501

        UserWriteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_retrieve_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Write Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserWriteStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_write_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserWriteStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_write/{stage_uuid}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_write_update(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Write Stage.")], user_write_stage_request : UserWriteStageRequest, **kwargs) -> UserWriteStage:  # noqa: E501
        """stages_user_write_update  # noqa: E501

        UserWriteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_update(stage_uuid, user_write_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Write Stage. (required)
        :type stage_uuid: str
        :param user_write_stage_request: (required)
        :type user_write_stage_request: UserWriteStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserWriteStage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_write_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_write_update_with_http_info(stage_uuid, user_write_stage_request, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_write_update_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Write Stage.")], user_write_stage_request : UserWriteStageRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_write_update  # noqa: E501

        UserWriteStage Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_update_with_http_info(stage_uuid, user_write_stage_request, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Write Stage. (required)
        :type stage_uuid: str
        :param user_write_stage_request: (required)
        :type user_write_stage_request: UserWriteStageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserWriteStage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid',
            'user_write_stage_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_write_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['user_write_stage_request'] is not None:
            _body_params = _params['user_write_stage_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserWriteStage",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_write/{stage_uuid}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stages_user_write_used_by_list(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Write Stage.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """stages_user_write_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_used_by_list(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Write Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stages_user_write_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stages_user_write_used_by_list_with_http_info(stage_uuid, **kwargs)  # noqa: E501

    @validate_arguments
    def stages_user_write_used_by_list_with_http_info(self, stage_uuid : Annotated[StrictStr, Field(..., description="A UUID string identifying this User Write Stage.")], **kwargs) -> ApiResponse:  # noqa: E501
        """stages_user_write_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stages_user_write_used_by_list_with_http_info(stage_uuid, async_req=True)
        >>> result = thread.get()

        :param stage_uuid: A UUID string identifying this User Write Stage. (required)
        :type stage_uuid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'stage_uuid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stages_user_write_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['stage_uuid']:
            _path_params['stage_uuid'] = _params['stage_uuid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/stages/user_write/{stage_uuid}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
