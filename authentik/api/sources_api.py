# coding: utf-8

"""
    authentik

    Making authentication simple.

    The version of the OpenAPI document: 2023.6.1
    Contact: hello@goauthentik.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr, conlist

from typing import List, Optional, Union

from authentik.models.file_path_request import FilePathRequest
from authentik.models.ldap_debug import LDAPDebug
from authentik.models.ldap_source import LDAPSource
from authentik.models.ldap_source_request import LDAPSourceRequest
from authentik.models.o_auth_source import OAuthSource
from authentik.models.o_auth_source_request import OAuthSourceRequest
from authentik.models.paginated_ldap_source_list import PaginatedLDAPSourceList
from authentik.models.paginated_o_auth_source_list import PaginatedOAuthSourceList
from authentik.models.paginated_plex_source_connection_list import PaginatedPlexSourceConnectionList
from authentik.models.paginated_plex_source_list import PaginatedPlexSourceList
from authentik.models.paginated_saml_source_list import PaginatedSAMLSourceList
from authentik.models.paginated_source_list import PaginatedSourceList
from authentik.models.paginated_user_o_auth_source_connection_list import PaginatedUserOAuthSourceConnectionList
from authentik.models.paginated_user_saml_source_connection_list import PaginatedUserSAMLSourceConnectionList
from authentik.models.paginated_user_source_connection_list import PaginatedUserSourceConnectionList
from authentik.models.patched_ldap_source_request import PatchedLDAPSourceRequest
from authentik.models.patched_o_auth_source_request import PatchedOAuthSourceRequest
from authentik.models.patched_plex_source_connection_request import PatchedPlexSourceConnectionRequest
from authentik.models.patched_plex_source_request import PatchedPlexSourceRequest
from authentik.models.patched_saml_source_request import PatchedSAMLSourceRequest
from authentik.models.patched_user_o_auth_source_connection_request import PatchedUserOAuthSourceConnectionRequest
from authentik.models.patched_user_saml_source_connection_request import PatchedUserSAMLSourceConnectionRequest
from authentik.models.plex_source import PlexSource
from authentik.models.plex_source_connection import PlexSourceConnection
from authentik.models.plex_source_connection_request import PlexSourceConnectionRequest
from authentik.models.plex_source_request import PlexSourceRequest
from authentik.models.plex_token_redeem_request import PlexTokenRedeemRequest
from authentik.models.redirect_challenge import RedirectChallenge
from authentik.models.saml_metadata import SAMLMetadata
from authentik.models.saml_source import SAMLSource
from authentik.models.saml_source_request import SAMLSourceRequest
from authentik.models.source import Source
from authentik.models.source_type import SourceType
from authentik.models.task import Task
from authentik.models.type_create import TypeCreate
from authentik.models.used_by import UsedBy
from authentik.models.user_o_auth_source_connection import UserOAuthSourceConnection
from authentik.models.user_o_auth_source_connection_request import UserOAuthSourceConnectionRequest
from authentik.models.user_saml_source_connection import UserSAMLSourceConnection
from authentik.models.user_saml_source_connection_request import UserSAMLSourceConnectionRequest
from authentik.models.user_setting import UserSetting
from authentik.models.user_source_connection import UserSourceConnection

from authentik.api_client import ApiClient
from authentik.api_response import ApiResponse
from authentik.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class SourcesApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def sources_all_destroy(self, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """sources_all_destroy  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_destroy(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_all_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_all_destroy_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_all_destroy_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_all_destroy  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_destroy_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_all_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/sources/all/{slug}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_all_list(self, managed : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, slug : Optional[StrictStr] = None, **kwargs) -> PaginatedSourceList:  # noqa: E501
        """sources_all_list  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_list(managed, name, ordering, page, page_size, search, slug, async_req=True)
        >>> result = thread.get()

        :param managed:
        :type managed: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param slug:
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedSourceList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_all_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_all_list_with_http_info(managed, name, ordering, page, page_size, search, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_all_list_with_http_info(self, managed : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, slug : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_all_list  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_list_with_http_info(managed, name, ordering, page, page_size, search, slug, async_req=True)
        >>> result = thread.get()

        :param managed:
        :type managed: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param slug:
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedSourceList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'managed',
            'name',
            'ordering',
            'page',
            'page_size',
            'search',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_all_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('managed') is not None:  # noqa: E501
            _query_params.append(('managed', _params['managed']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('slug') is not None:  # noqa: E501
            _query_params.append(('slug', _params['slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedSourceList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/all/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_all_retrieve(self, slug : StrictStr, **kwargs) -> Source:  # noqa: E501
        """sources_all_retrieve  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_retrieve(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Source
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_all_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_all_retrieve_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_all_retrieve_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_all_retrieve  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_retrieve_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Source, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_all_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "Source",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/all/{slug}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_all_set_icon_create(self, slug : StrictStr, file : Optional[Union[StrictBytes, StrictStr]] = None, clear : Optional[StrictBool] = None, **kwargs) -> None:  # noqa: E501
        """sources_all_set_icon_create  # noqa: E501

        Set source icon  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_set_icon_create(slug, file, clear, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param file:
        :type file: bytearray
        :param clear:
        :type clear: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_all_set_icon_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_all_set_icon_create_with_http_info(slug, file, clear, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_all_set_icon_create_with_http_info(self, slug : StrictStr, file : Optional[Union[StrictBytes, StrictStr]] = None, clear : Optional[StrictBool] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_all_set_icon_create  # noqa: E501

        Set source icon  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_set_icon_create_with_http_info(slug, file, clear, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param file:
        :type file: bytearray
        :param clear:
        :type clear: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'slug',
            'file',
            'clear'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_all_set_icon_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        if _params['file']:
            _files['file'] = _params['file']

        if _params['clear']:
            _form_params.append(('clear', _params['clear']))

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/sources/all/{slug}/set_icon/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_all_set_icon_url_create(self, slug : StrictStr, file_path_request : FilePathRequest, **kwargs) -> None:  # noqa: E501
        """sources_all_set_icon_url_create  # noqa: E501

        Set source icon (as URL)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_set_icon_url_create(slug, file_path_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param file_path_request: (required)
        :type file_path_request: FilePathRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_all_set_icon_url_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_all_set_icon_url_create_with_http_info(slug, file_path_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_all_set_icon_url_create_with_http_info(self, slug : StrictStr, file_path_request : FilePathRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_all_set_icon_url_create  # noqa: E501

        Set source icon (as URL)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_set_icon_url_create_with_http_info(slug, file_path_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param file_path_request: (required)
        :type file_path_request: FilePathRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'slug',
            'file_path_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_all_set_icon_url_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['file_path_request'] is not None:
            _body_params = _params['file_path_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/sources/all/{slug}/set_icon_url/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_all_types_list(self, **kwargs) -> List[TypeCreate]:  # noqa: E501
        """sources_all_types_list  # noqa: E501

        Get all creatable source types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_types_list(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[TypeCreate]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_all_types_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_all_types_list_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def sources_all_types_list_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_all_types_list  # noqa: E501

        Get all creatable source types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_types_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[TypeCreate], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_all_types_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[TypeCreate]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/all/types/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_all_used_by_list(self, slug : StrictStr, **kwargs) -> List[UsedBy]:  # noqa: E501
        """sources_all_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_used_by_list(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_all_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_all_used_by_list_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_all_used_by_list_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_all_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_used_by_list_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_all_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/all/{slug}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_all_user_settings_list(self, **kwargs) -> List[UserSetting]:  # noqa: E501
        """sources_all_user_settings_list  # noqa: E501

        Get all sources the user can configure  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_user_settings_list(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UserSetting]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_all_user_settings_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_all_user_settings_list_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def sources_all_user_settings_list_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_all_user_settings_list  # noqa: E501

        Get all sources the user can configure  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_all_user_settings_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UserSetting], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_all_user_settings_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UserSetting]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/all/user_settings/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_ldap_create(self, ldap_source_request : LDAPSourceRequest, **kwargs) -> LDAPSource:  # noqa: E501
        """sources_ldap_create  # noqa: E501

        LDAP Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_create(ldap_source_request, async_req=True)
        >>> result = thread.get()

        :param ldap_source_request: (required)
        :type ldap_source_request: LDAPSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LDAPSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_ldap_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_ldap_create_with_http_info(ldap_source_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_ldap_create_with_http_info(self, ldap_source_request : LDAPSourceRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_ldap_create  # noqa: E501

        LDAP Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_create_with_http_info(ldap_source_request, async_req=True)
        >>> result = thread.get()

        :param ldap_source_request: (required)
        :type ldap_source_request: LDAPSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LDAPSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ldap_source_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_ldap_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['ldap_source_request'] is not None:
            _body_params = _params['ldap_source_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "LDAPSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/ldap/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_ldap_debug_retrieve(self, slug : StrictStr, **kwargs) -> LDAPDebug:  # noqa: E501
        """sources_ldap_debug_retrieve  # noqa: E501

        Get raw LDAP data to debug  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_debug_retrieve(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LDAPDebug
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_ldap_debug_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_ldap_debug_retrieve_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_ldap_debug_retrieve_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_ldap_debug_retrieve  # noqa: E501

        Get raw LDAP data to debug  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_debug_retrieve_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LDAPDebug, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_ldap_debug_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "LDAPDebug",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/ldap/{slug}/debug/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_ldap_destroy(self, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """sources_ldap_destroy  # noqa: E501

        LDAP Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_destroy(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_ldap_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_ldap_destroy_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_ldap_destroy_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_ldap_destroy  # noqa: E501

        LDAP Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_destroy_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_ldap_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/sources/ldap/{slug}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_ldap_list(self, additional_group_dn : Optional[StrictStr] = None, additional_user_dn : Optional[StrictStr] = None, base_dn : Optional[StrictStr] = None, bind_cn : Optional[StrictStr] = None, client_certificate : Optional[StrictStr] = None, enabled : Optional[StrictBool] = None, group_membership_field : Optional[StrictStr] = None, group_object_filter : Optional[StrictStr] = None, name : Optional[StrictStr] = None, object_uniqueness_field : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, peer_certificate : Optional[StrictStr] = None, property_mappings : Optional[conlist(StrictStr)] = None, property_mappings_group : Optional[conlist(StrictStr)] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, server_uri : Optional[StrictStr] = None, slug : Optional[StrictStr] = None, sni : Optional[StrictBool] = None, start_tls : Optional[StrictBool] = None, sync_groups : Optional[StrictBool] = None, sync_parent_group : Optional[StrictStr] = None, sync_users : Optional[StrictBool] = None, sync_users_password : Optional[StrictBool] = None, user_object_filter : Optional[StrictStr] = None, **kwargs) -> PaginatedLDAPSourceList:  # noqa: E501
        """sources_ldap_list  # noqa: E501

        LDAP Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_list(additional_group_dn, additional_user_dn, base_dn, bind_cn, client_certificate, enabled, group_membership_field, group_object_filter, name, object_uniqueness_field, ordering, page, page_size, peer_certificate, property_mappings, property_mappings_group, search, server_uri, slug, sni, start_tls, sync_groups, sync_parent_group, sync_users, sync_users_password, user_object_filter, async_req=True)
        >>> result = thread.get()

        :param additional_group_dn:
        :type additional_group_dn: str
        :param additional_user_dn:
        :type additional_user_dn: str
        :param base_dn:
        :type base_dn: str
        :param bind_cn:
        :type bind_cn: str
        :param client_certificate:
        :type client_certificate: str
        :param enabled:
        :type enabled: bool
        :param group_membership_field:
        :type group_membership_field: str
        :param group_object_filter:
        :type group_object_filter: str
        :param name:
        :type name: str
        :param object_uniqueness_field:
        :type object_uniqueness_field: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param peer_certificate:
        :type peer_certificate: str
        :param property_mappings:
        :type property_mappings: List[str]
        :param property_mappings_group:
        :type property_mappings_group: List[str]
        :param search: A search term.
        :type search: str
        :param server_uri:
        :type server_uri: str
        :param slug:
        :type slug: str
        :param sni:
        :type sni: bool
        :param start_tls:
        :type start_tls: bool
        :param sync_groups:
        :type sync_groups: bool
        :param sync_parent_group:
        :type sync_parent_group: str
        :param sync_users:
        :type sync_users: bool
        :param sync_users_password:
        :type sync_users_password: bool
        :param user_object_filter:
        :type user_object_filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedLDAPSourceList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_ldap_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_ldap_list_with_http_info(additional_group_dn, additional_user_dn, base_dn, bind_cn, client_certificate, enabled, group_membership_field, group_object_filter, name, object_uniqueness_field, ordering, page, page_size, peer_certificate, property_mappings, property_mappings_group, search, server_uri, slug, sni, start_tls, sync_groups, sync_parent_group, sync_users, sync_users_password, user_object_filter, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_ldap_list_with_http_info(self, additional_group_dn : Optional[StrictStr] = None, additional_user_dn : Optional[StrictStr] = None, base_dn : Optional[StrictStr] = None, bind_cn : Optional[StrictStr] = None, client_certificate : Optional[StrictStr] = None, enabled : Optional[StrictBool] = None, group_membership_field : Optional[StrictStr] = None, group_object_filter : Optional[StrictStr] = None, name : Optional[StrictStr] = None, object_uniqueness_field : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, peer_certificate : Optional[StrictStr] = None, property_mappings : Optional[conlist(StrictStr)] = None, property_mappings_group : Optional[conlist(StrictStr)] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, server_uri : Optional[StrictStr] = None, slug : Optional[StrictStr] = None, sni : Optional[StrictBool] = None, start_tls : Optional[StrictBool] = None, sync_groups : Optional[StrictBool] = None, sync_parent_group : Optional[StrictStr] = None, sync_users : Optional[StrictBool] = None, sync_users_password : Optional[StrictBool] = None, user_object_filter : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_ldap_list  # noqa: E501

        LDAP Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_list_with_http_info(additional_group_dn, additional_user_dn, base_dn, bind_cn, client_certificate, enabled, group_membership_field, group_object_filter, name, object_uniqueness_field, ordering, page, page_size, peer_certificate, property_mappings, property_mappings_group, search, server_uri, slug, sni, start_tls, sync_groups, sync_parent_group, sync_users, sync_users_password, user_object_filter, async_req=True)
        >>> result = thread.get()

        :param additional_group_dn:
        :type additional_group_dn: str
        :param additional_user_dn:
        :type additional_user_dn: str
        :param base_dn:
        :type base_dn: str
        :param bind_cn:
        :type bind_cn: str
        :param client_certificate:
        :type client_certificate: str
        :param enabled:
        :type enabled: bool
        :param group_membership_field:
        :type group_membership_field: str
        :param group_object_filter:
        :type group_object_filter: str
        :param name:
        :type name: str
        :param object_uniqueness_field:
        :type object_uniqueness_field: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param peer_certificate:
        :type peer_certificate: str
        :param property_mappings:
        :type property_mappings: List[str]
        :param property_mappings_group:
        :type property_mappings_group: List[str]
        :param search: A search term.
        :type search: str
        :param server_uri:
        :type server_uri: str
        :param slug:
        :type slug: str
        :param sni:
        :type sni: bool
        :param start_tls:
        :type start_tls: bool
        :param sync_groups:
        :type sync_groups: bool
        :param sync_parent_group:
        :type sync_parent_group: str
        :param sync_users:
        :type sync_users: bool
        :param sync_users_password:
        :type sync_users_password: bool
        :param user_object_filter:
        :type user_object_filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedLDAPSourceList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'additional_group_dn',
            'additional_user_dn',
            'base_dn',
            'bind_cn',
            'client_certificate',
            'enabled',
            'group_membership_field',
            'group_object_filter',
            'name',
            'object_uniqueness_field',
            'ordering',
            'page',
            'page_size',
            'peer_certificate',
            'property_mappings',
            'property_mappings_group',
            'search',
            'server_uri',
            'slug',
            'sni',
            'start_tls',
            'sync_groups',
            'sync_parent_group',
            'sync_users',
            'sync_users_password',
            'user_object_filter'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_ldap_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('additional_group_dn') is not None:  # noqa: E501
            _query_params.append(('additional_group_dn', _params['additional_group_dn']))

        if _params.get('additional_user_dn') is not None:  # noqa: E501
            _query_params.append(('additional_user_dn', _params['additional_user_dn']))

        if _params.get('base_dn') is not None:  # noqa: E501
            _query_params.append(('base_dn', _params['base_dn']))

        if _params.get('bind_cn') is not None:  # noqa: E501
            _query_params.append(('bind_cn', _params['bind_cn']))

        if _params.get('client_certificate') is not None:  # noqa: E501
            _query_params.append(('client_certificate', _params['client_certificate']))

        if _params.get('enabled') is not None:  # noqa: E501
            _query_params.append(('enabled', _params['enabled']))

        if _params.get('group_membership_field') is not None:  # noqa: E501
            _query_params.append(('group_membership_field', _params['group_membership_field']))

        if _params.get('group_object_filter') is not None:  # noqa: E501
            _query_params.append(('group_object_filter', _params['group_object_filter']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('object_uniqueness_field') is not None:  # noqa: E501
            _query_params.append(('object_uniqueness_field', _params['object_uniqueness_field']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('peer_certificate') is not None:  # noqa: E501
            _query_params.append(('peer_certificate', _params['peer_certificate']))

        if _params.get('property_mappings') is not None:  # noqa: E501
            _query_params.append(('property_mappings', _params['property_mappings']))
            _collection_formats['property_mappings'] = 'multi'

        if _params.get('property_mappings_group') is not None:  # noqa: E501
            _query_params.append(('property_mappings_group', _params['property_mappings_group']))
            _collection_formats['property_mappings_group'] = 'multi'

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('server_uri') is not None:  # noqa: E501
            _query_params.append(('server_uri', _params['server_uri']))

        if _params.get('slug') is not None:  # noqa: E501
            _query_params.append(('slug', _params['slug']))

        if _params.get('sni') is not None:  # noqa: E501
            _query_params.append(('sni', _params['sni']))

        if _params.get('start_tls') is not None:  # noqa: E501
            _query_params.append(('start_tls', _params['start_tls']))

        if _params.get('sync_groups') is not None:  # noqa: E501
            _query_params.append(('sync_groups', _params['sync_groups']))

        if _params.get('sync_parent_group') is not None:  # noqa: E501
            _query_params.append(('sync_parent_group', _params['sync_parent_group']))

        if _params.get('sync_users') is not None:  # noqa: E501
            _query_params.append(('sync_users', _params['sync_users']))

        if _params.get('sync_users_password') is not None:  # noqa: E501
            _query_params.append(('sync_users_password', _params['sync_users_password']))

        if _params.get('user_object_filter') is not None:  # noqa: E501
            _query_params.append(('user_object_filter', _params['user_object_filter']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedLDAPSourceList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/ldap/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_ldap_partial_update(self, slug : StrictStr, patched_ldap_source_request : Optional[PatchedLDAPSourceRequest] = None, **kwargs) -> LDAPSource:  # noqa: E501
        """sources_ldap_partial_update  # noqa: E501

        LDAP Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_partial_update(slug, patched_ldap_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param patched_ldap_source_request:
        :type patched_ldap_source_request: PatchedLDAPSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LDAPSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_ldap_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_ldap_partial_update_with_http_info(slug, patched_ldap_source_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_ldap_partial_update_with_http_info(self, slug : StrictStr, patched_ldap_source_request : Optional[PatchedLDAPSourceRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_ldap_partial_update  # noqa: E501

        LDAP Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_partial_update_with_http_info(slug, patched_ldap_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param patched_ldap_source_request:
        :type patched_ldap_source_request: PatchedLDAPSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LDAPSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'patched_ldap_source_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_ldap_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_ldap_source_request'] is not None:
            _body_params = _params['patched_ldap_source_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "LDAPSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/ldap/{slug}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_ldap_retrieve(self, slug : StrictStr, **kwargs) -> LDAPSource:  # noqa: E501
        """sources_ldap_retrieve  # noqa: E501

        LDAP Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_retrieve(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LDAPSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_ldap_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_ldap_retrieve_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_ldap_retrieve_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_ldap_retrieve  # noqa: E501

        LDAP Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_retrieve_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LDAPSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_ldap_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "LDAPSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/ldap/{slug}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_ldap_sync_status_list(self, slug : StrictStr, **kwargs) -> List[Task]:  # noqa: E501
        """sources_ldap_sync_status_list  # noqa: E501

        Get source's sync status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_sync_status_list(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Task]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_ldap_sync_status_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_ldap_sync_status_list_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_ldap_sync_status_list_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_ldap_sync_status_list  # noqa: E501

        Get source's sync status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_sync_status_list_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Task], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_ldap_sync_status_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[Task]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/ldap/{slug}/sync_status/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_ldap_update(self, slug : StrictStr, ldap_source_request : LDAPSourceRequest, **kwargs) -> LDAPSource:  # noqa: E501
        """sources_ldap_update  # noqa: E501

        LDAP Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_update(slug, ldap_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param ldap_source_request: (required)
        :type ldap_source_request: LDAPSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LDAPSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_ldap_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_ldap_update_with_http_info(slug, ldap_source_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_ldap_update_with_http_info(self, slug : StrictStr, ldap_source_request : LDAPSourceRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_ldap_update  # noqa: E501

        LDAP Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_update_with_http_info(slug, ldap_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param ldap_source_request: (required)
        :type ldap_source_request: LDAPSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LDAPSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'ldap_source_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_ldap_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['ldap_source_request'] is not None:
            _body_params = _params['ldap_source_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "LDAPSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/ldap/{slug}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_ldap_used_by_list(self, slug : StrictStr, **kwargs) -> List[UsedBy]:  # noqa: E501
        """sources_ldap_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_used_by_list(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_ldap_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_ldap_used_by_list_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_ldap_used_by_list_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_ldap_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_ldap_used_by_list_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_ldap_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/ldap/{slug}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_oauth_create(self, o_auth_source_request : OAuthSourceRequest, **kwargs) -> OAuthSource:  # noqa: E501
        """sources_oauth_create  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_create(o_auth_source_request, async_req=True)
        >>> result = thread.get()

        :param o_auth_source_request: (required)
        :type o_auth_source_request: OAuthSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OAuthSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_oauth_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_oauth_create_with_http_info(o_auth_source_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_oauth_create_with_http_info(self, o_auth_source_request : OAuthSourceRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_oauth_create  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_create_with_http_info(o_auth_source_request, async_req=True)
        >>> result = thread.get()

        :param o_auth_source_request: (required)
        :type o_auth_source_request: OAuthSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OAuthSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'o_auth_source_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_oauth_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['o_auth_source_request'] is not None:
            _body_params = _params['o_auth_source_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "OAuthSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/oauth/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_oauth_destroy(self, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """sources_oauth_destroy  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_destroy(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_oauth_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_oauth_destroy_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_oauth_destroy_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_oauth_destroy  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_destroy_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_oauth_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/sources/oauth/{slug}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_oauth_list(self, access_token_url : Optional[StrictStr] = None, additional_scopes : Optional[StrictStr] = None, authentication_flow : Optional[StrictStr] = None, authorization_url : Optional[StrictStr] = None, consumer_key : Optional[StrictStr] = None, enabled : Optional[StrictBool] = None, enrollment_flow : Optional[StrictStr] = None, has_jwks : Annotated[Optional[StrictBool], Field(description="Only return sources with JWKS data")] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, policy_engine_mode : Annotated[Optional[StrictStr], Field(description="* `all` - all, all policies must pass * `any` - any, any policy must pass")] = None, profile_url : Optional[StrictStr] = None, provider_type : Optional[StrictStr] = None, request_token_url : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, slug : Optional[StrictStr] = None, user_matching_mode : Annotated[Optional[StrictStr], Field(description="How the source determines if an existing user should be authenticated or a new user enrolled.  * `identifier` - Use the source-specific identifier * `email_link` - Link to a user with identical email address. Can have security implications when a source doesn't validate email addresses. * `email_deny` - Use the user's email address, but deny enrollment when the email address already exists. * `username_link` - Link to a user with identical username. Can have security implications when a username is used with another source. * `username_deny` - Use the user's username, but deny enrollment when the username already exists.")] = None, **kwargs) -> PaginatedOAuthSourceList:  # noqa: E501
        """sources_oauth_list  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_list(access_token_url, additional_scopes, authentication_flow, authorization_url, consumer_key, enabled, enrollment_flow, has_jwks, name, ordering, page, page_size, policy_engine_mode, profile_url, provider_type, request_token_url, search, slug, user_matching_mode, async_req=True)
        >>> result = thread.get()

        :param access_token_url:
        :type access_token_url: str
        :param additional_scopes:
        :type additional_scopes: str
        :param authentication_flow:
        :type authentication_flow: str
        :param authorization_url:
        :type authorization_url: str
        :param consumer_key:
        :type consumer_key: str
        :param enabled:
        :type enabled: bool
        :param enrollment_flow:
        :type enrollment_flow: str
        :param has_jwks: Only return sources with JWKS data
        :type has_jwks: bool
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param policy_engine_mode: * `all` - all, all policies must pass * `any` - any, any policy must pass
        :type policy_engine_mode: str
        :param profile_url:
        :type profile_url: str
        :param provider_type:
        :type provider_type: str
        :param request_token_url:
        :type request_token_url: str
        :param search: A search term.
        :type search: str
        :param slug:
        :type slug: str
        :param user_matching_mode: How the source determines if an existing user should be authenticated or a new user enrolled.  * `identifier` - Use the source-specific identifier * `email_link` - Link to a user with identical email address. Can have security implications when a source doesn't validate email addresses. * `email_deny` - Use the user's email address, but deny enrollment when the email address already exists. * `username_link` - Link to a user with identical username. Can have security implications when a username is used with another source. * `username_deny` - Use the user's username, but deny enrollment when the username already exists.
        :type user_matching_mode: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedOAuthSourceList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_oauth_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_oauth_list_with_http_info(access_token_url, additional_scopes, authentication_flow, authorization_url, consumer_key, enabled, enrollment_flow, has_jwks, name, ordering, page, page_size, policy_engine_mode, profile_url, provider_type, request_token_url, search, slug, user_matching_mode, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_oauth_list_with_http_info(self, access_token_url : Optional[StrictStr] = None, additional_scopes : Optional[StrictStr] = None, authentication_flow : Optional[StrictStr] = None, authorization_url : Optional[StrictStr] = None, consumer_key : Optional[StrictStr] = None, enabled : Optional[StrictBool] = None, enrollment_flow : Optional[StrictStr] = None, has_jwks : Annotated[Optional[StrictBool], Field(description="Only return sources with JWKS data")] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, policy_engine_mode : Annotated[Optional[StrictStr], Field(description="* `all` - all, all policies must pass * `any` - any, any policy must pass")] = None, profile_url : Optional[StrictStr] = None, provider_type : Optional[StrictStr] = None, request_token_url : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, slug : Optional[StrictStr] = None, user_matching_mode : Annotated[Optional[StrictStr], Field(description="How the source determines if an existing user should be authenticated or a new user enrolled.  * `identifier` - Use the source-specific identifier * `email_link` - Link to a user with identical email address. Can have security implications when a source doesn't validate email addresses. * `email_deny` - Use the user's email address, but deny enrollment when the email address already exists. * `username_link` - Link to a user with identical username. Can have security implications when a username is used with another source. * `username_deny` - Use the user's username, but deny enrollment when the username already exists.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_oauth_list  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_list_with_http_info(access_token_url, additional_scopes, authentication_flow, authorization_url, consumer_key, enabled, enrollment_flow, has_jwks, name, ordering, page, page_size, policy_engine_mode, profile_url, provider_type, request_token_url, search, slug, user_matching_mode, async_req=True)
        >>> result = thread.get()

        :param access_token_url:
        :type access_token_url: str
        :param additional_scopes:
        :type additional_scopes: str
        :param authentication_flow:
        :type authentication_flow: str
        :param authorization_url:
        :type authorization_url: str
        :param consumer_key:
        :type consumer_key: str
        :param enabled:
        :type enabled: bool
        :param enrollment_flow:
        :type enrollment_flow: str
        :param has_jwks: Only return sources with JWKS data
        :type has_jwks: bool
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param policy_engine_mode: * `all` - all, all policies must pass * `any` - any, any policy must pass
        :type policy_engine_mode: str
        :param profile_url:
        :type profile_url: str
        :param provider_type:
        :type provider_type: str
        :param request_token_url:
        :type request_token_url: str
        :param search: A search term.
        :type search: str
        :param slug:
        :type slug: str
        :param user_matching_mode: How the source determines if an existing user should be authenticated or a new user enrolled.  * `identifier` - Use the source-specific identifier * `email_link` - Link to a user with identical email address. Can have security implications when a source doesn't validate email addresses. * `email_deny` - Use the user's email address, but deny enrollment when the email address already exists. * `username_link` - Link to a user with identical username. Can have security implications when a username is used with another source. * `username_deny` - Use the user's username, but deny enrollment when the username already exists.
        :type user_matching_mode: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedOAuthSourceList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'access_token_url',
            'additional_scopes',
            'authentication_flow',
            'authorization_url',
            'consumer_key',
            'enabled',
            'enrollment_flow',
            'has_jwks',
            'name',
            'ordering',
            'page',
            'page_size',
            'policy_engine_mode',
            'profile_url',
            'provider_type',
            'request_token_url',
            'search',
            'slug',
            'user_matching_mode'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_oauth_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('access_token_url') is not None:  # noqa: E501
            _query_params.append(('access_token_url', _params['access_token_url']))

        if _params.get('additional_scopes') is not None:  # noqa: E501
            _query_params.append(('additional_scopes', _params['additional_scopes']))

        if _params.get('authentication_flow') is not None:  # noqa: E501
            _query_params.append(('authentication_flow', _params['authentication_flow']))

        if _params.get('authorization_url') is not None:  # noqa: E501
            _query_params.append(('authorization_url', _params['authorization_url']))

        if _params.get('consumer_key') is not None:  # noqa: E501
            _query_params.append(('consumer_key', _params['consumer_key']))

        if _params.get('enabled') is not None:  # noqa: E501
            _query_params.append(('enabled', _params['enabled']))

        if _params.get('enrollment_flow') is not None:  # noqa: E501
            _query_params.append(('enrollment_flow', _params['enrollment_flow']))

        if _params.get('has_jwks') is not None:  # noqa: E501
            _query_params.append(('has_jwks', _params['has_jwks']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('policy_engine_mode') is not None:  # noqa: E501
            _query_params.append(('policy_engine_mode', _params['policy_engine_mode']))

        if _params.get('profile_url') is not None:  # noqa: E501
            _query_params.append(('profile_url', _params['profile_url']))

        if _params.get('provider_type') is not None:  # noqa: E501
            _query_params.append(('provider_type', _params['provider_type']))

        if _params.get('request_token_url') is not None:  # noqa: E501
            _query_params.append(('request_token_url', _params['request_token_url']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('slug') is not None:  # noqa: E501
            _query_params.append(('slug', _params['slug']))

        if _params.get('user_matching_mode') is not None:  # noqa: E501
            _query_params.append(('user_matching_mode', _params['user_matching_mode']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedOAuthSourceList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/oauth/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_oauth_partial_update(self, slug : StrictStr, patched_o_auth_source_request : Optional[PatchedOAuthSourceRequest] = None, **kwargs) -> OAuthSource:  # noqa: E501
        """sources_oauth_partial_update  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_partial_update(slug, patched_o_auth_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param patched_o_auth_source_request:
        :type patched_o_auth_source_request: PatchedOAuthSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OAuthSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_oauth_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_oauth_partial_update_with_http_info(slug, patched_o_auth_source_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_oauth_partial_update_with_http_info(self, slug : StrictStr, patched_o_auth_source_request : Optional[PatchedOAuthSourceRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_oauth_partial_update  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_partial_update_with_http_info(slug, patched_o_auth_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param patched_o_auth_source_request:
        :type patched_o_auth_source_request: PatchedOAuthSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OAuthSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'patched_o_auth_source_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_oauth_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_o_auth_source_request'] is not None:
            _body_params = _params['patched_o_auth_source_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "OAuthSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/oauth/{slug}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_oauth_retrieve(self, slug : StrictStr, **kwargs) -> OAuthSource:  # noqa: E501
        """sources_oauth_retrieve  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_retrieve(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OAuthSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_oauth_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_oauth_retrieve_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_oauth_retrieve_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_oauth_retrieve  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_retrieve_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OAuthSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_oauth_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "OAuthSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/oauth/{slug}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_oauth_source_types_list(self, name : Optional[StrictStr] = None, **kwargs) -> List[SourceType]:  # noqa: E501
        """sources_oauth_source_types_list  # noqa: E501

        Get all creatable source types. If ?name is set, only returns the type for <name>. If <name> isn't found, returns the default type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_source_types_list(name, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[SourceType]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_oauth_source_types_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_oauth_source_types_list_with_http_info(name, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_oauth_source_types_list_with_http_info(self, name : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_oauth_source_types_list  # noqa: E501

        Get all creatable source types. If ?name is set, only returns the type for <name>. If <name> isn't found, returns the default type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_source_types_list_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param name:
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[SourceType], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_oauth_source_types_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[SourceType]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/oauth/source_types/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_oauth_update(self, slug : StrictStr, o_auth_source_request : OAuthSourceRequest, **kwargs) -> OAuthSource:  # noqa: E501
        """sources_oauth_update  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_update(slug, o_auth_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param o_auth_source_request: (required)
        :type o_auth_source_request: OAuthSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OAuthSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_oauth_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_oauth_update_with_http_info(slug, o_auth_source_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_oauth_update_with_http_info(self, slug : StrictStr, o_auth_source_request : OAuthSourceRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_oauth_update  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_update_with_http_info(slug, o_auth_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param o_auth_source_request: (required)
        :type o_auth_source_request: OAuthSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OAuthSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'o_auth_source_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_oauth_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['o_auth_source_request'] is not None:
            _body_params = _params['o_auth_source_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "OAuthSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/oauth/{slug}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_oauth_used_by_list(self, slug : StrictStr, **kwargs) -> List[UsedBy]:  # noqa: E501
        """sources_oauth_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_used_by_list(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_oauth_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_oauth_used_by_list_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_oauth_used_by_list_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_oauth_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_oauth_used_by_list_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_oauth_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/oauth/{slug}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_plex_create(self, plex_source_request : PlexSourceRequest, **kwargs) -> PlexSource:  # noqa: E501
        """sources_plex_create  # noqa: E501

        Plex source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_create(plex_source_request, async_req=True)
        >>> result = thread.get()

        :param plex_source_request: (required)
        :type plex_source_request: PlexSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PlexSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_plex_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_plex_create_with_http_info(plex_source_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_plex_create_with_http_info(self, plex_source_request : PlexSourceRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_plex_create  # noqa: E501

        Plex source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_create_with_http_info(plex_source_request, async_req=True)
        >>> result = thread.get()

        :param plex_source_request: (required)
        :type plex_source_request: PlexSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PlexSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'plex_source_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_plex_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['plex_source_request'] is not None:
            _body_params = _params['plex_source_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "PlexSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/plex/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_plex_destroy(self, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """sources_plex_destroy  # noqa: E501

        Plex source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_destroy(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_plex_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_plex_destroy_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_plex_destroy_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_plex_destroy  # noqa: E501

        Plex source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_destroy_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_plex_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/sources/plex/{slug}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_plex_list(self, allow_friends : Optional[StrictBool] = None, authentication_flow : Optional[StrictStr] = None, client_id : Optional[StrictStr] = None, enabled : Optional[StrictBool] = None, enrollment_flow : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, policy_engine_mode : Annotated[Optional[StrictStr], Field(description="* `all` - all, all policies must pass * `any` - any, any policy must pass")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, slug : Optional[StrictStr] = None, user_matching_mode : Annotated[Optional[StrictStr], Field(description="How the source determines if an existing user should be authenticated or a new user enrolled.  * `identifier` - Use the source-specific identifier * `email_link` - Link to a user with identical email address. Can have security implications when a source doesn't validate email addresses. * `email_deny` - Use the user's email address, but deny enrollment when the email address already exists. * `username_link` - Link to a user with identical username. Can have security implications when a username is used with another source. * `username_deny` - Use the user's username, but deny enrollment when the username already exists.")] = None, **kwargs) -> PaginatedPlexSourceList:  # noqa: E501
        """sources_plex_list  # noqa: E501

        Plex source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_list(allow_friends, authentication_flow, client_id, enabled, enrollment_flow, name, ordering, page, page_size, policy_engine_mode, search, slug, user_matching_mode, async_req=True)
        >>> result = thread.get()

        :param allow_friends:
        :type allow_friends: bool
        :param authentication_flow:
        :type authentication_flow: str
        :param client_id:
        :type client_id: str
        :param enabled:
        :type enabled: bool
        :param enrollment_flow:
        :type enrollment_flow: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param policy_engine_mode: * `all` - all, all policies must pass * `any` - any, any policy must pass
        :type policy_engine_mode: str
        :param search: A search term.
        :type search: str
        :param slug:
        :type slug: str
        :param user_matching_mode: How the source determines if an existing user should be authenticated or a new user enrolled.  * `identifier` - Use the source-specific identifier * `email_link` - Link to a user with identical email address. Can have security implications when a source doesn't validate email addresses. * `email_deny` - Use the user's email address, but deny enrollment when the email address already exists. * `username_link` - Link to a user with identical username. Can have security implications when a username is used with another source. * `username_deny` - Use the user's username, but deny enrollment when the username already exists.
        :type user_matching_mode: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedPlexSourceList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_plex_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_plex_list_with_http_info(allow_friends, authentication_flow, client_id, enabled, enrollment_flow, name, ordering, page, page_size, policy_engine_mode, search, slug, user_matching_mode, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_plex_list_with_http_info(self, allow_friends : Optional[StrictBool] = None, authentication_flow : Optional[StrictStr] = None, client_id : Optional[StrictStr] = None, enabled : Optional[StrictBool] = None, enrollment_flow : Optional[StrictStr] = None, name : Optional[StrictStr] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, policy_engine_mode : Annotated[Optional[StrictStr], Field(description="* `all` - all, all policies must pass * `any` - any, any policy must pass")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, slug : Optional[StrictStr] = None, user_matching_mode : Annotated[Optional[StrictStr], Field(description="How the source determines if an existing user should be authenticated or a new user enrolled.  * `identifier` - Use the source-specific identifier * `email_link` - Link to a user with identical email address. Can have security implications when a source doesn't validate email addresses. * `email_deny` - Use the user's email address, but deny enrollment when the email address already exists. * `username_link` - Link to a user with identical username. Can have security implications when a username is used with another source. * `username_deny` - Use the user's username, but deny enrollment when the username already exists.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_plex_list  # noqa: E501

        Plex source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_list_with_http_info(allow_friends, authentication_flow, client_id, enabled, enrollment_flow, name, ordering, page, page_size, policy_engine_mode, search, slug, user_matching_mode, async_req=True)
        >>> result = thread.get()

        :param allow_friends:
        :type allow_friends: bool
        :param authentication_flow:
        :type authentication_flow: str
        :param client_id:
        :type client_id: str
        :param enabled:
        :type enabled: bool
        :param enrollment_flow:
        :type enrollment_flow: str
        :param name:
        :type name: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param policy_engine_mode: * `all` - all, all policies must pass * `any` - any, any policy must pass
        :type policy_engine_mode: str
        :param search: A search term.
        :type search: str
        :param slug:
        :type slug: str
        :param user_matching_mode: How the source determines if an existing user should be authenticated or a new user enrolled.  * `identifier` - Use the source-specific identifier * `email_link` - Link to a user with identical email address. Can have security implications when a source doesn't validate email addresses. * `email_deny` - Use the user's email address, but deny enrollment when the email address already exists. * `username_link` - Link to a user with identical username. Can have security implications when a username is used with another source. * `username_deny` - Use the user's username, but deny enrollment when the username already exists.
        :type user_matching_mode: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedPlexSourceList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'allow_friends',
            'authentication_flow',
            'client_id',
            'enabled',
            'enrollment_flow',
            'name',
            'ordering',
            'page',
            'page_size',
            'policy_engine_mode',
            'search',
            'slug',
            'user_matching_mode'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_plex_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('allow_friends') is not None:  # noqa: E501
            _query_params.append(('allow_friends', _params['allow_friends']))

        if _params.get('authentication_flow') is not None:  # noqa: E501
            _query_params.append(('authentication_flow', _params['authentication_flow']))

        if _params.get('client_id') is not None:  # noqa: E501
            _query_params.append(('client_id', _params['client_id']))

        if _params.get('enabled') is not None:  # noqa: E501
            _query_params.append(('enabled', _params['enabled']))

        if _params.get('enrollment_flow') is not None:  # noqa: E501
            _query_params.append(('enrollment_flow', _params['enrollment_flow']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('policy_engine_mode') is not None:  # noqa: E501
            _query_params.append(('policy_engine_mode', _params['policy_engine_mode']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('slug') is not None:  # noqa: E501
            _query_params.append(('slug', _params['slug']))

        if _params.get('user_matching_mode') is not None:  # noqa: E501
            _query_params.append(('user_matching_mode', _params['user_matching_mode']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedPlexSourceList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/plex/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_plex_partial_update(self, slug : StrictStr, patched_plex_source_request : Optional[PatchedPlexSourceRequest] = None, **kwargs) -> PlexSource:  # noqa: E501
        """sources_plex_partial_update  # noqa: E501

        Plex source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_partial_update(slug, patched_plex_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param patched_plex_source_request:
        :type patched_plex_source_request: PatchedPlexSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PlexSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_plex_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_plex_partial_update_with_http_info(slug, patched_plex_source_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_plex_partial_update_with_http_info(self, slug : StrictStr, patched_plex_source_request : Optional[PatchedPlexSourceRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_plex_partial_update  # noqa: E501

        Plex source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_partial_update_with_http_info(slug, patched_plex_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param patched_plex_source_request:
        :type patched_plex_source_request: PatchedPlexSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PlexSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'patched_plex_source_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_plex_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_plex_source_request'] is not None:
            _body_params = _params['patched_plex_source_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PlexSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/plex/{slug}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_plex_redeem_token_authenticated_create(self, plex_token_redeem_request : PlexTokenRedeemRequest, slug : Optional[StrictStr] = None, **kwargs) -> None:  # noqa: E501
        """sources_plex_redeem_token_authenticated_create  # noqa: E501

        Redeem a plex token for an authenticated user, creating a connection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_redeem_token_authenticated_create(plex_token_redeem_request, slug, async_req=True)
        >>> result = thread.get()

        :param plex_token_redeem_request: (required)
        :type plex_token_redeem_request: PlexTokenRedeemRequest
        :param slug:
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_plex_redeem_token_authenticated_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_plex_redeem_token_authenticated_create_with_http_info(plex_token_redeem_request, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_plex_redeem_token_authenticated_create_with_http_info(self, plex_token_redeem_request : PlexTokenRedeemRequest, slug : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_plex_redeem_token_authenticated_create  # noqa: E501

        Redeem a plex token for an authenticated user, creating a connection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_redeem_token_authenticated_create_with_http_info(plex_token_redeem_request, slug, async_req=True)
        >>> result = thread.get()

        :param plex_token_redeem_request: (required)
        :type plex_token_redeem_request: PlexTokenRedeemRequest
        :param slug:
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'plex_token_redeem_request',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_plex_redeem_token_authenticated_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('slug') is not None:  # noqa: E501
            _query_params.append(('slug', _params['slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['plex_token_redeem_request'] is not None:
            _body_params = _params['plex_token_redeem_request']

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/sources/plex/redeem_token_authenticated/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_plex_redeem_token_create(self, plex_token_redeem_request : PlexTokenRedeemRequest, slug : Optional[StrictStr] = None, **kwargs) -> RedirectChallenge:  # noqa: E501
        """sources_plex_redeem_token_create  # noqa: E501

        Redeem a plex token, check it's access to resources against what's allowed for the source, and redirect to an authentication/enrollment flow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_redeem_token_create(plex_token_redeem_request, slug, async_req=True)
        >>> result = thread.get()

        :param plex_token_redeem_request: (required)
        :type plex_token_redeem_request: PlexTokenRedeemRequest
        :param slug:
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RedirectChallenge
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_plex_redeem_token_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_plex_redeem_token_create_with_http_info(plex_token_redeem_request, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_plex_redeem_token_create_with_http_info(self, plex_token_redeem_request : PlexTokenRedeemRequest, slug : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_plex_redeem_token_create  # noqa: E501

        Redeem a plex token, check it's access to resources against what's allowed for the source, and redirect to an authentication/enrollment flow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_redeem_token_create_with_http_info(plex_token_redeem_request, slug, async_req=True)
        >>> result = thread.get()

        :param plex_token_redeem_request: (required)
        :type plex_token_redeem_request: PlexTokenRedeemRequest
        :param slug:
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RedirectChallenge, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'plex_token_redeem_request',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_plex_redeem_token_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('slug') is not None:  # noqa: E501
            _query_params.append(('slug', _params['slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['plex_token_redeem_request'] is not None:
            _body_params = _params['plex_token_redeem_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "RedirectChallenge",
            '400': None,
            '403': None,
        }

        return self.api_client.call_api(
            '/sources/plex/redeem_token/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_plex_retrieve(self, slug : StrictStr, **kwargs) -> PlexSource:  # noqa: E501
        """sources_plex_retrieve  # noqa: E501

        Plex source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_retrieve(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PlexSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_plex_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_plex_retrieve_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_plex_retrieve_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_plex_retrieve  # noqa: E501

        Plex source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_retrieve_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PlexSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_plex_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PlexSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/plex/{slug}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_plex_update(self, slug : StrictStr, plex_source_request : PlexSourceRequest, **kwargs) -> PlexSource:  # noqa: E501
        """sources_plex_update  # noqa: E501

        Plex source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_update(slug, plex_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param plex_source_request: (required)
        :type plex_source_request: PlexSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PlexSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_plex_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_plex_update_with_http_info(slug, plex_source_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_plex_update_with_http_info(self, slug : StrictStr, plex_source_request : PlexSourceRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_plex_update  # noqa: E501

        Plex source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_update_with_http_info(slug, plex_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param plex_source_request: (required)
        :type plex_source_request: PlexSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PlexSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'plex_source_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_plex_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['plex_source_request'] is not None:
            _body_params = _params['plex_source_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PlexSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/plex/{slug}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_plex_used_by_list(self, slug : StrictStr, **kwargs) -> List[UsedBy]:  # noqa: E501
        """sources_plex_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_used_by_list(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_plex_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_plex_used_by_list_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_plex_used_by_list_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_plex_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_plex_used_by_list_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_plex_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/plex/{slug}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_saml_create(self, saml_source_request : SAMLSourceRequest, **kwargs) -> SAMLSource:  # noqa: E501
        """sources_saml_create  # noqa: E501

        SAMLSource Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_create(saml_source_request, async_req=True)
        >>> result = thread.get()

        :param saml_source_request: (required)
        :type saml_source_request: SAMLSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SAMLSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_saml_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_saml_create_with_http_info(saml_source_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_saml_create_with_http_info(self, saml_source_request : SAMLSourceRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_saml_create  # noqa: E501

        SAMLSource Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_create_with_http_info(saml_source_request, async_req=True)
        >>> result = thread.get()

        :param saml_source_request: (required)
        :type saml_source_request: SAMLSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SAMLSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'saml_source_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_saml_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['saml_source_request'] is not None:
            _body_params = _params['saml_source_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "SAMLSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/saml/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_saml_destroy(self, slug : StrictStr, **kwargs) -> None:  # noqa: E501
        """sources_saml_destroy  # noqa: E501

        SAMLSource Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_destroy(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_saml_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_saml_destroy_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_saml_destroy_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_saml_destroy  # noqa: E501

        SAMLSource Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_destroy_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_saml_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/sources/saml/{slug}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_saml_list(self, allow_idp_initiated : Optional[StrictBool] = None, authentication_flow : Optional[StrictStr] = None, binding_type : Annotated[Optional[StrictStr], Field(description="* `REDIRECT` - Redirect Binding * `POST` - POST Binding * `POST_AUTO` - POST Binding with auto-confirmation")] = None, digest_algorithm : Annotated[Optional[StrictStr], Field(description="* `http://www.w3.org/2000/09/xmldsig#sha1` - SHA1 * `http://www.w3.org/2001/04/xmlenc#sha256` - SHA256 * `http://www.w3.org/2001/04/xmldsig-more#sha384` - SHA384 * `http://www.w3.org/2001/04/xmlenc#sha512` - SHA512")] = None, enabled : Optional[StrictBool] = None, enrollment_flow : Optional[StrictStr] = None, issuer : Optional[StrictStr] = None, managed : Optional[StrictStr] = None, name : Optional[StrictStr] = None, name_id_policy : Annotated[Optional[StrictStr], Field(description="NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent.  * `urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress` - Email * `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` - Persistent * `urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName` - X509 * `urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName` - Windows * `urn:oasis:names:tc:SAML:2.0:nameid-format:transient` - Transient")] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, policy_engine_mode : Annotated[Optional[StrictStr], Field(description="* `all` - all, all policies must pass * `any` - any, any policy must pass")] = None, pre_authentication_flow : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, signature_algorithm : Annotated[Optional[StrictStr], Field(description="* `http://www.w3.org/2000/09/xmldsig#rsa-sha1` - RSA-SHA1 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha256` - RSA-SHA256 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha384` - RSA-SHA384 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha512` - RSA-SHA512 * `http://www.w3.org/2000/09/xmldsig#dsa-sha1` - DSA-SHA1")] = None, signing_kp : Optional[StrictStr] = None, slo_url : Optional[StrictStr] = None, slug : Optional[StrictStr] = None, sso_url : Optional[StrictStr] = None, temporary_user_delete_after : Optional[StrictStr] = None, user_matching_mode : Annotated[Optional[StrictStr], Field(description="How the source determines if an existing user should be authenticated or a new user enrolled.  * `identifier` - Use the source-specific identifier * `email_link` - Link to a user with identical email address. Can have security implications when a source doesn't validate email addresses. * `email_deny` - Use the user's email address, but deny enrollment when the email address already exists. * `username_link` - Link to a user with identical username. Can have security implications when a username is used with another source. * `username_deny` - Use the user's username, but deny enrollment when the username already exists.")] = None, verification_kp : Optional[StrictStr] = None, **kwargs) -> PaginatedSAMLSourceList:  # noqa: E501
        """sources_saml_list  # noqa: E501

        SAMLSource Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_list(allow_idp_initiated, authentication_flow, binding_type, digest_algorithm, enabled, enrollment_flow, issuer, managed, name, name_id_policy, ordering, page, page_size, policy_engine_mode, pre_authentication_flow, search, signature_algorithm, signing_kp, slo_url, slug, sso_url, temporary_user_delete_after, user_matching_mode, verification_kp, async_req=True)
        >>> result = thread.get()

        :param allow_idp_initiated:
        :type allow_idp_initiated: bool
        :param authentication_flow:
        :type authentication_flow: str
        :param binding_type: * `REDIRECT` - Redirect Binding * `POST` - POST Binding * `POST_AUTO` - POST Binding with auto-confirmation
        :type binding_type: str
        :param digest_algorithm: * `http://www.w3.org/2000/09/xmldsig#sha1` - SHA1 * `http://www.w3.org/2001/04/xmlenc#sha256` - SHA256 * `http://www.w3.org/2001/04/xmldsig-more#sha384` - SHA384 * `http://www.w3.org/2001/04/xmlenc#sha512` - SHA512
        :type digest_algorithm: str
        :param enabled:
        :type enabled: bool
        :param enrollment_flow:
        :type enrollment_flow: str
        :param issuer:
        :type issuer: str
        :param managed:
        :type managed: str
        :param name:
        :type name: str
        :param name_id_policy: NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent.  * `urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress` - Email * `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` - Persistent * `urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName` - X509 * `urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName` - Windows * `urn:oasis:names:tc:SAML:2.0:nameid-format:transient` - Transient
        :type name_id_policy: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param policy_engine_mode: * `all` - all, all policies must pass * `any` - any, any policy must pass
        :type policy_engine_mode: str
        :param pre_authentication_flow:
        :type pre_authentication_flow: str
        :param search: A search term.
        :type search: str
        :param signature_algorithm: * `http://www.w3.org/2000/09/xmldsig#rsa-sha1` - RSA-SHA1 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha256` - RSA-SHA256 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha384` - RSA-SHA384 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha512` - RSA-SHA512 * `http://www.w3.org/2000/09/xmldsig#dsa-sha1` - DSA-SHA1
        :type signature_algorithm: str
        :param signing_kp:
        :type signing_kp: str
        :param slo_url:
        :type slo_url: str
        :param slug:
        :type slug: str
        :param sso_url:
        :type sso_url: str
        :param temporary_user_delete_after:
        :type temporary_user_delete_after: str
        :param user_matching_mode: How the source determines if an existing user should be authenticated or a new user enrolled.  * `identifier` - Use the source-specific identifier * `email_link` - Link to a user with identical email address. Can have security implications when a source doesn't validate email addresses. * `email_deny` - Use the user's email address, but deny enrollment when the email address already exists. * `username_link` - Link to a user with identical username. Can have security implications when a username is used with another source. * `username_deny` - Use the user's username, but deny enrollment when the username already exists.
        :type user_matching_mode: str
        :param verification_kp:
        :type verification_kp: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedSAMLSourceList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_saml_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_saml_list_with_http_info(allow_idp_initiated, authentication_flow, binding_type, digest_algorithm, enabled, enrollment_flow, issuer, managed, name, name_id_policy, ordering, page, page_size, policy_engine_mode, pre_authentication_flow, search, signature_algorithm, signing_kp, slo_url, slug, sso_url, temporary_user_delete_after, user_matching_mode, verification_kp, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_saml_list_with_http_info(self, allow_idp_initiated : Optional[StrictBool] = None, authentication_flow : Optional[StrictStr] = None, binding_type : Annotated[Optional[StrictStr], Field(description="* `REDIRECT` - Redirect Binding * `POST` - POST Binding * `POST_AUTO` - POST Binding with auto-confirmation")] = None, digest_algorithm : Annotated[Optional[StrictStr], Field(description="* `http://www.w3.org/2000/09/xmldsig#sha1` - SHA1 * `http://www.w3.org/2001/04/xmlenc#sha256` - SHA256 * `http://www.w3.org/2001/04/xmldsig-more#sha384` - SHA384 * `http://www.w3.org/2001/04/xmlenc#sha512` - SHA512")] = None, enabled : Optional[StrictBool] = None, enrollment_flow : Optional[StrictStr] = None, issuer : Optional[StrictStr] = None, managed : Optional[StrictStr] = None, name : Optional[StrictStr] = None, name_id_policy : Annotated[Optional[StrictStr], Field(description="NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent.  * `urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress` - Email * `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` - Persistent * `urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName` - X509 * `urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName` - Windows * `urn:oasis:names:tc:SAML:2.0:nameid-format:transient` - Transient")] = None, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, policy_engine_mode : Annotated[Optional[StrictStr], Field(description="* `all` - all, all policies must pass * `any` - any, any policy must pass")] = None, pre_authentication_flow : Optional[StrictStr] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, signature_algorithm : Annotated[Optional[StrictStr], Field(description="* `http://www.w3.org/2000/09/xmldsig#rsa-sha1` - RSA-SHA1 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha256` - RSA-SHA256 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha384` - RSA-SHA384 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha512` - RSA-SHA512 * `http://www.w3.org/2000/09/xmldsig#dsa-sha1` - DSA-SHA1")] = None, signing_kp : Optional[StrictStr] = None, slo_url : Optional[StrictStr] = None, slug : Optional[StrictStr] = None, sso_url : Optional[StrictStr] = None, temporary_user_delete_after : Optional[StrictStr] = None, user_matching_mode : Annotated[Optional[StrictStr], Field(description="How the source determines if an existing user should be authenticated or a new user enrolled.  * `identifier` - Use the source-specific identifier * `email_link` - Link to a user with identical email address. Can have security implications when a source doesn't validate email addresses. * `email_deny` - Use the user's email address, but deny enrollment when the email address already exists. * `username_link` - Link to a user with identical username. Can have security implications when a username is used with another source. * `username_deny` - Use the user's username, but deny enrollment when the username already exists.")] = None, verification_kp : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_saml_list  # noqa: E501

        SAMLSource Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_list_with_http_info(allow_idp_initiated, authentication_flow, binding_type, digest_algorithm, enabled, enrollment_flow, issuer, managed, name, name_id_policy, ordering, page, page_size, policy_engine_mode, pre_authentication_flow, search, signature_algorithm, signing_kp, slo_url, slug, sso_url, temporary_user_delete_after, user_matching_mode, verification_kp, async_req=True)
        >>> result = thread.get()

        :param allow_idp_initiated:
        :type allow_idp_initiated: bool
        :param authentication_flow:
        :type authentication_flow: str
        :param binding_type: * `REDIRECT` - Redirect Binding * `POST` - POST Binding * `POST_AUTO` - POST Binding with auto-confirmation
        :type binding_type: str
        :param digest_algorithm: * `http://www.w3.org/2000/09/xmldsig#sha1` - SHA1 * `http://www.w3.org/2001/04/xmlenc#sha256` - SHA256 * `http://www.w3.org/2001/04/xmldsig-more#sha384` - SHA384 * `http://www.w3.org/2001/04/xmlenc#sha512` - SHA512
        :type digest_algorithm: str
        :param enabled:
        :type enabled: bool
        :param enrollment_flow:
        :type enrollment_flow: str
        :param issuer:
        :type issuer: str
        :param managed:
        :type managed: str
        :param name:
        :type name: str
        :param name_id_policy: NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent.  * `urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress` - Email * `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` - Persistent * `urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName` - X509 * `urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName` - Windows * `urn:oasis:names:tc:SAML:2.0:nameid-format:transient` - Transient
        :type name_id_policy: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param policy_engine_mode: * `all` - all, all policies must pass * `any` - any, any policy must pass
        :type policy_engine_mode: str
        :param pre_authentication_flow:
        :type pre_authentication_flow: str
        :param search: A search term.
        :type search: str
        :param signature_algorithm: * `http://www.w3.org/2000/09/xmldsig#rsa-sha1` - RSA-SHA1 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha256` - RSA-SHA256 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha384` - RSA-SHA384 * `http://www.w3.org/2001/04/xmldsig-more#rsa-sha512` - RSA-SHA512 * `http://www.w3.org/2000/09/xmldsig#dsa-sha1` - DSA-SHA1
        :type signature_algorithm: str
        :param signing_kp:
        :type signing_kp: str
        :param slo_url:
        :type slo_url: str
        :param slug:
        :type slug: str
        :param sso_url:
        :type sso_url: str
        :param temporary_user_delete_after:
        :type temporary_user_delete_after: str
        :param user_matching_mode: How the source determines if an existing user should be authenticated or a new user enrolled.  * `identifier` - Use the source-specific identifier * `email_link` - Link to a user with identical email address. Can have security implications when a source doesn't validate email addresses. * `email_deny` - Use the user's email address, but deny enrollment when the email address already exists. * `username_link` - Link to a user with identical username. Can have security implications when a username is used with another source. * `username_deny` - Use the user's username, but deny enrollment when the username already exists.
        :type user_matching_mode: str
        :param verification_kp:
        :type verification_kp: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedSAMLSourceList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'allow_idp_initiated',
            'authentication_flow',
            'binding_type',
            'digest_algorithm',
            'enabled',
            'enrollment_flow',
            'issuer',
            'managed',
            'name',
            'name_id_policy',
            'ordering',
            'page',
            'page_size',
            'policy_engine_mode',
            'pre_authentication_flow',
            'search',
            'signature_algorithm',
            'signing_kp',
            'slo_url',
            'slug',
            'sso_url',
            'temporary_user_delete_after',
            'user_matching_mode',
            'verification_kp'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_saml_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('allow_idp_initiated') is not None:  # noqa: E501
            _query_params.append(('allow_idp_initiated', _params['allow_idp_initiated']))

        if _params.get('authentication_flow') is not None:  # noqa: E501
            _query_params.append(('authentication_flow', _params['authentication_flow']))

        if _params.get('binding_type') is not None:  # noqa: E501
            _query_params.append(('binding_type', _params['binding_type']))

        if _params.get('digest_algorithm') is not None:  # noqa: E501
            _query_params.append(('digest_algorithm', _params['digest_algorithm']))

        if _params.get('enabled') is not None:  # noqa: E501
            _query_params.append(('enabled', _params['enabled']))

        if _params.get('enrollment_flow') is not None:  # noqa: E501
            _query_params.append(('enrollment_flow', _params['enrollment_flow']))

        if _params.get('issuer') is not None:  # noqa: E501
            _query_params.append(('issuer', _params['issuer']))

        if _params.get('managed') is not None:  # noqa: E501
            _query_params.append(('managed', _params['managed']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('name_id_policy') is not None:  # noqa: E501
            _query_params.append(('name_id_policy', _params['name_id_policy']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('policy_engine_mode') is not None:  # noqa: E501
            _query_params.append(('policy_engine_mode', _params['policy_engine_mode']))

        if _params.get('pre_authentication_flow') is not None:  # noqa: E501
            _query_params.append(('pre_authentication_flow', _params['pre_authentication_flow']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('signature_algorithm') is not None:  # noqa: E501
            _query_params.append(('signature_algorithm', _params['signature_algorithm']))

        if _params.get('signing_kp') is not None:  # noqa: E501
            _query_params.append(('signing_kp', _params['signing_kp']))

        if _params.get('slo_url') is not None:  # noqa: E501
            _query_params.append(('slo_url', _params['slo_url']))

        if _params.get('slug') is not None:  # noqa: E501
            _query_params.append(('slug', _params['slug']))

        if _params.get('sso_url') is not None:  # noqa: E501
            _query_params.append(('sso_url', _params['sso_url']))

        if _params.get('temporary_user_delete_after') is not None:  # noqa: E501
            _query_params.append(('temporary_user_delete_after', _params['temporary_user_delete_after']))

        if _params.get('user_matching_mode') is not None:  # noqa: E501
            _query_params.append(('user_matching_mode', _params['user_matching_mode']))

        if _params.get('verification_kp') is not None:  # noqa: E501
            _query_params.append(('verification_kp', _params['verification_kp']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedSAMLSourceList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/saml/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_saml_metadata_retrieve(self, slug : StrictStr, **kwargs) -> SAMLMetadata:  # noqa: E501
        """sources_saml_metadata_retrieve  # noqa: E501

        Return metadata as XML string  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_metadata_retrieve(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SAMLMetadata
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_saml_metadata_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_saml_metadata_retrieve_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_saml_metadata_retrieve_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_saml_metadata_retrieve  # noqa: E501

        Return metadata as XML string  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_metadata_retrieve_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SAMLMetadata, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_saml_metadata_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "SAMLMetadata",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/saml/{slug}/metadata/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_saml_partial_update(self, slug : StrictStr, patched_saml_source_request : Optional[PatchedSAMLSourceRequest] = None, **kwargs) -> SAMLSource:  # noqa: E501
        """sources_saml_partial_update  # noqa: E501

        SAMLSource Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_partial_update(slug, patched_saml_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param patched_saml_source_request:
        :type patched_saml_source_request: PatchedSAMLSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SAMLSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_saml_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_saml_partial_update_with_http_info(slug, patched_saml_source_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_saml_partial_update_with_http_info(self, slug : StrictStr, patched_saml_source_request : Optional[PatchedSAMLSourceRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_saml_partial_update  # noqa: E501

        SAMLSource Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_partial_update_with_http_info(slug, patched_saml_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param patched_saml_source_request:
        :type patched_saml_source_request: PatchedSAMLSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SAMLSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'patched_saml_source_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_saml_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_saml_source_request'] is not None:
            _body_params = _params['patched_saml_source_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "SAMLSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/saml/{slug}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_saml_retrieve(self, slug : StrictStr, **kwargs) -> SAMLSource:  # noqa: E501
        """sources_saml_retrieve  # noqa: E501

        SAMLSource Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_retrieve(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SAMLSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_saml_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_saml_retrieve_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_saml_retrieve_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_saml_retrieve  # noqa: E501

        SAMLSource Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_retrieve_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SAMLSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_saml_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "SAMLSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/saml/{slug}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_saml_update(self, slug : StrictStr, saml_source_request : SAMLSourceRequest, **kwargs) -> SAMLSource:  # noqa: E501
        """sources_saml_update  # noqa: E501

        SAMLSource Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_update(slug, saml_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param saml_source_request: (required)
        :type saml_source_request: SAMLSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SAMLSource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_saml_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_saml_update_with_http_info(slug, saml_source_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_saml_update_with_http_info(self, slug : StrictStr, saml_source_request : SAMLSourceRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_saml_update  # noqa: E501

        SAMLSource Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_update_with_http_info(slug, saml_source_request, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param saml_source_request: (required)
        :type saml_source_request: SAMLSourceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SAMLSource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'saml_source_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_saml_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['saml_source_request'] is not None:
            _body_params = _params['saml_source_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "SAMLSource",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/saml/{slug}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_saml_used_by_list(self, slug : StrictStr, **kwargs) -> List[UsedBy]:  # noqa: E501
        """sources_saml_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_used_by_list(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_saml_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_saml_used_by_list_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_saml_used_by_list_with_http_info(self, slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_saml_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_saml_used_by_list_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_saml_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug']:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/saml/{slug}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_all_destroy(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this user source connection.")], **kwargs) -> None:  # noqa: E501
        """sources_user_connections_all_destroy  # noqa: E501

        User-source connection Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_all_destroy(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this user source connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_all_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_all_destroy_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_all_destroy_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this user source connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_all_destroy  # noqa: E501

        User-source connection Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_all_destroy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this user source connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_all_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/sources/user_connections/all/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_all_list(self, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, user : Optional[StrictInt] = None, **kwargs) -> PaginatedUserSourceConnectionList:  # noqa: E501
        """sources_user_connections_all_list  # noqa: E501

        User-source connection Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_all_list(ordering, page, page_size, search, user, async_req=True)
        >>> result = thread.get()

        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param user:
        :type user: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedUserSourceConnectionList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_all_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_all_list_with_http_info(ordering, page, page_size, search, user, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_all_list_with_http_info(self, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, user : Optional[StrictInt] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_all_list  # noqa: E501

        User-source connection Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_all_list_with_http_info(ordering, page, page_size, search, user, async_req=True)
        >>> result = thread.get()

        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param user:
        :type user: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedUserSourceConnectionList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ordering',
            'page',
            'page_size',
            'search',
            'user'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_all_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('user') is not None:  # noqa: E501
            _query_params.append(('user', _params['user']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedUserSourceConnectionList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/all/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_all_partial_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this user source connection.")], **kwargs) -> UserSourceConnection:  # noqa: E501
        """sources_user_connections_all_partial_update  # noqa: E501

        User-source connection Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_all_partial_update(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this user source connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_all_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_all_partial_update_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_all_partial_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this user source connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_all_partial_update  # noqa: E501

        User-source connection Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_all_partial_update_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this user source connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_all_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/all/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_all_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this user source connection.")], **kwargs) -> UserSourceConnection:  # noqa: E501
        """sources_user_connections_all_retrieve  # noqa: E501

        User-source connection Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_all_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this user source connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_all_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_all_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_all_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this user source connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_all_retrieve  # noqa: E501

        User-source connection Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_all_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this user source connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_all_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/all/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_all_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this user source connection.")], **kwargs) -> UserSourceConnection:  # noqa: E501
        """sources_user_connections_all_update  # noqa: E501

        User-source connection Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_all_update(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this user source connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_all_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_all_update_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_all_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this user source connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_all_update  # noqa: E501

        User-source connection Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_all_update_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this user source connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_all_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/all/{id}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_all_used_by_list(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this user source connection.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """sources_user_connections_all_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_all_used_by_list(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this user source connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_all_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_all_used_by_list_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_all_used_by_list_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this user source connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_all_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_all_used_by_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this user source connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_all_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/all/{id}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_oauth_create(self, user_o_auth_source_connection_request : UserOAuthSourceConnectionRequest, **kwargs) -> UserOAuthSourceConnection:  # noqa: E501
        """sources_user_connections_oauth_create  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_create(user_o_auth_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param user_o_auth_source_connection_request: (required)
        :type user_o_auth_source_connection_request: UserOAuthSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserOAuthSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_oauth_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_oauth_create_with_http_info(user_o_auth_source_connection_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_oauth_create_with_http_info(self, user_o_auth_source_connection_request : UserOAuthSourceConnectionRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_oauth_create  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_create_with_http_info(user_o_auth_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param user_o_auth_source_connection_request: (required)
        :type user_o_auth_source_connection_request: UserOAuthSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserOAuthSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'user_o_auth_source_connection_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_oauth_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['user_o_auth_source_connection_request'] is not None:
            _body_params = _params['user_o_auth_source_connection_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "UserOAuthSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/oauth/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_oauth_destroy(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User OAuth Source Connection.")], **kwargs) -> None:  # noqa: E501
        """sources_user_connections_oauth_destroy  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_destroy(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User OAuth Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_oauth_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_oauth_destroy_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_oauth_destroy_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User OAuth Source Connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_oauth_destroy  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_destroy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User OAuth Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_oauth_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/sources/user_connections/oauth/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_oauth_list(self, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, source__slug : Optional[StrictStr] = None, **kwargs) -> PaginatedUserOAuthSourceConnectionList:  # noqa: E501
        """sources_user_connections_oauth_list  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_list(ordering, page, page_size, search, source__slug, async_req=True)
        >>> result = thread.get()

        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param source__slug:
        :type source__slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedUserOAuthSourceConnectionList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_oauth_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_oauth_list_with_http_info(ordering, page, page_size, search, source__slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_oauth_list_with_http_info(self, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, source__slug : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_oauth_list  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_list_with_http_info(ordering, page, page_size, search, source__slug, async_req=True)
        >>> result = thread.get()

        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param source__slug:
        :type source__slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedUserOAuthSourceConnectionList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ordering',
            'page',
            'page_size',
            'search',
            'source__slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_oauth_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('source__slug') is not None:  # noqa: E501
            _query_params.append(('source__slug', _params['source__slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedUserOAuthSourceConnectionList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/oauth/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_oauth_partial_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User OAuth Source Connection.")], patched_user_o_auth_source_connection_request : Optional[PatchedUserOAuthSourceConnectionRequest] = None, **kwargs) -> UserOAuthSourceConnection:  # noqa: E501
        """sources_user_connections_oauth_partial_update  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_partial_update(id, patched_user_o_auth_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User OAuth Source Connection. (required)
        :type id: int
        :param patched_user_o_auth_source_connection_request:
        :type patched_user_o_auth_source_connection_request: PatchedUserOAuthSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserOAuthSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_oauth_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_oauth_partial_update_with_http_info(id, patched_user_o_auth_source_connection_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_oauth_partial_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User OAuth Source Connection.")], patched_user_o_auth_source_connection_request : Optional[PatchedUserOAuthSourceConnectionRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_oauth_partial_update  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_partial_update_with_http_info(id, patched_user_o_auth_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User OAuth Source Connection. (required)
        :type id: int
        :param patched_user_o_auth_source_connection_request:
        :type patched_user_o_auth_source_connection_request: PatchedUserOAuthSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserOAuthSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'patched_user_o_auth_source_connection_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_oauth_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_user_o_auth_source_connection_request'] is not None:
            _body_params = _params['patched_user_o_auth_source_connection_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserOAuthSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/oauth/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_oauth_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User OAuth Source Connection.")], **kwargs) -> UserOAuthSourceConnection:  # noqa: E501
        """sources_user_connections_oauth_retrieve  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User OAuth Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserOAuthSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_oauth_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_oauth_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_oauth_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User OAuth Source Connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_oauth_retrieve  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User OAuth Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserOAuthSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_oauth_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserOAuthSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/oauth/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_oauth_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User OAuth Source Connection.")], user_o_auth_source_connection_request : UserOAuthSourceConnectionRequest, **kwargs) -> UserOAuthSourceConnection:  # noqa: E501
        """sources_user_connections_oauth_update  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_update(id, user_o_auth_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User OAuth Source Connection. (required)
        :type id: int
        :param user_o_auth_source_connection_request: (required)
        :type user_o_auth_source_connection_request: UserOAuthSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserOAuthSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_oauth_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_oauth_update_with_http_info(id, user_o_auth_source_connection_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_oauth_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User OAuth Source Connection.")], user_o_auth_source_connection_request : UserOAuthSourceConnectionRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_oauth_update  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_update_with_http_info(id, user_o_auth_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User OAuth Source Connection. (required)
        :type id: int
        :param user_o_auth_source_connection_request: (required)
        :type user_o_auth_source_connection_request: UserOAuthSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserOAuthSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'user_o_auth_source_connection_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_oauth_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['user_o_auth_source_connection_request'] is not None:
            _body_params = _params['user_o_auth_source_connection_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserOAuthSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/oauth/{id}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_oauth_used_by_list(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User OAuth Source Connection.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """sources_user_connections_oauth_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_used_by_list(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User OAuth Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_oauth_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_oauth_used_by_list_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_oauth_used_by_list_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User OAuth Source Connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_oauth_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_oauth_used_by_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User OAuth Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_oauth_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/oauth/{id}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_plex_create(self, plex_source_connection_request : PlexSourceConnectionRequest, **kwargs) -> PlexSourceConnection:  # noqa: E501
        """sources_user_connections_plex_create  # noqa: E501

        Plex Source connection Serializer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_create(plex_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param plex_source_connection_request: (required)
        :type plex_source_connection_request: PlexSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PlexSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_plex_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_plex_create_with_http_info(plex_source_connection_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_plex_create_with_http_info(self, plex_source_connection_request : PlexSourceConnectionRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_plex_create  # noqa: E501

        Plex Source connection Serializer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_create_with_http_info(plex_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param plex_source_connection_request: (required)
        :type plex_source_connection_request: PlexSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PlexSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'plex_source_connection_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_plex_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['plex_source_connection_request'] is not None:
            _body_params = _params['plex_source_connection_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "PlexSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/plex/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_plex_destroy(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User Plex Source Connection.")], **kwargs) -> None:  # noqa: E501
        """sources_user_connections_plex_destroy  # noqa: E501

        Plex Source connection Serializer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_destroy(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User Plex Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_plex_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_plex_destroy_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_plex_destroy_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User Plex Source Connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_plex_destroy  # noqa: E501

        Plex Source connection Serializer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_destroy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User Plex Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_plex_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/sources/user_connections/plex/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_plex_list(self, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, source__slug : Optional[StrictStr] = None, **kwargs) -> PaginatedPlexSourceConnectionList:  # noqa: E501
        """sources_user_connections_plex_list  # noqa: E501

        Plex Source connection Serializer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_list(ordering, page, page_size, search, source__slug, async_req=True)
        >>> result = thread.get()

        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param source__slug:
        :type source__slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedPlexSourceConnectionList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_plex_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_plex_list_with_http_info(ordering, page, page_size, search, source__slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_plex_list_with_http_info(self, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, source__slug : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_plex_list  # noqa: E501

        Plex Source connection Serializer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_list_with_http_info(ordering, page, page_size, search, source__slug, async_req=True)
        >>> result = thread.get()

        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param source__slug:
        :type source__slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedPlexSourceConnectionList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ordering',
            'page',
            'page_size',
            'search',
            'source__slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_plex_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('source__slug') is not None:  # noqa: E501
            _query_params.append(('source__slug', _params['source__slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedPlexSourceConnectionList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/plex/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_plex_partial_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User Plex Source Connection.")], patched_plex_source_connection_request : Optional[PatchedPlexSourceConnectionRequest] = None, **kwargs) -> PlexSourceConnection:  # noqa: E501
        """sources_user_connections_plex_partial_update  # noqa: E501

        Plex Source connection Serializer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_partial_update(id, patched_plex_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User Plex Source Connection. (required)
        :type id: int
        :param patched_plex_source_connection_request:
        :type patched_plex_source_connection_request: PatchedPlexSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PlexSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_plex_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_plex_partial_update_with_http_info(id, patched_plex_source_connection_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_plex_partial_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User Plex Source Connection.")], patched_plex_source_connection_request : Optional[PatchedPlexSourceConnectionRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_plex_partial_update  # noqa: E501

        Plex Source connection Serializer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_partial_update_with_http_info(id, patched_plex_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User Plex Source Connection. (required)
        :type id: int
        :param patched_plex_source_connection_request:
        :type patched_plex_source_connection_request: PatchedPlexSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PlexSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'patched_plex_source_connection_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_plex_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_plex_source_connection_request'] is not None:
            _body_params = _params['patched_plex_source_connection_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PlexSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/plex/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_plex_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User Plex Source Connection.")], **kwargs) -> PlexSourceConnection:  # noqa: E501
        """sources_user_connections_plex_retrieve  # noqa: E501

        Plex Source connection Serializer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User Plex Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PlexSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_plex_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_plex_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_plex_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User Plex Source Connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_plex_retrieve  # noqa: E501

        Plex Source connection Serializer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User Plex Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PlexSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_plex_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PlexSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/plex/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_plex_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User Plex Source Connection.")], plex_source_connection_request : PlexSourceConnectionRequest, **kwargs) -> PlexSourceConnection:  # noqa: E501
        """sources_user_connections_plex_update  # noqa: E501

        Plex Source connection Serializer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_update(id, plex_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User Plex Source Connection. (required)
        :type id: int
        :param plex_source_connection_request: (required)
        :type plex_source_connection_request: PlexSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PlexSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_plex_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_plex_update_with_http_info(id, plex_source_connection_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_plex_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User Plex Source Connection.")], plex_source_connection_request : PlexSourceConnectionRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_plex_update  # noqa: E501

        Plex Source connection Serializer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_update_with_http_info(id, plex_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User Plex Source Connection. (required)
        :type id: int
        :param plex_source_connection_request: (required)
        :type plex_source_connection_request: PlexSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PlexSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'plex_source_connection_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_plex_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['plex_source_connection_request'] is not None:
            _body_params = _params['plex_source_connection_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PlexSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/plex/{id}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_plex_used_by_list(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User Plex Source Connection.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """sources_user_connections_plex_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_used_by_list(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User Plex Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_plex_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_plex_used_by_list_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_plex_used_by_list_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User Plex Source Connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_plex_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_plex_used_by_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User Plex Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_plex_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/plex/{id}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_saml_create(self, user_saml_source_connection_request : UserSAMLSourceConnectionRequest, **kwargs) -> UserSAMLSourceConnection:  # noqa: E501
        """sources_user_connections_saml_create  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_create(user_saml_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param user_saml_source_connection_request: (required)
        :type user_saml_source_connection_request: UserSAMLSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserSAMLSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_saml_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_saml_create_with_http_info(user_saml_source_connection_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_saml_create_with_http_info(self, user_saml_source_connection_request : UserSAMLSourceConnectionRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_saml_create  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_create_with_http_info(user_saml_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param user_saml_source_connection_request: (required)
        :type user_saml_source_connection_request: UserSAMLSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserSAMLSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'user_saml_source_connection_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_saml_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['user_saml_source_connection_request'] is not None:
            _body_params = _params['user_saml_source_connection_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '201': "UserSAMLSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/saml/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_saml_destroy(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User SAML Source Connection.")], **kwargs) -> None:  # noqa: E501
        """sources_user_connections_saml_destroy  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_destroy(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User SAML Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_saml_destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_saml_destroy_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_saml_destroy_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User SAML Source Connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_saml_destroy  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_destroy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User SAML Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_saml_destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/sources/user_connections/saml/{id}/', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_saml_list(self, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, source__slug : Optional[StrictStr] = None, **kwargs) -> PaginatedUserSAMLSourceConnectionList:  # noqa: E501
        """sources_user_connections_saml_list  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_list(ordering, page, page_size, search, source__slug, async_req=True)
        >>> result = thread.get()

        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param source__slug:
        :type source__slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedUserSAMLSourceConnectionList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_saml_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_saml_list_with_http_info(ordering, page, page_size, search, source__slug, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_saml_list_with_http_info(self, ordering : Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None, page : Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None, search : Annotated[Optional[StrictStr], Field(description="A search term.")] = None, source__slug : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_saml_list  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_list_with_http_info(ordering, page, page_size, search, source__slug, async_req=True)
        >>> result = thread.get()

        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param page_size: Number of results to return per page.
        :type page_size: int
        :param search: A search term.
        :type search: str
        :param source__slug:
        :type source__slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedUserSAMLSourceConnectionList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ordering',
            'page',
            'page_size',
            'search',
            'source__slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_saml_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('source__slug') is not None:  # noqa: E501
            _query_params.append(('source__slug', _params['source__slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "PaginatedUserSAMLSourceConnectionList",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/saml/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_saml_partial_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User SAML Source Connection.")], patched_user_saml_source_connection_request : Optional[PatchedUserSAMLSourceConnectionRequest] = None, **kwargs) -> UserSAMLSourceConnection:  # noqa: E501
        """sources_user_connections_saml_partial_update  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_partial_update(id, patched_user_saml_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User SAML Source Connection. (required)
        :type id: int
        :param patched_user_saml_source_connection_request:
        :type patched_user_saml_source_connection_request: PatchedUserSAMLSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserSAMLSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_saml_partial_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_saml_partial_update_with_http_info(id, patched_user_saml_source_connection_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_saml_partial_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User SAML Source Connection.")], patched_user_saml_source_connection_request : Optional[PatchedUserSAMLSourceConnectionRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_saml_partial_update  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_partial_update_with_http_info(id, patched_user_saml_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User SAML Source Connection. (required)
        :type id: int
        :param patched_user_saml_source_connection_request:
        :type patched_user_saml_source_connection_request: PatchedUserSAMLSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserSAMLSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'patched_user_saml_source_connection_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_saml_partial_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patched_user_saml_source_connection_request'] is not None:
            _body_params = _params['patched_user_saml_source_connection_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserSAMLSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/saml/{id}/', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_saml_retrieve(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User SAML Source Connection.")], **kwargs) -> UserSAMLSourceConnection:  # noqa: E501
        """sources_user_connections_saml_retrieve  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_retrieve(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User SAML Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserSAMLSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_saml_retrieve_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_saml_retrieve_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_saml_retrieve_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User SAML Source Connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_saml_retrieve  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_retrieve_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User SAML Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserSAMLSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_saml_retrieve" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserSAMLSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/saml/{id}/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_saml_update(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User SAML Source Connection.")], user_saml_source_connection_request : UserSAMLSourceConnectionRequest, **kwargs) -> UserSAMLSourceConnection:  # noqa: E501
        """sources_user_connections_saml_update  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_update(id, user_saml_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User SAML Source Connection. (required)
        :type id: int
        :param user_saml_source_connection_request: (required)
        :type user_saml_source_connection_request: UserSAMLSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserSAMLSourceConnection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_saml_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_saml_update_with_http_info(id, user_saml_source_connection_request, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_saml_update_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User SAML Source Connection.")], user_saml_source_connection_request : UserSAMLSourceConnectionRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_saml_update  # noqa: E501

        Source Viewset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_update_with_http_info(id, user_saml_source_connection_request, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User SAML Source Connection. (required)
        :type id: int
        :param user_saml_source_connection_request: (required)
        :type user_saml_source_connection_request: UserSAMLSourceConnectionRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserSAMLSourceConnection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'user_saml_source_connection_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_saml_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['user_saml_source_connection_request'] is not None:
            _body_params = _params['user_saml_source_connection_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "UserSAMLSourceConnection",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/saml/{id}/', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def sources_user_connections_saml_used_by_list(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User SAML Source Connection.")], **kwargs) -> List[UsedBy]:  # noqa: E501
        """sources_user_connections_saml_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_used_by_list(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User SAML Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UsedBy]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the sources_user_connections_saml_used_by_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.sources_user_connections_saml_used_by_list_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def sources_user_connections_saml_used_by_list_with_http_info(self, id : Annotated[StrictInt, Field(..., description="A unique integer value identifying this User SAML Source Connection.")], **kwargs) -> ApiResponse:  # noqa: E501
        """sources_user_connections_saml_used_by_list  # noqa: E501

        Get a list of all objects that use this object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sources_user_connections_saml_used_by_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: A unique integer value identifying this User SAML Source Connection. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UsedBy], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sources_user_connections_saml_used_by_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['authentik']  # noqa: E501

        _response_types_map = {
            '200': "List[UsedBy]",
            '400': "ValidationError",
            '403': "GenericError",
        }

        return self.api_client.call_api(
            '/sources/user_connections/saml/{id}/used_by/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
